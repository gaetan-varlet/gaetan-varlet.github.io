{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Sommaire de mes diff\u00e9rents d\u00e9p\u00f4ts Tutoriels Tutoriel HTML CSS fiches exercice de cr\u00e9ation d'une page d'accueil d'une agence de voyage d\u00e9p\u00f4t page Web Tutoriel JavaScript fiches exercice de cr\u00e9ation du jeu du snake (version avec webpack) d\u00e9p\u00f4t page Web exercice de cr\u00e9ation de l'application World Bucket List d\u00e9p\u00f4t page Web Tutoriel jQuery (TODO) Tutoriel Bootstrap (TODO) Tutoriel React-Redux Tutoriel Java (DOING) Tutoriel Java EE (DOING) Tutoriel Python (DOING) Tutoriel SQL (DOING) Tutoriel Git (DOING) Tutoriel Linux (DOING) Tutoriel Docker Tutoriel VS Code (DOING) Formation API Rest D\u00e9p\u00f4t Diaporama Formation Spring Data (TODO) Projets Advent Of Code Rapport Biture-Prix Project d\u00e9p\u00f4t page Web Parseur CSV Divers Fiche pour l'examen d'analyste d\u00e9veloppeur Fiche pour le concours d'Attach\u00e9 Principal Int\u00e9gration continue Gitlab","title":"Sommaire"},{"location":"#sommaire-de-mes-differents-depots","text":"","title":"Sommaire de mes diff\u00e9rents d\u00e9p\u00f4ts"},{"location":"#tutoriels","text":"Tutoriel HTML CSS fiches exercice de cr\u00e9ation d'une page d'accueil d'une agence de voyage d\u00e9p\u00f4t page Web Tutoriel JavaScript fiches exercice de cr\u00e9ation du jeu du snake (version avec webpack) d\u00e9p\u00f4t page Web exercice de cr\u00e9ation de l'application World Bucket List d\u00e9p\u00f4t page Web Tutoriel jQuery (TODO) Tutoriel Bootstrap (TODO) Tutoriel React-Redux Tutoriel Java (DOING) Tutoriel Java EE (DOING) Tutoriel Python (DOING) Tutoriel SQL (DOING) Tutoriel Git (DOING) Tutoriel Linux (DOING) Tutoriel Docker Tutoriel VS Code (DOING) Formation API Rest D\u00e9p\u00f4t Diaporama Formation Spring Data (TODO)","title":"Tutoriels"},{"location":"#projets","text":"Advent Of Code Rapport Biture-Prix Project d\u00e9p\u00f4t page Web Parseur CSV","title":"Projets"},{"location":"#divers","text":"Fiche pour l'examen d'analyste d\u00e9veloppeur Fiche pour le concours d'Attach\u00e9 Principal Int\u00e9gration continue Gitlab","title":"Divers"},{"location":"html-css/","text":"","title":"HTML/CSS"},{"location":"md1/","text":"","title":"Md1"},{"location":"md2/","text":"","title":"Md2"},{"location":"md3/","text":"","title":"Md3"},{"location":"tutoriel-linux/","text":"Tutoriel Linux Raccourcis utiles Alt + Ctrl + T permet d'ouvrir un terminal Ctrl + D fin de fichier, ou exit . ferme le terminal Tab permet de faire de l\u2019auto-compl\u00e9tion Ctrl + R permet de faire une recherche parmi les commandes pr\u00e9c\u00e9dentes Ctrl + C arr\u00eate la commande en cours Ctrl + L ou clear efface le contenu de la console Shift + PgUp et Shift + PgDown pour monter et descendre dans la console Ctrl + A ram\u00e8ne le curseur au d\u00e9but de la commande, Ctrl + E ou Fin ram\u00e8ne le curseur \u00e0 la de la commande Ctrl + U supprime ce qui se trouve \u00e0 gauche du curseur, Ctrl + K ce qui se trouve \u00e0 droite Ctrl + W supprime le premier mot \u00e0 gauche du curseur, utile pour supprimer ke param\u00e8tre \u00e0 gauche du curseur Ctrl + Y permet de coller le texte coup\u00e9 avec Ctrl + U , Ctrl + K ou Ctrl + W Les r\u00e9pertoires /bin pour binaires contient les commandes dont le syst\u00e8me \u00e0 besoin pour d\u00e9marrer /boot est le r\u00e9pertoire o\u00f9 Linux range ce qu'il faut pour d\u00e9marrer. Les fichiers vmlinuz sont les diff\u00e9rents noyaux, on en utilise un seul \u00e0 la fois /dev pour device ou p\u00e9riph\u00e9rique en fran\u00e7ais, contient un fichier pour chaque p\u00e9riph\u00e9rique /etc pour Editable Text Configuration ou configuration \u00e9ditable par texte /lib pour libraries ou biblioth\u00e8qes contient les biblioth\u00e8ques partag\u00e9es par /bin et /sbin /media et /mnt sont les points de montage du syst\u00e8me. /run est un ajout r\u00e9cent qui doit prendre la rel\u00e8ve de /media . Les p\u00e9riph\u00e9riques amovibles doivent \u00eatre mont\u00e9s lors de leur insertion et d\u00e9monter lorsqu'on l'enl\u00e8ve /proc et /sys contiennent un syt\u00e8me de fichiers \"volatile\" qui fournit des infos sur le syst\u00e8me /root est le r\u00e9pertoire de l'utilisateur root /sbin pour system binaries ou binaires syst\u00e8me contient des ex\u00e9cutables pour l'administrateur comme partitionner ou formation des disques, configurer le r\u00e9seau... /usr pour Unix System Resources contient tout ce qui n'est pas utile au fonctionnement minimal du syst\u00e8me. Les applications se trouvent pour la plupart ici. /usr/bin est \u00e9quivalent \u00e0 C:\\Program Files de Windows. /tmp est le r\u00e9pertoire temporaire du syst\u00e8me /var contient des fichiers variables, cr\u00e9es par des serivces, c'est-\u00e0-dire des logiciels qui tournent en t\u00e2che de fond Les types de fichier r\u00e9pertoire avec une barre oblique \u00e0 la fin (couleur par d\u00e9faut : bleu) fichier r\u00e9gulier non ex\u00e9cutable sans suffixe (couleur par d\u00e9faut : noir ou blanc) lien symbolique avec un @ \u00e0 la fin, \u00e9quivalent du raccourci sous Windows (couleur par d\u00e9faut : turquoise) fichier r\u00e9gulier ex\u00e9cutable avec un * \u00e0 la fin (couleur par d\u00e9faut : vert) Les commandes de base date donne la date et l'heure time { commande ; } ex\u00e9cute commande et donne son temps d'ex\u00e9cution gucharmap affiche la table de caract\u00e8res history affiche la liste des commandes que l'on a saisi !num permet de r\u00e9p\u00e9ter une commande d\u00e9j\u00e0 effectu\u00e9e, par exemple !245 pwd pour Print Working Directory affiche le dossier courant file fichier pr\u00e9cise le type de fichier ls pour list , liste les fichiers et dossiers du r\u00e9pertoire courant. ls /usr liste les fichiers du r\u00e9pertoire usr . -a ou --all affiche les fichiers et dossiers cach\u00e9s -A affiche tout comme -a sauf les dossiers ./ (dossier courant) et ../ (dossier parent) -F indique le type d'\u00e9l\u00e9ment (dossier, fichier, raccourci...) -l liste d\u00e9taill\u00e9e (droits, nombre de liens physiques, nom du propri\u00e9taire, nom du groupe, taille du fichier en octets, date derni\u00e8re modification, nom du fichier). Avec lh , le h pour Human Readable permet d'avoir la taille du fichier en Ko, Mo... ls -l prefixe* permet de lister seulement les fichiers commen\u00e7ant par prefixe -d pour Directory qui affiche le r\u00e9pertoire au lieu d'afficher le contenu. Pour afficher les informations d\u00e9tailles du r\u00e9pertoire sans son contenu : ls -ld -t trie par date de derni\u00e8re modification. On voit en premier le dernier fichier modifi\u00e9. -r renverse l'ordre d'affichage des fichiers -R pour recursive , affiche les sous-dossiers et leur contenu exemple de combinaison des commandes : ls -larth cd Change Directory , c'est-\u00e0-dire changer de dossier. Sans param\u00e8tre, ram\u00e8ne dans le home personnel chemin absolu : on part de la racine : cd /home/gaetan/documents chemin relatif : on part du dossier courant. Exemple si on est dans /home/gaetan : cd documents cd .. pour remonter dans le dossier parent du Disk Usage informe sur la taille que les dossiers occupent. \u00e0 combiner avec -h : du -h -a pour avoir la taille des dossiers ET des fichiers du -ah -s pour avoir juste le total : du -sh echo affiche une ligne de texte et peut l'enregistrer dans un fichier echo Bonjour affiche Bonjour dans la console echo Bonjour > test.txt enregistre Bonjour dans un fichier test.txt . Si le fichier existe d\u00e9j\u00e0, il est \u00e9cras\u00e9. echo Bonjour >> test.txt ajoute une ligne au fichier test.txt cat affiche tout le contenu d'un fichier, et peut en concat\u00e9ner cat test.txt affiche le contenu du fichier cat -n test.txt affiche le contenu du fichier avec les num\u00e9ros de ligne cat test.txt test2.txt affiche le contenu des deux fichiers cat fichier1 fichier2 fichier3 > grosfichier enregistre le contenu des trois fichiers dans un seul pour \u00e9crire dans un fichier sur plusieurs lignes, par exemple 2 lignes : cat > test.txt << FIN ligne1 ligne2 FIN more et less pour afficher les gros fichiers, page par page. Ce sont des logiciels de pagination/visualisation de fichiers texte, on ne peut pas modifier les fichiers avec. more est plus ancien, less plus r\u00e9cent et plus complet more fichier.txt affiche le texte en remplissant un \u00e9cran puis s'arr\u00eate. Pour continuer, il faut : Entr\u00e9e pour avancer ligne \u00e0 ligne Espace pour avancer page \u00e0 page Q pour sortir du mode de visualisation B pour reculer page par page une fois arriv\u00e9 au bout du fichier, on sort du mode de visualisation less est un autre logiciel de visualisation = permet de savoir \u00e0 quelle ligne on est et \u00e0 quel pourcentage du fichier m\u00eames commandes avec quelques avantages : ne quitte pas le mode de visualisation \u00e0 la fin du fichier possibilit\u00e9 de naviguer avec les fl\u00e8ches du clavier fonction de recherche /maChaine . Toutes les occurrences sont affich\u00e9s en surbrillance. Naivguer avec n et N pour passer d'occurrence en occurrence. head et tail permettent d'afficher le d\u00e9but et la fin d'un fichier, par d\u00e9faut 10 lignes. On peut sp\u00e9ficier le nombre de lignes que l'on veut afficher. head -n 4 fichier affiche les 4 premi\u00e8res lignes de fichier tail fichier affiche les 10 derni\u00e8res lignes du fichier tail -f fichier pour follow permet d'afficher la fin du fichier au fur et \u00e0 mesure de son \u00e9volution touch monFichier cr\u00e9e un fichier vide monFichier s'il n'existe pas, sinon modifie l'horodatage du fichier si le fichier existe mkdir , pour Make Directory , sert \u00e0 cr\u00e9er un nouveau r\u00e9pertoire en sp\u00e9cifiant le nom de ce dernier ou en sp\u00e9cifiant le chemin complet mkdir monDossier ou mkdir monDossier monDossier2 pour en cr\u00e9er plusieurs \u00e0 la fois mkdir -p monDossier1/monDossier2 avec l'option -p pour parent pour cr\u00e9er un dossier et un sous-dossier dedans on peut utiliser l'option -v ou --verbose pour avoir des informations sur la cr\u00e9ation pour g\u00e9rer les espaces, 3 possibilit\u00e9s : mkdir \"Mes documents\" , mkdir 'Mes documents' ou mkdir Mes\\ documents tree permet de voir l'arborescence dans le r\u00e9pertoire courant tree monDossier permet de voir l'arborescence d'un sous-dossier du r\u00e9pertoire courant -d n'affiche que les dossiers, -a affiche les dossiers et fichiers cach\u00e9s cp pour copy permet de copier des fichiers et des r\u00e9pertoires cp fichier fichier2 copie le fichier dans le m\u00eame r\u00e9pertoire cp fichier.txt /cheminDestination copie le fichier dans un autre r\u00e9pertoire cp fichier.txt /dossier/fichier2.txt copie le fichier dans un autre r\u00e9pertoire en le renommant cp -R Fichiers/ /tmp/ ou cp -r Fichiers/ /tmp/ permet de copier un r\u00e9pertoire entier avec tout son contenu ( -R pour recursive ) dans le r\u00e9pertoire sp\u00e9cifi\u00e9 cp -R dossier/ copieDossier permet de copier l'int\u00e9gralit\u00e9 du r\u00e9pertoire dans un r\u00e9pertoire d'un autre nom cp -R dossier/ ../copieDossier permet de copier l'int\u00e9gralit\u00e9 du r\u00e9pertoire dans un r\u00e9pertoire d'un autre nom dans un autre endroit du syst\u00e8me mv pour move permet de d\u00e9placer et renommer des fichiers et des r\u00e9pertoires mv fichier dossier/ d\u00e9place fichier dans dossier mv dossier1 dossier2/ d\u00e9place dossier1 et son contenu dans dossier2 mv dossier/fichier ./ d\u00e9place fichier qui est dans dossier dans le r\u00e9pertoire courant mv fichier fichierRenomm\u00e9 renomme fichier en fichierRenomm\u00e9 , fonctionne aussi pour les dossiers mv fichier dossier/fichierRenomm\u00e9 d\u00e9place et renomme le fichier en une seule commande rm et rmdir pour remove et remove directory permettent de supprimer des fichiers et des dossiers rm fichier supprime fichier sans demande de confirmation, le fichier est perdu \u00e0 jamais rm -i fichier pour interactive demande une confirmation avant la suppression rm -f fichier pour force force la suppression si la demande de confirmation est syst\u00e9matique, par exemple avec l'ajout d'un alias sur la commande rm rmdir dossier supprime dossier seulement s'il est vide rm -r dossier pour recursive , supprime dossier et tout son contenu ln permet de cr\u00e9er des liens (raccourcis) entre fichiers. Il existe 2 types de liens : liens physiques : ln fichier1 fichier2 cr\u00e9e fichier2 qui partage le m\u00eame inode (contenu du fichier) que fichier1 ls -i permet d'afficher le num\u00e9ro d'inode pour v\u00e9rifier si les fichiers sont associ\u00e9s au m\u00eame inode Une modification dans l'un entra\u00eene une modification dans l'autre. Si on supprime l'un des 2 fichiers, l'autre reste en place et le contenu est toujours le m\u00eame. Il faut supprimer les 2 pour supprimer le contenu. liens symboliques : ln -s fichier1 fichier2 pour symbolique . Cr\u00e9e fichier2 qui pointe sur fichier1 . ressemble davantage au \"raccourci\" sous Windows, c'est-\u00e0-dire qu'on cr\u00e9e un lien vers un autre fichier on \u00e9dite le m\u00eame contenu dans fichier1 et fichier2 fonctionnent sur des r\u00e9pertoires contrairement aux liens physiques qui ne fonctionnent que sur les fichiers si on supprime fichier2 , rien de mal. Si on supprime fichier1 , fichier2 pointe vers un fichier qui n'existe plus, on parle de lien mort alias concerne les alias de commande, qui sont des raccourcis alias permet de voir les alias existants alias rm='rm -i' permet de cr\u00e9er un alias. Cette cr\u00e9ation n'est pas persistante, elle dispara\u00eet en fermant la console la documentation man pour manual affiche le manuel d'une commande comme avec la commande less : man mkdir . /test pour rechercher test dans la documentation. La documentation man est aussi disponible sur internet apropos permet de chercher les commandes en rapport \u00e0 un terme, par exemple apropos sound --help donne une information proche de celle de man , par exemple mkdir --help whatis donne juste le nom de la commande pour comprendre ce qu'elle fait, par exemple whatis mkdir info affiche un manuel en ligne encore plus complet que man , par exemple info mkdir rechercher des fichiers locate fichier pour une recherche rapide sur la base de donn\u00e9es des fichiers qui est mise \u00e0 jour toutes les 24 heures. Pour la mettre \u00e0 jour, lancer la commande sudo updatedb find pour une recherche approfondie, en parcourant les fichiers sur le disque, ce qui peut \u00eatre long. La commande s'utilise avec des param\u00e8tres find \"o\u00f9\" \"quoi\" \"que faire avec\" . Seul \"quoi\" est obligatoire. o\u00f9 est le dossier dans lequel on fait la recherche, ainsi que tous ses sous-dossiers. Si non renseign\u00e9, recherche dans le dossier courant quoi fichier ou dossier \u00e0 rechercher, par nom, date de cr\u00e9ation, taille... que faire avec on peut faire un post-traitement. Par d\u00e9faut, la commande affiche la liste des fichiers trouv\u00e9s, mais d'autres actions sont possibles -iname option qui permet d'ignorer la casse pour faire la recherche, par exemple find /etc/ -iname 'readme' exemples : find -name \"README.md\" recherche un fichier dans le r\u00e9pertoire courant qui s'appelle exactement README.md . On peut utiliser l'\u00e9toile pour rechercher des noms incomplets, par exemple : find -name \"READM*\" find /var/log/ -name \"syslog\" find /etc -type d permet d'afficher tous les r\u00e9pertoires et sous-r\u00e9pertoires du dossier find -size +10M permet de rechercher les fichiers de plus de 10Mo. On peut utiliser le - au lieu de + , et le k ou le G \u00e0 la place du M find -name \"*.md\" -atime 6 recherche les fichiers au format markdown modifi\u00e9 il y a moins de 7 jours (0 pour 1 jour). On peut enlever le - pour modifi\u00e9 exactement il y a x jours -type d et -type f permet de limiter la recherche aux r\u00e9pertoires ou aux fichiers, par exemple find -name \"syslog\" -type d find -name \"README.md\" -print permet d'afficher les r\u00e9sultats, ce qui correspond au r\u00e9sultat par d\u00e9faut find -name \"README.md\" -printf permet de formater le r\u00e9sultat affich\u00e9, par exemple find -name \"README.md\" -printf \"%p - %u\\n\" -delete permet de supprimer les fichiers trouv\u00e9s, par exemple find -name \"README.md\" -delete -exec , permet d'appeler une commande qui effectuera une action sur chacun des fichiers trouv\u00e9s find /bin -size +200k -exec ls -l \\{} \\; permet d'effectuer un ls -l sur les r\u00e9sultats de la recherche. {} symbolise le r\u00e9sultat de la recherche find /bin -size +200k | xargs ls -l . xargs sert \u00e0 construire et ex\u00e9cuter des lignes de commande \u00e0 partir de l\u2019entr\u00e9e standard manipulations dans les fichiers awk est un langage de traitement de lignes qui sert \u00e0 manipuler des fichiers textes awk NR==5 fichier affiche la 5e ligne de fichier awk NR==2,NR==4 fichier affiche les lignes 2 \u00e0 4 de fichier sed , pour stream editor sed -n 5p fichier affiche la 5e ligne de fichier sed -n 2,4p fichier affiche les lignes 2 \u00e0 4 de fichier grep permet de filtrer des donn\u00e9es grep texte fichier permet de chercher texte dans fichier , par exemple grep alias .bashrc permet de chercher le mot alias dans le fichier .bashrc et affiche toutes les lignes du fichier comportant ce mot -i pour ne pas tenir compte de la casse, grep -i texte fichier -n pour afficher les num\u00e9ros de lignes -v permet d'inverser la recherche et d'afficher uniquement les lignes qui ne contiennent pas le mot recherch\u00e9 -c permet de compter le nombre de lignes au lieu de les afficher -r permet de faire une recherche r\u00e9cursive dans tous les sous-dossiers et fichiers, par exemple grep -r machaine dossier/ . Le nom du fichier o\u00f9 la cha\u00eene a \u00e9t\u00e9 trouv\u00e9 s'affiche au d\u00e9but de la ligne -E permet d'utiliser des expressions r\u00e9guli\u00e8res on peut utiliser egrep \u00e0 la place de grep -E -E n'est pas obligatoire car les expressions r\u00e9guli\u00e8res sont activ\u00e9es de base sur Linux. C'est utile sur les autres syst\u00e8mes Unix . caract\u00e8re quelconque, ^ d\u00e9but de ligne, $ fin de ligne, [] un des caract\u00e8res entre les crochets, ? l'\u00e9l\u00e9ment pr\u00e9c\u00e9dent est optionnel (peut \u00eatre pr\u00e9sent 0 ou 1 fois), * l'\u00e9l\u00e9ment pr\u00e9c\u00e9dent peut \u00eatre pr\u00e9sent 0, 1 ou plusieurs fois, + l\u00b2'\u00e9l\u00e9ment pr\u00e9c\u00e9dent doit \u00eatre pr\u00e9sent 1 ou plusieurs fois, | ou, () groupement d'expressions par exemple grep -E ^alias .bashrc pour rechercher le mot alias uniquement en d\u00e9but de ligne grep -E [Aa]lias .bashrc renvoie les lignes qui contiennent alias ou Alias grep -E [0-4] .bashrc renvoie les lignes qui contiennent un chiffre entre 0 et 4 sort permet de trier les lignes sort fichier trie les lignes du fichier par ordre alphab\u00e9tique et affiche le r\u00e9sultat dans la console, en ignorant la casse -o permet d'\u00e9crire le r\u00e9sultat dans un fichier : sort -o resultatTri\u00e9 fichierATrier -r permet de trier en ordre inverse, sort -r fichier -R permet de trier al\u00e9atoirement -n permet de trier des nombres. Sans cette option, ils sont tri\u00e9s alphab\u00e9tiquement donc par exemple 150 serait avant 18 wc pour word count permet de compter le nombre de lignes, de mots, de caract\u00e8res, d'octets wc fichier retourne le nombre de lignes, de mots et d'octets -l retourne le nombre de lignes, wc -l fichiers -w retourne le nombre de mots -c retourne le nombre d'octets -m retourne le nombre de caract\u00e8res uniq permet de supprimer les doublons (lignes identiques) seulement si elles se suivent, il faut donc travailler sur un fichier tri\u00e9 uniq fichier affiche dans la console la liste des lignes sans doublons uniq fichierATraiter fichierSansDoublons enregistre le r\u00e9sultat dans un fichier -c compte le nombre d'occurence, affiche devant chaque ligne le nombre de fois qu'elle est pr\u00e9sente dans le fichier, par exemple uniq -c fichier -d affiche uniquement les lignes pr\u00e9sentes plusieurs fois cut permet de couper les lignes d'un fichier afin de conserver uniquement une partie de chaque ligne -c pour couper selon le nombre de caract\u00e8res. cut -c 2-5 noms.txt affiche les caract\u00e8res 2 \u00e0 5 de chaque ligne, cut -c -3 du 1er au 3 et cut -c 3- du 3e au dernier couper selon un d\u00e9limiteur, -d pour pr\u00e9ciser le d\u00e9limiteur, -f pour indiquer le num\u00e9ro du ou des champs \u00e0 couper. cut -d , -f 1 fichier conserve le 1er champ de chaque ligne, -f 2-4 conserve les champs 2, 3 et 4, -f 1,3 les champs 1 et 3 Les \u00e9diteurs de texte Il en existe plusieurs. Les plus connus sont Nano, Vim et Emacs. - Nano - \u00e9diteur de texte simple compar\u00e9 \u00e0 Vim et Emacs - nano pour lancer l'\u00e9diteur vide - nano fichier lance l'\u00e9diteur en ouvrant le fichier - -m pour autoriser l'utilisation de la souris - -i pour l'indentation automatique, c'est-\u00e0-dire que la tabulation de la ligne pr\u00e9c\u00e9dente sera respect\u00e9 lorsqu'on va \u00e0 la ligne - Nano se configure dans le fichier .nanorc , situ\u00e9 \u00e0 la racine du home pour son propre fichier de configuration ( /home/user/.nanorc ), o\u00f9 dans le fichier nanorc situ\u00e9 dans le dossier etc ( /etc/nanorc ). Ce dernier n\u00e9cessite d'\u00eatre en root pour le modifier. Il contient d\u00e9j\u00e0 plusieurs options mises en commentaires pour l'exemple Emacs : puissant \u00e9diteur de texte d\u00e9velopp\u00e9 par Richard Stallman, le fondateur du projet GNU Vim : autre puissant \u00e9diteur de texte g\u00e9n\u00e9ralement disponible par d\u00e9faut sur Linux Vi existe en plusieurs versions : vi , le clone elvis , vim (VI iMproved, version am\u00e9lior\u00e9e de Vi),ou encore gvim dot\u00e9e d'une interface graphique Vimtutor pour apprendre \u00e0 s'en servir Configuration de la console Il faut modifier le fichier .bashrc personnel situ\u00e9 dans le r\u00e9pertoire personnel, ou le fichier bashrc global situ\u00e9 dans le r\u00e9pertoire /etc/bash.bashrc . On peut par exemple personnaliser l'invite de commande, ou aussi y cr\u00e9er des alias qui sont persistants. Il existe \u00e9galement un fichier ~/.profile et un fichier /etc/profile qui est lu dans les consoles o\u00f9 on se logue (les consoles Alt+Ctrl+F1 \u00e0 F6), alors que le .bashrc est lu dans les consoles o\u00f9 on ne se logue pas, comme les consoles en mode graphique. Le .profile fait appel au .bashrc par d\u00e9faut, donc faire des modifications dans le .bashrc modifiera les options pour les consoles avec et sans login. Les utilisateurs et les droits Chaque personne \u00e0 son propre compte utilisateur avec des droits limit\u00e9s. Il existe un super-utilisateur appel\u00e9 root qui a tous les droits, qui ne doit servir que rarement, lorsque c'est n\u00e9cessaire. sudo pour Substitute User DO ou encore faire en se substituant \u00e0 l'utilisateur, permet de devenir root temporairement le temps d'ex\u00e9cuter une commande en faisant sudo commande sudo su pour switch user , permet de devenir root et de le rester dans Ubuntu su - est suffisant dans les autres distributions, le tiret rend accessible certains programmes destin\u00e9s seulement \u00e0 root, et nous place dans le dossier personnel de root ( /root ) le symbole # \u00e0 la fin de l'invite de commandes indique que l'on est devenu super-utilisateur exit permet de quitter le mode root , permet aussi de fermer la console dans une session normale su - test permet de se connecter avec le compte utilisateur test , le tiret indique que l'on souhaite utiliser ses variables d'environnement whoami permet de savoir avec quel utilisateur on est connect\u00e9 id permet d'afficher l'UID (User Identification), le GID (Group Identification) et la liste de groupe secondaires de l'utilisateur connect\u00e9, par exemple affiche uid=1000(gaetan) gid=1000(gaetan) groupes=1000(gaetan),4(adm),24(cdrom),27(sudo),30(dip),46(plugdev),113(lpadmin),130(sambashare) id user affiche les m\u00eames informations pour l'utilisateur user id -u affiche uniquement le num\u00e9ro uid id -g affiche uniquement le num\u00e9ro gid id -gn affiche uniquement le nom du groupe id -Gn ou groups affiche les noms des groupes dont l'utilisateur est membre finger user affiche les donn\u00e9es GECOS de user , c'est-\u00e0-dire son login, son nom, son home, son shell, etc... le fichier /etc/passwd contient les informations des utilisateurs concernant leur connexion, par exemple : gaetan:x:1000:1000:Ga\u00ebtan Varlet,,,:/home/gaetan:/bin/bash . utilisateur root, uid=0 utilisateurs syst\u00e8me, uid compris entre 1 et 99 utilisateurs normaux avec uid sup\u00e9rieur ou \u00e9gal \u00e0 1000 les mdp sont dans le fichier /etc/shadow , uniquement accessible par root Gestion des utilisateurs commandes r\u00e9serv\u00e9s \u00e0 root adduser permet d'ajouter un utilisateur, avec au minimum le nom d'utisateur \u00e0 cr\u00e9er, par exemple adduser louis r\u00e9pertoire personnel est cr\u00e9\u00e9 on doit choisir un mot de passe passwd permet de changer le mot de passe du compte en param\u00e8tre, par exemple passwd louis sans param\u00e8tre, c'est le mdp de l'utilisateur connect\u00e9 que l'on modifie deluser permet de supprimer un compte, par exemple deluser louis ne supprime pas le r\u00e9pertoire personnel. Si on souhaite le faire, ajouter l'option --remove-home , par exemple deluser --remove-home louis ou encore userdel -r louis adduser et deluser n'existent que sous Debian et ses descendants dont Ubuntu. Ailleurs, il faut utiliser les commandes Unix traditionnelles useradd et userdel qui font la m\u00eame chose de mani\u00e8re plus basique, par exemple il faut appeler passwd pour d\u00e9finir un mdp et activer le compte Gestion des groupes chaque utilisateur appartient \u00e0 un groupe. Par d\u00e9faut, un groupe du m\u00eame nom que l'utilisateur est cr\u00e9\u00e9 addgroup permet de cr\u00e9er un groupe, par exemple addgroup famille delgroup permet de supprimer un groupe, par exemple delgroup famille usermod permet de modifier un utilisateur -l renomme l'utilisateur sans renommer son r\u00e9pertoire personnel -g change de groupe, par exemple usermod -g famille louis pour mettre Louis dans le groupe famille et usermod -g louis louis pour le remettre dans le groupe louis -G permet \u00e0 un utilisateur d'avoir plusieurs groupes, par exemple usermod -G famille,amis louis . L'utilisateur ne sera plus dans les groupes dans lesquels il \u00e9tait avant. -a permet d'ajouter des groupes \u00e0 un utilisateur sans perdre les groupes auxquels il appartient, par exemple usermod -aG famille louis gpasswd -d permet de supprimer l'appartenance d'un utilisateur \u00e0 un groupe, par exemple gpasswd -d louis audio le fichier /etc/group contient la liste des groupes avec leur GID et la liste de des membres des groupes addgroup et delgroup n'existent que sous Debian et ses d\u00e9riv\u00e9s. Les commandes traditionnelles sont groupadd et groupdel qui offrent moins d'options Gestion des propri\u00e9taires d'un fichier seul l'utilisateur root peut changer le propri\u00e9taire d'un fichier chown pour change owner , permet de changer le propri\u00e9taire d'un fichier, en renseignant le nom du nouveau propri\u00e9taire et le nom du fichier, par exemple chown louis fichier . Cela ne change pas le groupe du fichier chown louis:famille fichier permet de changer le propri\u00e9taire et le groupe en m\u00eame temps -R pour recursive permet d'affecter tous les sous-dossiers et fichiers contenu dans le dossier, par exemple chown -R louis:louis /home/gaetan/dossier/ chgrp permet de changer le groupe propri\u00e9taire du fichier, par exemple chgrp famille fichier Modifier les droits d'acc\u00e8s chaque fichier et dossier poss\u00e8de des droits : voir, modifier et ex\u00e9cuter la commande ls -l permet de voir les droits, il s'agit des 10 premiers caract\u00e8res le 1er d pour directory si c'est un dossier, l pour link ou - si c'est un fichier 3 triplets qui correspondent aux droits de l'utilisateur, du groupe et des autres. Un triplet correspond \u00e0 rwx pour read , write et execute Ce dernier n'est utile que pour les fichiers ex\u00e9cutables (programmes et scripts). si la lettre appara\u00eet, c'est que le droit existe. S'il y a un tiret \u00e0 la place, c'est qu'il n'y a aucun droit. si c'est un dossier, x indique qu'on peut se placer dans le r\u00e9pertoire avec la commande cd , et voir son contenu si on a les droits en lecture dessus r . les droits de modification donnent aussi les droits de suppression root \u00e0 tous les droits chmod permet de modifier les droits d'acc\u00e8s. Pas besoin d'\u00eatre root, il suffit d'\u00eatre propri\u00e9taire du fichier pour modifier les droits d'acc\u00e8s plusieurs m\u00e9thodes d'attribution des droits avec des chiffres : r=4, w=2, x=1. On les combine en additionnant, par exemple 6 donne les droits en lecture et \u00e9criture. \u00e7a va de 0 \u00e0 7. chmod 777 fichier donne tous les droits \u00e0 tout le monde, chmod 000 fichier ne donne aucun droit \u00e0 personne, sauf \u00e0 root avec des lettres : u=user, g=group, o=other. + =ajouter, - =supprimer et = =affecter. Par exemple chmod g+w fichier ajoute le droit en \u00e9criture au groupe -R pour affecter r\u00e9cursivement tous les sous-dossiers et fichiers, par exemple chmod -R 700 /home/louis umask permet de voir les permissions par d\u00e9faut. Un fichier cr\u00e9\u00e9 ne peut avoir de base les droits d'ex\u00e9cution. Installer des programmes paquet : c'est un programme \u00ab pr\u00eat \u00e0 l'emploi \u00bb, l'\u00e9quivalent des programmes d'installation sous Windows en quelque sorte. C'est une sorte de dossier zipp\u00e9 qui contient tous les fichiers du programme. Il se pr\u00e9sente sous la forme d'un fichier .deb et contient toutes les instructions n\u00e9cessaires pour installer le programme d\u00e9pendance : un paquet peut avoir besoin de plusieurs autres paquets pour fonctionner, on dit qu'il a des d\u00e9pendances d\u00e9p\u00f4t : c'est le serveur sur lequel on va t\u00e9l\u00e9charger nos paquets programme graphique qui g\u00e8re les paquets ou utiliser un programme en ligne de commande comme apt-get ou aptitude apt-get update met \u00e0 jour le cache (liste des paquets existant propos\u00e9 par le d\u00e9p\u00f4t) apt-cache search paquetRecherch\u00e9 recherche le paquet que l'on veut t\u00e9l\u00e9charger si on ne connait pas le nom exact apt-get install monPaquet t\u00e9l\u00e9charge et installe le paquet apt-get upgrade met \u00e0 jour tous les paquets install\u00e9s, apr\u00e8s avoir fait un apt-get update car apt-get comapre la version des paquets install\u00e9s avec ceux pr\u00e9sents dans le cache apt-get autoremove monPaquet permet de d\u00e9sinstaller un paquet et les d\u00e9pendances devenues inutiles alors apt-get remove monPaquet ne supprime que le paquet en param\u00e8tre Programmes absents des d\u00e9p\u00f4ts officiels Si un programme est absent des d\u00e9p\u00f4ts officiels, on peut parfois trouver sur le site web du logiciel un paquetage .deb , sp\u00e9cifique \u00e0 Debian et ses distributions d\u00e9riv\u00e9es. Par exemple, Red Hat utilise des .rpm . - t\u00e9l\u00e9charger le .deb et double-cliquer dessus. - s'il n'y a pas d'erreurs, on peut installer le programme - sinon, le programme ne correspond pas \u00e0 notre machine (32 bits au lieu de 64 bits par exemple) ou alors qu'il manque des d\u00e9pendances qu'il faut installer manuellement Si le .deb n'est pas disponible, il faut alors r\u00e9cup\u00e9rer le code source du programme et le compiler pour avoir un ex\u00e9cutable pour sa machine - le programme build-essential est n\u00e9cessaire pour compiler le code source d'un programme - trouver le code source sur le site du programme et le t\u00e9l\u00e9charger, et \u00e9ventuellement le d\u00e9compresser - ex\u00e9cuter le programme configure avec la commande ./configure . Cela analyse notre ordinateur et v\u00e9rifie si tous les outils n\u00e9cessaires \u00e0 la compilation du logiciel que l'on souhaite installer sont bien pr\u00e9sents - s'il y a une erreur, il y a s\u00fbrement des paquets manquants. Il faut le trouver, l'installer puis relancer ./configure jusqu'\u00e0 qu'il n'y ait plus d'erreurs - une fois qu'il n'y a plus d'erreur, lancer la compilation avec la commande make qui cr\u00e9e l'ex\u00e9cutable - installer le programme avec la commande sudo make install . Une fois termin\u00e9, le programme est install\u00e9 et on peut le lancer en \u00e9crivant son nom dans la ligne de commande - pour le d\u00e9sinstaller, ex\u00e9cuter la commande sudo make uninstall depuis le r\u00e9pertoire o\u00f9 il a \u00e9t\u00e9 compil\u00e9. Si on supprime le r\u00e9pertoire avec le code source, on ne pourra plus lancer la commande de d\u00e9sinstallation Les flux de redirection Au lieu d'afficher le r\u00e9sultat d'une commande dans la console (comportement par d\u00e9faut), on peut le rediriger - dans un fichier - en entr\u00e9e d'une autre commande pour effectuer des cha\u00eenes de commandes - dans la \"corbeille\", commande > /dev/null , tout est supprim\u00e9 imm\u00e9diatement, si on ne veut ni l'afficher dans la console ni dans un fichier > et >> permettent de rediriger le r\u00e9sultat dans un nouveau fichier pour > et \u00e0 la fin d'un fichier pour >> echo Bonjour affiche Bonjour dans la console echo Bonjour > test.txt enregistre Bonjour dans un fichier test.txt . Si le fichier existe d\u00e9j\u00e0, il est \u00e9cras\u00e9 echo Bonjour >> test.txt ajoute une ligne au fichier test.txt .Si le fichier n'existe pas, il sera cr\u00e9\u00e9 2>, 2>> et 2>&1 permettent de rediriger les erreurs toutes les commandes produisent deux flux de donn\u00e9es : la sortie standard et la sortie d'erreur . Par d\u00e9faut, les deux s'affichent dans la console avec > et >> , seule la sortie standard est redirig\u00e9e vers le fichier, les erreurs continuent \u00e0 \u00eatre affich\u00e9 dans la console 2> permet de rediriger les erreurs dans un fichier \u00e0 part, par exemple ls -l /root/ > test 2> erreur redirige la sortie standard dans le fichier test et la sortie d'erreur dans le fichier erreur 2>> permet d'ajouter les erreurs \u00e0 la fin du fichier 2>&1 permet de fusionner les sorties dans un seul fichier, par exemple ls -l / > testFusion 2>&1 < et << permet de lire depuis un fichier pour < , et de lire progressivement depuis le clavier pour << l'entr\u00e9e d'une commande vient des param\u00e8tres de la commande, mais elle peut aussi venir d'un fichier ou d'une saisie au clavier cat < fichier affiche le contenu de fichier . La commande cat re\u00e7oit le contenu du fichier qu'elle affiche, alors que la commande cat fichier re\u00e7oit le nom du fichier qu'elle doit d'abord ouvrir pour ensuite afficher son contenu. Le r\u00e9sultat est le m\u00eame mais ce qui se passe derri\u00e8re est diff\u00e9rent << passe la console en mode saisie au clavier ligne par ligne. Toutes ces lignes seront envoy\u00e9es \u00e0 la commande lorsque le mot-cl\u00e9 de fin aura \u00e9t\u00e9 \u00e9crit. Par exemple : wc -m << FIN Combien de caract\u00e8res dans cette phrase ? FIN | permet de cha\u00eener les commandes connecter la sortie d'une commande \u00e0 l'entr\u00e9e d'une autre commande exemple : du | sort -nr | head permet d'afficher les 10 dossiers les plus lourds tri\u00e9s par taille Surveiller l'activit\u00e9 du syst\u00e8me w permet de voir qui est connect\u00e9 et ce qu'ils font l'heure, aussi accessible via date l'uptime, aussi accessible via uptime , qui indique depuis combien de temps l'ordinateur n'a pas \u00e9t\u00e9 red\u00e9marr\u00e9 la charge, aussi accessible via uptime et tload . Il s'agit de la charge moyenne depuis 1, 5 et 15 minutes, plus pr\u00e9cis\u00e9ment le nombre de processus qui r\u00e9clament le processeur. La charge maximale correspond au nombre de processeur, au del\u00e0, il y a surcharge la liste des personnes connect\u00e9s sur la machine, accessible aussi via who free -m mesure la consommation m\u00e9moire. L'option -m permet d'avoir l'information en Mo ps et top pour lister les processus un processus est un programme qui tourne en m\u00e9moire. Certains programmes ne font tourner qu'un processus, d'autres plusieurs comme Chrome qui cr\u00e9e un processus par onglet ps permet d'avoir la liste statique des processus en cours PID est l'identifiant du processus par d\u00e9faut, seul les processus lanc\u00e9s par l'utilisateur dans la console sont affich\u00e9s ps -x affiche l'ensemble des processus de l'utilisateur -a ajoute ceux de tous les utilisateurs -u donne des informations suppl\u00e9mentaires comme le propri\u00e9taire du processus, l'utilisation du processus et de la m\u00e9moire ps -ef permet d'afficher tous les processus et ps -ejH de les afficher en arbre pstree , ou pstree | less affiche l\u2019organisation hi\u00e9rarchique de tous les processus en cours du syst\u00e8me top permet d'avoir la liste dynamique des processus et permet de mesurer la consommation en ressources de chaque processus affiche les processus tri\u00e9 sur le taux d'utilisation du processeur h permet d'afficher l'aide Ctrl + C ou kill pour arr\u00eater un processus Ctrl + C permet d'arr\u00eater un processus lanc\u00e9 en console kill permet d'arr\u00eater proprement un processus lanc\u00e9 en arri\u00e8re-plan en indiquant son PID , par exemple kill 12345 kill -9 permet de tuer un processus sans lui laisser le temps de s'arr\u00eater proprement, s'il refuse de se fermer normalement. Par exemple kill -9 12345 killall permet de tuer tous les processus d'un m\u00eame programme, par exemple killall find \u00e9teindre l'ordinateur halt , poweroff et reboot -p arr\u00eatent le syst\u00e8me en tuant tous les processus sans pr\u00e9venir personne reboot redem\u00e9arre le syst\u00e8me de la m\u00eame mani\u00e8re shutdown arr\u00eate ou red\u00e9marre le syst\u00e8me proprement : shutdown -h now et shutdown -r now Ex\u00e9cuter des programmes en arri\u00e8re-plan un service , ou demon est un processus qui s'ex\u00e9cute en arri\u00e8re-plan plut\u00f4t que sous le contr\u00f4le direct d'un utilisateur & permet de lancer un processus en arri\u00e8re-plan, par exemple cp fichier copie & les messages renvoy\u00e9s par les commandes s'affichent toujours dans la console. On peut donc les envoyer dans un fichier, par exemple find / -name \"*log\" > sortiefind & nohup permet de d\u00e9tacher le processus de la console. Si l'utilisateur se d\u00e9connecte ou si la console est ferm\u00e9e, le processus continuera. Exemple : nohup fichier copie Ctrl+Z met en pause un processus ex\u00e9cut\u00e9 au premier plan, sans & donc bg pour background , passe le processus en pause en arri\u00e8re-plan jobs permet de conna\u00eetre les processus qui tournent en arri\u00e8re-plan fg pour foreground , permet de reprendre un processus au premier plan fg s'il y a un seul processus en arri\u00e8re-plan list\u00e9 dans jobs fg %x s'il y a plusieurs processus en arri\u00e8re-plan pour reprendre le processus x screen est un programme qui permet d'ouvrir plusieurs consoles virtuelles au sein d'une seule et m\u00eame console, et d'ex\u00e9cuter facilement plusieurs processus en parall\u00e8le Ex\u00e9cuter des programmes \u00e0 une heure diff\u00e9r\u00e9e date permet d'afficher la date date \"+%H:%M:%S\" permet de personnaliser l'affichage sudo date MMDDhhmmYYYY permet de modifier la date syst\u00e8me at permet d'ex\u00e9cuter une commande plus tard une seule fois 1) on indique quand on veut ex\u00e9cuter la commande, par exemple at 18:17 ou at 18:17 tomorrow ou at 18:17 04/12/18 (12 avril, attention \u00e0 l'ordre MM/DD/YY) ou encore at now +5 minutes (minutes, hours, days, weeks, months, years) 2) taper la ou les commandes que l'on veut ex\u00e9cuter \u00e0 cette heure l\u00e0 3) faire Ctrl + D . Le symbole <EOT> s'affiche et nous donne le num\u00e9ro de la t\u00e2che (job en anglais) atq permet d'avoir la liste des jobs en attente atrm permet de supprimer un job en attente, par exemple atrm 5 pour supprimer le job n\u00b05 il est possible d'encha\u00eener des commandes : avec le point-virgule, par exemple touch fichier; rm fichier avec les && , par exemple touch fichier && sleep 10 && rm fichier . Les instructions ne s'encha\u00eeneront que si elles se sont correctement ex\u00e9cut\u00e9es sleep permet de faire une pause, par exemple touch fichier; sleep 10; rm fichier ou une pause de 10 secondes aura lieu on peut r\u00e9gler l'unit\u00e9 de sleep qui est par d\u00e9faut la seconde : m pour minute, h pour heure et d pour jour. Exemple : sleep 1m crontab permet ex\u00e9cuter une commande r\u00e9guli\u00e8rement crontab permet de lire et modifier un fichier appel\u00e9 la crontab , qui contient la liste des programmes \u00e0 ex\u00e9cuter r\u00e9guli\u00e8rement, et l'heure \u00e0 laquelle ils soient ex\u00e9cut\u00e9s -l permet d'afficher la crontab, -e la modifier, -r la supprimer sans confirmation syntaxe : m h dom mon dow command pour minute (0-59), hour (0-23), day of month (1-31), month (1-12), day of week (0-6, 0=dimanche) on peut mettre une \u00e9toile \u00e0 la place d'un chiffre pour dire tous les chiffres 3,5,10 pour les 3 valeurs, 3-7 pour les valeurs 3 \u00e0 7, */3 pour les multiples de 3, par exemple 0, 3, 6, 9... le r\u00e9sultat de la commande n'appara\u00eet pas dans la console, il est normalement envoy\u00e9 par mail le rediriger dans un fichier : 45 18 * * * touch /home/louis/fichier >> /home/louis/cron.log 2>&1 le rediriger dans le trou noir pour suppression imm\u00e9diate : * * * * * commande > /dev/null 2>&1 exemples : 45 18 * * * commande est ex\u00e9cut\u00e9 tous les jours \u00e0 18h45 0 0 * * 1 commande tous les lundis \u00e0 minuit (nuit de dimanche \u00e0 lundi) 0 4 1 * * commande tous les premiers du mois \u00e0 4h 0 4 * 12 * commande tous les jours du mois de d\u00e9cembre * * * * * toutes les minutes, c'est la fr\u00e9quence minimale Archiver et compresser tar , pour tape archiver , est un programme d'archivage. Il permet : d'assembler des fichiers dans une archive regroupement des fichiers dans un m\u00eame dossier cr\u00e9ation de l'archive tar : tar -cvf nomArchive.tar nomDossier/ . -c pour la cr\u00e9ation de l'archive, -v pour l'affichage des d\u00e9tails de l'op\u00e9ration et -f pour assembler l'archive dans un fichier d'afficher le contenu d'une archive sans l'extraire, par exemple tar -tf archive.tar d'ajouter un fichier \u00e0 une archive existante, par exemple tar -rvf archive.tar nouveauFichier d'extraire les fichiers d'une archive, par exemple tar -xvf archive.tar avec -x pour extract . Le contenu de l'archive est extrait dans le r\u00e9pertoire courant Les diff\u00e9rents programmes de compression d'une archive - gzip , pour GNU Zip , est le plus connu et le plus utilis\u00e9 - gzip archive.tar compresse l'archive qui devient archive.tar.gz - gunzip archive.tar.gz ou gzip -d archive.tar.gz d\u00e9compresse l'archive qui redevient archive.tar - bzip2 compresse mieux mais plus lentement - bzip2 archive.tar compresse l'archive qui devient archive.tar.bz2 - bunzip2 archive.tar.bz2 ou bzip2 -d archive.tar d\u00e9compresse l'archive qui redevient archive.tar - compress n'est plus utilis\u00e9 car moins performant que gzip et bzip2 - contrairement \u00e0 zip et rar , gzip et bzip2 ne peuvent compresser qu'un seul fichier \u00e0 la fois, c'est pour cela qu'il faut cr\u00e9er une archive tar auparavant Archiver et compresser en m\u00eame temps avec tar - avec gzip - -zcvf permet d'archiver et compresser, par exemple tar -zcvf nomArchive.tar.gz nomDossier/ - -zxvf permet de d\u00e9compresser, par exemple tar -zxvf nomArchive.tar.gz - avec bzip2 - -jcvf permet d'archiver et compresser, par exemple tar -zcvf nomArchive.tar.bz2 nomDossier/ - -jxvf permet de d\u00e9compresser, par exemple tar -zxvf nomArchive.tar.bz2 Lecture d'un fichier compress\u00e9 - on peut compresser directement un fichier en faisant gzip fichier - si on veut le lire, par exemple en faisant cat fichier , des caract\u00e8res bizarres s'affichent \u00e0 cause de la compression. A la place, on peut utiliser zcat , zmore ou zless qui permettent de lire un fichier compress\u00e9. Exemple zmore fichier D\u00e9compresser les zip et les rar - unzip permet de d\u00e9compresser un .zip - exemple unzip archive.zip - -l permet d'afficher le contenu sans l'extraire, par exemple unzip -l archive.zip - zip permet de cr\u00e9er un zip , par exemple zip -r dossier.zip dossier/ - unrar permet de d\u00e9compresser un rar - exemple unrar e toto.rar sans tiret devant le e - unrar l toto.rar permet d'afficher le contenu sans l'extraire - il n'est pas possible gratuitement de cr\u00e9er des rar car c'est un format propri\u00e9taire. Le paquet rar est payant Les connexions \u00e0 distance Les protocoles on peut configurer une machine Linux pour s'y connecter \u00e0 distance \u00e0 condition qu'elle reste allum\u00e9e pour communiquer entre eux, deux ordinateurs doivent utiliser le m\u00eame protocole il en existe plein, par exemple HTTP pour s'\u00e9changer des pages web, FTP protocole de transfert de fichier, IMAP protocole pour s'\u00e9changer des emails... Telnet est un protocole simple cr\u00e9\u00e9 dans les ann\u00e9es 80 pour \u00e9changer des messages en clair d'une machine \u00e0 une autre, qui peuvent donc \u00eatre intercept\u00e9s et lus par n'importe qui SSH est un protocole qui permet de chiffrer les \u00e9changes cr\u00e9ation d'un tunnel s\u00e9curis\u00e9 avec SSH (tout ce fait automatiquement) : utilisation du chiffrement asym\u00e9trique pour s'\u00e9changer une cl\u00e9 de chiffrement sym\u00e9trique : le serveur envoie la cl\u00e9 publique en clair au client pour qu'il puisse chiffrer le client g\u00e9n\u00e8re une cl\u00e9 de chiffrement sym\u00e9trique qu'il chiffre gr\u00e2ce \u00e0 la cl\u00e9 publique qu'il a re\u00e7ue, et l'envoi au serveur, qui d\u00e9chiffre la cl\u00e9 re\u00e7ue gr\u00e2ce \u00e0 sa cl\u00e9 priv\u00e9e ensuite, utilisation du chiffrement sym\u00e9trique pour chiffrer tous les \u00e9changes car le chiffrement asym\u00e9trique est beaucoup plus lent que le chiffrement sym\u00e9trique. une fois le tunnel mis en place, le client peut se connecter au serveur avec son login et son mot de passe Transformer sa machine en serveur et s'y connecter en SSH transformer son pc en serveur : il faut installer le paquet openssh-server sudo apt-get install openssh-server normalement, le serveur SSH sera lanc\u00e9 \u00e0 chaque d\u00e9marrage sudo /etc/init.d/ssh start permet de le lancer \u00e0 tout moment sudo /etc/init.d/ssh stop permet de l'arr\u00eater \u00e0 tout moment au besoin, le fichier de configuration se trouve dans /etc/ssh/ssh_config . Il faut ensuite recharger SSH avec la commande sudo /etc/init.d/ssh reload pour que les changements soient pris en compte se connecter via SSH \u00e0 partir d'une machine Linux ssh login@ip en rempla\u00e7ant login par notre login et ip par l'adresse IP de notre ordinateur que l'on peut obtenir par exemple via le site www.whatismyip.com ou l'IP locale si on se connecte depuis un autre ordinateur sur le m\u00eame reseau local ssh login@localhost ou ssh login@127.0.0.1 permet de se connecter depuis son propre PC exit ou logout permet de se d\u00e9connecter le port 22 est le port utilis\u00e9 par d\u00e9faut par SSH. Si le serveur tourne sur un autre port, il faut le pr\u00e9ciser comme ceci : ssh login@ip -p 12345 si le serveur fonctionne sur le port 12345 le fingerprint du serveur, ou empreinte, est un num\u00e9ro unique qui permet d'identifier le serveur. Si quelqu'un essaie de se faire passer pour le serveur, le fingerprint changera et on sera averti se connecter via SSH \u00e0 partir d'une machine Windows renseigner l'adresse IP dans Host Name et le port (22 par d\u00e9faut) lors de la premi\u00e8re connexion, Putty nous demande une confirmation en nous donnant l'empreinte du serveur le serveur demande le login et le mot de passe. La connexion est maintenant \u00e9tablie L'identification automatique par cl\u00e9 Les m\u00e9thodes les plus utilis\u00e9es pour s'authentifier aupr\u00e8s du serveur sont l'authentification par mot de passe l'authentification par cl\u00e9s publique et priv\u00e9e du client . cette m\u00e9thode \u00e9vite de renseigner son mot de passe \u00e0 chaque fois la cl\u00e9 publique ainsi g\u00e9n\u00e9r\u00e9e doit \u00eatre envoy\u00e9e sur le serveur, la cl\u00e9 priv\u00e9e reste sur le PC du client. La connexion se fait alors sans mot de passe et reste s\u00e9curis\u00e9e Authentification par cl\u00e9 depuis Linux g\u00e9n\u00e9rer une paire de cl\u00e9s publique/priv\u00e9e avec la commande ssh-keygen -t rsa sur le client rsa \u00e9tant un algorithme de chiffrement asym\u00e9trique, on peut aussi utiliser dsa qui est un autre algorithme de chiffrement les cl\u00e9s sont enregistr\u00e9es dans des fichiers. Laisser les valeurs par d\u00e9faut, ~/.ssh/id_rsa.pub pour la cl\u00e9 publique et ~/.ssh/id_rsa pour la cl\u00e9 priv\u00e9e. Le dossier .ssh/ contient aussi un fichier known_hosts qui est la liste des fingerprint que votre PC de client tient \u00e0 jour on nous demande une passphrase qui sert \u00e0 chiffrer la cl\u00e9 priv\u00e9e pour plus de s\u00e9curit\u00e9. On peut ne pas la renseigner si personne d'autre n'utilise le PC ou ne peut lire le fichier contenant la cl\u00e9 priv\u00e9e. envoyer la cl\u00e9 publique au serveur, pour qu'il puisse chiffrer les messages qu'il nous envoi ssh-copy-id -i id_rsa.pub login@ip avec le login et l'ip du serveur on envoie la cl\u00e9 publique id_rsa.pub sur le serveur dans son fichier authorized_keys on peut maintenant se connecter avec la commande ssh login@ip . Si on n'a pas mis de passphrase on est directement connect\u00e9, sinon il faut renseigner la passphrase pour \u00e9viter de renseigner la passphrase \u00e0 chaque fois, on peut utiliser l'agent SSH qui permet de la renseigner une seule fois. C'est un programme qui tourne en m\u00e9moire qui retient les cl\u00e9s priv\u00e9es pendant toute la dur\u00e9e de la session. Lancer le programme avec ssh-add sur le client, qui va lire notre cl\u00e9 priv\u00e9e et va nous demander notre passphrase pour la d\u00e9chiffrer. On peut maintenant se connecter plusieurs fois sur le m\u00eame serveur ou sur diff\u00e9rents serveurs sans retaper le passphrase Authentification par cl\u00e9 depuis Windows avec Putty m\u00eame principe : g\u00e9n\u00e9rer une paire de cl\u00e9s publique/priv\u00e9e sur le client et envoyer la cl\u00e9 publique au serveur g\u00e9n\u00e9rer la paire de cl\u00e9 avec Puttygen en laissant les valeurs par d\u00e9faut. on peut \u00e9ventuellement renseigner une passphrase enregistrer les cl\u00e9s dans des fichiers, par exemple cle.pub et cle.ppk se connecter au serveur avec son login/mdp et ajouter la cl\u00e9 publique dans les cl\u00e9 autoris\u00e9es \u00e0 la fin du fichier : cd .ssh pour aller dans le dossier .ssh de notre dossier personnel puis echo \"cle_publique\" >> authorized_keys se d\u00e9connecter pour configurer Putty pour se connecter avec la cl\u00e9. Dans Connection \u2192 SSH \u2192 Auth , indiquer le chemin du fichier contenant la cl\u00e9 priv\u00e9e, et dans Connection \u2192 Data renseigner le login dans Auto-login username se connecter en cliquant sur Open, le login est d\u00e9j\u00e0 renseign\u00e9, il faut renseigner la passphrase pour \u00e9viter de renseigner la passphrase \u00e0 chaque fois, on peut utiliser l'agent SSH Pageant , install\u00e9 avec Putty. Il est possible de le lancer automatiquement au d\u00e9marrage. Cliquer sur addkey , pr\u00e9ciser l'emplacement du fichier et renseigner la passphrase. Se connecter \u00e0 un serveur en s\u00e9lectionnant Saved Sessions Le transfert de fichiers wget permet de t\u00e9l\u00e9charger des fichiers en indiquant l'adresse HTTP ou FTP exemple wget https://thumbs.dreamstime.com/z/chat-mignon-2507126.jpg -c permet de reprendre un t\u00e9l\u00e9chargement arr\u00eat\u00e9 si le bout de fichier t\u00e9l\u00e9charg\u00e9 est toujours l\u00e0 : wget -c adresseHttp --background permet de laner un t\u00e9l\u00e9chargement en t\u00e2che de fond (tout comme la commande nohup ) scp pour secure copy , permet de copier des fichiers sur le r\u00e9seau d'un ordinateur \u00e0 un autre de mani\u00e8re s\u00e9curis\u00e9e rcp pour remote copy fait la m\u00eame chose sans cryptage syntaxe : scp origine destination , sous la forme login@ip:nom_fichier . Le login et l'IP sont facultatifs. S'ils sont absents, la commande consid\u00e8re que le fichier est sur notre ordinateur exemple : scp louis@12.345.67.890:image.png copie.png copie l'image sur l'ordinateur distant sur mon ordinateur sous le nom copie.png scp louis@12.345.67.890:image.png . fait la m\u00eame copie sans changer le nom du fichier, le . signifie r\u00e9pertoire courant si le serveur SSH sur lequel on se connecte n'est pas sur le port par d\u00e9faut (22), il faut indiquer le num\u00e9ro de port avec -P . Par exemple scp -P 12345 louis@12.345.67.890:image.png . avec un P majuscule contrairement \u00e0 la commande ssh qui utilise le p minuscule pour le port ftp et sftp permettent de transf\u00e9rer des fichiers Le FTP pour File Transfer Protocol est un protocole permettant d'\u00e9changer des fichiers sur le r\u00e9seau. Il est assez ancien (1985) et toujours utilis\u00e9 \u00e0 l'heure actuelle pour transf\u00e9rer des fichiers On l'utilise pour t\u00e9l\u00e9charger depuis un serveur FTP public, notamment lorsqu'on clique sur un lien de t\u00e9l\u00e9chargement via un navigateur. La connexion se fait alors en mode anonyme . On l'utilise aussi pour transf\u00e9rer des fichiers vers un serveur FTP priv\u00e9 (et aussi t\u00e9l\u00e9charger). La connexion se fait donc en mode authentifi\u00e9 FileZilla est un logiciel graphique qui permet de faire des transferts de fichiers via FTP ftp adresseServeurFtp permet de se connecter \u00e0 un serveur FTP exemple : ftp speedtest.tele2.net ou via un navigateur web ftp://speedtest.tele2.net/ sur les serveur public, le login est toujours anonymous et pour le mot de passe, tout fonctionne. On fait ensuite face \u00e0 un prompt ftp> les commandes sont pour la plupart les m\u00eames que celles qu'on connait : ls liste les fichiers du r\u00e9pertoire courant, pwd affiche le chemin du r\u00e9pertoire actuel, cd change de r\u00e9pertoire... pour utiliser les commandes sur son poste, il faut ajouter un point d'exclamation au d\u00e9but, par exemple !pwd pour savoir dans quel r\u00e9pertoire on est sur notre ordinateur put et get permettent d'envoyer un fichier vers le serveur et de t\u00e9l\u00e9charger un fichier depuis le serveur exemple : get fichier.zip pour t\u00e9l\u00e9charger fichier.zip delete permet de supprimer un fichier et non rm bye , exit , quit et Ctrl+D permet de fermer la session sftp est un FTP s\u00e9curis\u00e9 contrairement \u00e0 FTP ou les donn\u00e9es circulent en clair repose sur SSH pour s\u00e9curiser la connexion : sftp login@ip et on nous demande ensuite notre mot de passe (ou connexion via cl\u00e9 publique/priv\u00e9e) les commandes sont globalement les m\u00eames qu'avec ftp , sauf pour supprimer un fichier, il faut utiliser rm et non plus delete par d\u00e9faut, on utilise le port 22 comme pour SSH. Si le port est diff\u00e9rent, il faut le pr\u00e9ciser comme ceci : sftp -oPort=27401 login@ip rsync permet de synchroniser des fichiers pour une sauvegarde permet d'effectuer une synchronisation entre deux r\u00e9pertoires, que ce soit sur le m\u00eame PC ou entre deux ordinateurs reli\u00e9s en r\u00e9seau utilis\u00e9 pour effectuer des sauvegardes incr\u00e9mentielles : rsync compare et analyse les diff\u00e9rences entre deux dossiers puis copie uniquement les changements rsync -arv dossierASauvegarder/ backup/ fait une sauvegarde dans un autre dossier du m\u00eame ordinateur -a conserve les infos sur les fichiers (droits, date de modification...) -r pour sauvegarder tous les sous-dossiers -v mode verbeux pour afficher les d\u00e9tails par d\u00e9faut, rsync ne supprime pas les fichiers dans le r\u00e9pertoire de copie. Il faut ajouter l'option --delete . Exemple : rsync -arv --delete dossierASauvegarder/ backup/ sauvegarder les fichiers supprim\u00e9s --backup garde de c\u00f4t\u00e9 les fichiers supprim\u00e9s qui prennent un suffixe dans le r\u00e9pertoire de sauvegarde --backup-dir=/chemin d\u00e9place les fichiers supprim\u00e9s dans un dossier d\u00e9di\u00e9. Exemple : rsync -arv --delete --backup --backup-dir=/home/louis/backups_supprimes Images/ backups/ --exclude permet d'exclure un dossier de la sauvegarde rsync permet de sauvegarder sur un autre ordinateur, le plus couramment en utilisant SSH rsync -arv --delete --backup --backup-dir=/home/louis/fichiersSupprimes Images/ louis@ip:backup/ rsync -arv --delete --backup --backup-dir=/home/louis/fichiersSupprimes Images/ louis@ip:backup/ -e \"ssh -p 12345\" si le serveur SSH \u00e9coute sur un autre port que celui par d\u00e9faut Le r\u00e9seau adresse IP : chaque ordinateur reli\u00e9 \u00e0 Internet est identifi\u00e9 par une adresse IP format IPv4 : 86.172.120.28 format IPv6 : fe80::209:62fa:fb80:29f2 nom d'h\u00f4te, hostname en anglais, \u00e9quivalent \u00e0 l'IP mais plus simple \u00e0 retenir host donne le nom d'h\u00f4te \u00e0 partir de l'adresse IP et inversement. Exemple : host siteduzero.com et host 92.243.25.239 les serveurs DNS fournissent la liste des correspondances IP <-> noms d'h\u00f4te le fichier /etc/hosts permet de modifier la liste de correspondance personnalis\u00e9e de notre ordinateur, par exemple ajouter un nom d'h\u00f4te \u00e0 chaque PC pour s'y connecter sans retenir l'IP whois donne des renseignements sur un nom de domaine. Exemple : whois siteduzero.com ifconfig liste les interfaces r\u00e9seau et permet aussi de faire des r\u00e9glages r\u00e9seau exemple : eth0 pour une connexion par c\u00e2ble r\u00e9seau, lo pour la boucle locale, c'est-\u00e0-dire une connexion \u00e0 soi-m\u00eame, wlan0 pour une connexion sans-fil Wi-Fi ifconfig interface etat permet d'activer/d\u00e9sactiver une interface r\u00e9seau, par exemple ifconfig eth0 down ou ifconfig eth0 up netstat permet d'avoir des statistiques sur le r\u00e9seau netstat -i donnent des stats par interface r\u00e9seau netstat -uta liste toutes les connexions ouvertes -u pour les connexions UDP, -t pour les connexions TCP, -a pour afficher toutes les connexions quelque soit leur \u00e9tat permet de voir les ports sur lequels se sont les connexions. -n permet d'avoir les num\u00e9ros des ports plutot qu'une description en toutes lettres -l permet de filter uniquement les connexions \u00e0 l'\u00e9tat LISTEN netstat -s permet d'avoir des statistiques r\u00e9sum\u00e9es iptables est un pare-feu Linux. Il permet d'\u00e9tablir des r\u00e8gles \u00e0 quels ports on peut se connecter \u00e0 votre ordinateur \u00e0 quels ports vous avez le droit de vous connecter filtrer par IP iptables -L affiche les r\u00e8gles actuellement en place Chain INPUT correspond aux r\u00e8gles manipulant le trafic entrant, Chain FORWARD correspond aux r\u00e8gles manipulant la redirection du trafic, Chain OUTPUT correspond aux r\u00e8gles manipulant le trafic sortant policy ACCEPT signifie que par d\u00e9faut, tout le trafic est accept\u00e9, alors que policy DROP permet de resufer toutes les connexions que nous n'avons pas autoris\u00e9 iptables -F permet de r\u00e9initialiser toutes les r\u00e8gles iptables l'ajout et la suppression de r\u00e8gles : TODO","title":"Linux"},{"location":"tutoriel-linux/#tutoriel-linux","text":"","title":"Tutoriel Linux"},{"location":"tutoriel-linux/#raccourcis-utiles","text":"Alt + Ctrl + T permet d'ouvrir un terminal Ctrl + D fin de fichier, ou exit . ferme le terminal Tab permet de faire de l\u2019auto-compl\u00e9tion Ctrl + R permet de faire une recherche parmi les commandes pr\u00e9c\u00e9dentes Ctrl + C arr\u00eate la commande en cours Ctrl + L ou clear efface le contenu de la console Shift + PgUp et Shift + PgDown pour monter et descendre dans la console Ctrl + A ram\u00e8ne le curseur au d\u00e9but de la commande, Ctrl + E ou Fin ram\u00e8ne le curseur \u00e0 la de la commande Ctrl + U supprime ce qui se trouve \u00e0 gauche du curseur, Ctrl + K ce qui se trouve \u00e0 droite Ctrl + W supprime le premier mot \u00e0 gauche du curseur, utile pour supprimer ke param\u00e8tre \u00e0 gauche du curseur Ctrl + Y permet de coller le texte coup\u00e9 avec Ctrl + U , Ctrl + K ou Ctrl + W","title":"Raccourcis utiles"},{"location":"tutoriel-linux/#les-repertoires","text":"/bin pour binaires contient les commandes dont le syst\u00e8me \u00e0 besoin pour d\u00e9marrer /boot est le r\u00e9pertoire o\u00f9 Linux range ce qu'il faut pour d\u00e9marrer. Les fichiers vmlinuz sont les diff\u00e9rents noyaux, on en utilise un seul \u00e0 la fois /dev pour device ou p\u00e9riph\u00e9rique en fran\u00e7ais, contient un fichier pour chaque p\u00e9riph\u00e9rique /etc pour Editable Text Configuration ou configuration \u00e9ditable par texte /lib pour libraries ou biblioth\u00e8qes contient les biblioth\u00e8ques partag\u00e9es par /bin et /sbin /media et /mnt sont les points de montage du syst\u00e8me. /run est un ajout r\u00e9cent qui doit prendre la rel\u00e8ve de /media . Les p\u00e9riph\u00e9riques amovibles doivent \u00eatre mont\u00e9s lors de leur insertion et d\u00e9monter lorsqu'on l'enl\u00e8ve /proc et /sys contiennent un syt\u00e8me de fichiers \"volatile\" qui fournit des infos sur le syst\u00e8me /root est le r\u00e9pertoire de l'utilisateur root /sbin pour system binaries ou binaires syst\u00e8me contient des ex\u00e9cutables pour l'administrateur comme partitionner ou formation des disques, configurer le r\u00e9seau... /usr pour Unix System Resources contient tout ce qui n'est pas utile au fonctionnement minimal du syst\u00e8me. Les applications se trouvent pour la plupart ici. /usr/bin est \u00e9quivalent \u00e0 C:\\Program Files de Windows. /tmp est le r\u00e9pertoire temporaire du syst\u00e8me /var contient des fichiers variables, cr\u00e9es par des serivces, c'est-\u00e0-dire des logiciels qui tournent en t\u00e2che de fond","title":"Les r\u00e9pertoires"},{"location":"tutoriel-linux/#les-types-de-fichier","text":"r\u00e9pertoire avec une barre oblique \u00e0 la fin (couleur par d\u00e9faut : bleu) fichier r\u00e9gulier non ex\u00e9cutable sans suffixe (couleur par d\u00e9faut : noir ou blanc) lien symbolique avec un @ \u00e0 la fin, \u00e9quivalent du raccourci sous Windows (couleur par d\u00e9faut : turquoise) fichier r\u00e9gulier ex\u00e9cutable avec un * \u00e0 la fin (couleur par d\u00e9faut : vert)","title":"Les types de fichier"},{"location":"tutoriel-linux/#les-commandes-de-base","text":"date donne la date et l'heure time { commande ; } ex\u00e9cute commande et donne son temps d'ex\u00e9cution gucharmap affiche la table de caract\u00e8res history affiche la liste des commandes que l'on a saisi !num permet de r\u00e9p\u00e9ter une commande d\u00e9j\u00e0 effectu\u00e9e, par exemple !245 pwd pour Print Working Directory affiche le dossier courant file fichier pr\u00e9cise le type de fichier ls pour list , liste les fichiers et dossiers du r\u00e9pertoire courant. ls /usr liste les fichiers du r\u00e9pertoire usr . -a ou --all affiche les fichiers et dossiers cach\u00e9s -A affiche tout comme -a sauf les dossiers ./ (dossier courant) et ../ (dossier parent) -F indique le type d'\u00e9l\u00e9ment (dossier, fichier, raccourci...) -l liste d\u00e9taill\u00e9e (droits, nombre de liens physiques, nom du propri\u00e9taire, nom du groupe, taille du fichier en octets, date derni\u00e8re modification, nom du fichier). Avec lh , le h pour Human Readable permet d'avoir la taille du fichier en Ko, Mo... ls -l prefixe* permet de lister seulement les fichiers commen\u00e7ant par prefixe -d pour Directory qui affiche le r\u00e9pertoire au lieu d'afficher le contenu. Pour afficher les informations d\u00e9tailles du r\u00e9pertoire sans son contenu : ls -ld -t trie par date de derni\u00e8re modification. On voit en premier le dernier fichier modifi\u00e9. -r renverse l'ordre d'affichage des fichiers -R pour recursive , affiche les sous-dossiers et leur contenu exemple de combinaison des commandes : ls -larth cd Change Directory , c'est-\u00e0-dire changer de dossier. Sans param\u00e8tre, ram\u00e8ne dans le home personnel chemin absolu : on part de la racine : cd /home/gaetan/documents chemin relatif : on part du dossier courant. Exemple si on est dans /home/gaetan : cd documents cd .. pour remonter dans le dossier parent du Disk Usage informe sur la taille que les dossiers occupent. \u00e0 combiner avec -h : du -h -a pour avoir la taille des dossiers ET des fichiers du -ah -s pour avoir juste le total : du -sh echo affiche une ligne de texte et peut l'enregistrer dans un fichier echo Bonjour affiche Bonjour dans la console echo Bonjour > test.txt enregistre Bonjour dans un fichier test.txt . Si le fichier existe d\u00e9j\u00e0, il est \u00e9cras\u00e9. echo Bonjour >> test.txt ajoute une ligne au fichier test.txt cat affiche tout le contenu d'un fichier, et peut en concat\u00e9ner cat test.txt affiche le contenu du fichier cat -n test.txt affiche le contenu du fichier avec les num\u00e9ros de ligne cat test.txt test2.txt affiche le contenu des deux fichiers cat fichier1 fichier2 fichier3 > grosfichier enregistre le contenu des trois fichiers dans un seul pour \u00e9crire dans un fichier sur plusieurs lignes, par exemple 2 lignes : cat > test.txt << FIN ligne1 ligne2 FIN more et less pour afficher les gros fichiers, page par page. Ce sont des logiciels de pagination/visualisation de fichiers texte, on ne peut pas modifier les fichiers avec. more est plus ancien, less plus r\u00e9cent et plus complet more fichier.txt affiche le texte en remplissant un \u00e9cran puis s'arr\u00eate. Pour continuer, il faut : Entr\u00e9e pour avancer ligne \u00e0 ligne Espace pour avancer page \u00e0 page Q pour sortir du mode de visualisation B pour reculer page par page une fois arriv\u00e9 au bout du fichier, on sort du mode de visualisation less est un autre logiciel de visualisation = permet de savoir \u00e0 quelle ligne on est et \u00e0 quel pourcentage du fichier m\u00eames commandes avec quelques avantages : ne quitte pas le mode de visualisation \u00e0 la fin du fichier possibilit\u00e9 de naviguer avec les fl\u00e8ches du clavier fonction de recherche /maChaine . Toutes les occurrences sont affich\u00e9s en surbrillance. Naivguer avec n et N pour passer d'occurrence en occurrence. head et tail permettent d'afficher le d\u00e9but et la fin d'un fichier, par d\u00e9faut 10 lignes. On peut sp\u00e9ficier le nombre de lignes que l'on veut afficher. head -n 4 fichier affiche les 4 premi\u00e8res lignes de fichier tail fichier affiche les 10 derni\u00e8res lignes du fichier tail -f fichier pour follow permet d'afficher la fin du fichier au fur et \u00e0 mesure de son \u00e9volution touch monFichier cr\u00e9e un fichier vide monFichier s'il n'existe pas, sinon modifie l'horodatage du fichier si le fichier existe mkdir , pour Make Directory , sert \u00e0 cr\u00e9er un nouveau r\u00e9pertoire en sp\u00e9cifiant le nom de ce dernier ou en sp\u00e9cifiant le chemin complet mkdir monDossier ou mkdir monDossier monDossier2 pour en cr\u00e9er plusieurs \u00e0 la fois mkdir -p monDossier1/monDossier2 avec l'option -p pour parent pour cr\u00e9er un dossier et un sous-dossier dedans on peut utiliser l'option -v ou --verbose pour avoir des informations sur la cr\u00e9ation pour g\u00e9rer les espaces, 3 possibilit\u00e9s : mkdir \"Mes documents\" , mkdir 'Mes documents' ou mkdir Mes\\ documents tree permet de voir l'arborescence dans le r\u00e9pertoire courant tree monDossier permet de voir l'arborescence d'un sous-dossier du r\u00e9pertoire courant -d n'affiche que les dossiers, -a affiche les dossiers et fichiers cach\u00e9s cp pour copy permet de copier des fichiers et des r\u00e9pertoires cp fichier fichier2 copie le fichier dans le m\u00eame r\u00e9pertoire cp fichier.txt /cheminDestination copie le fichier dans un autre r\u00e9pertoire cp fichier.txt /dossier/fichier2.txt copie le fichier dans un autre r\u00e9pertoire en le renommant cp -R Fichiers/ /tmp/ ou cp -r Fichiers/ /tmp/ permet de copier un r\u00e9pertoire entier avec tout son contenu ( -R pour recursive ) dans le r\u00e9pertoire sp\u00e9cifi\u00e9 cp -R dossier/ copieDossier permet de copier l'int\u00e9gralit\u00e9 du r\u00e9pertoire dans un r\u00e9pertoire d'un autre nom cp -R dossier/ ../copieDossier permet de copier l'int\u00e9gralit\u00e9 du r\u00e9pertoire dans un r\u00e9pertoire d'un autre nom dans un autre endroit du syst\u00e8me mv pour move permet de d\u00e9placer et renommer des fichiers et des r\u00e9pertoires mv fichier dossier/ d\u00e9place fichier dans dossier mv dossier1 dossier2/ d\u00e9place dossier1 et son contenu dans dossier2 mv dossier/fichier ./ d\u00e9place fichier qui est dans dossier dans le r\u00e9pertoire courant mv fichier fichierRenomm\u00e9 renomme fichier en fichierRenomm\u00e9 , fonctionne aussi pour les dossiers mv fichier dossier/fichierRenomm\u00e9 d\u00e9place et renomme le fichier en une seule commande rm et rmdir pour remove et remove directory permettent de supprimer des fichiers et des dossiers rm fichier supprime fichier sans demande de confirmation, le fichier est perdu \u00e0 jamais rm -i fichier pour interactive demande une confirmation avant la suppression rm -f fichier pour force force la suppression si la demande de confirmation est syst\u00e9matique, par exemple avec l'ajout d'un alias sur la commande rm rmdir dossier supprime dossier seulement s'il est vide rm -r dossier pour recursive , supprime dossier et tout son contenu ln permet de cr\u00e9er des liens (raccourcis) entre fichiers. Il existe 2 types de liens : liens physiques : ln fichier1 fichier2 cr\u00e9e fichier2 qui partage le m\u00eame inode (contenu du fichier) que fichier1 ls -i permet d'afficher le num\u00e9ro d'inode pour v\u00e9rifier si les fichiers sont associ\u00e9s au m\u00eame inode Une modification dans l'un entra\u00eene une modification dans l'autre. Si on supprime l'un des 2 fichiers, l'autre reste en place et le contenu est toujours le m\u00eame. Il faut supprimer les 2 pour supprimer le contenu. liens symboliques : ln -s fichier1 fichier2 pour symbolique . Cr\u00e9e fichier2 qui pointe sur fichier1 . ressemble davantage au \"raccourci\" sous Windows, c'est-\u00e0-dire qu'on cr\u00e9e un lien vers un autre fichier on \u00e9dite le m\u00eame contenu dans fichier1 et fichier2 fonctionnent sur des r\u00e9pertoires contrairement aux liens physiques qui ne fonctionnent que sur les fichiers si on supprime fichier2 , rien de mal. Si on supprime fichier1 , fichier2 pointe vers un fichier qui n'existe plus, on parle de lien mort alias concerne les alias de commande, qui sont des raccourcis alias permet de voir les alias existants alias rm='rm -i' permet de cr\u00e9er un alias. Cette cr\u00e9ation n'est pas persistante, elle dispara\u00eet en fermant la console la documentation man pour manual affiche le manuel d'une commande comme avec la commande less : man mkdir . /test pour rechercher test dans la documentation. La documentation man est aussi disponible sur internet apropos permet de chercher les commandes en rapport \u00e0 un terme, par exemple apropos sound --help donne une information proche de celle de man , par exemple mkdir --help whatis donne juste le nom de la commande pour comprendre ce qu'elle fait, par exemple whatis mkdir info affiche un manuel en ligne encore plus complet que man , par exemple info mkdir rechercher des fichiers locate fichier pour une recherche rapide sur la base de donn\u00e9es des fichiers qui est mise \u00e0 jour toutes les 24 heures. Pour la mettre \u00e0 jour, lancer la commande sudo updatedb find pour une recherche approfondie, en parcourant les fichiers sur le disque, ce qui peut \u00eatre long. La commande s'utilise avec des param\u00e8tres find \"o\u00f9\" \"quoi\" \"que faire avec\" . Seul \"quoi\" est obligatoire. o\u00f9 est le dossier dans lequel on fait la recherche, ainsi que tous ses sous-dossiers. Si non renseign\u00e9, recherche dans le dossier courant quoi fichier ou dossier \u00e0 rechercher, par nom, date de cr\u00e9ation, taille... que faire avec on peut faire un post-traitement. Par d\u00e9faut, la commande affiche la liste des fichiers trouv\u00e9s, mais d'autres actions sont possibles -iname option qui permet d'ignorer la casse pour faire la recherche, par exemple find /etc/ -iname 'readme' exemples : find -name \"README.md\" recherche un fichier dans le r\u00e9pertoire courant qui s'appelle exactement README.md . On peut utiliser l'\u00e9toile pour rechercher des noms incomplets, par exemple : find -name \"READM*\" find /var/log/ -name \"syslog\" find /etc -type d permet d'afficher tous les r\u00e9pertoires et sous-r\u00e9pertoires du dossier find -size +10M permet de rechercher les fichiers de plus de 10Mo. On peut utiliser le - au lieu de + , et le k ou le G \u00e0 la place du M find -name \"*.md\" -atime 6 recherche les fichiers au format markdown modifi\u00e9 il y a moins de 7 jours (0 pour 1 jour). On peut enlever le - pour modifi\u00e9 exactement il y a x jours -type d et -type f permet de limiter la recherche aux r\u00e9pertoires ou aux fichiers, par exemple find -name \"syslog\" -type d find -name \"README.md\" -print permet d'afficher les r\u00e9sultats, ce qui correspond au r\u00e9sultat par d\u00e9faut find -name \"README.md\" -printf permet de formater le r\u00e9sultat affich\u00e9, par exemple find -name \"README.md\" -printf \"%p - %u\\n\" -delete permet de supprimer les fichiers trouv\u00e9s, par exemple find -name \"README.md\" -delete -exec , permet d'appeler une commande qui effectuera une action sur chacun des fichiers trouv\u00e9s find /bin -size +200k -exec ls -l \\{} \\; permet d'effectuer un ls -l sur les r\u00e9sultats de la recherche. {} symbolise le r\u00e9sultat de la recherche find /bin -size +200k | xargs ls -l . xargs sert \u00e0 construire et ex\u00e9cuter des lignes de commande \u00e0 partir de l\u2019entr\u00e9e standard manipulations dans les fichiers awk est un langage de traitement de lignes qui sert \u00e0 manipuler des fichiers textes awk NR==5 fichier affiche la 5e ligne de fichier awk NR==2,NR==4 fichier affiche les lignes 2 \u00e0 4 de fichier sed , pour stream editor sed -n 5p fichier affiche la 5e ligne de fichier sed -n 2,4p fichier affiche les lignes 2 \u00e0 4 de fichier grep permet de filtrer des donn\u00e9es grep texte fichier permet de chercher texte dans fichier , par exemple grep alias .bashrc permet de chercher le mot alias dans le fichier .bashrc et affiche toutes les lignes du fichier comportant ce mot -i pour ne pas tenir compte de la casse, grep -i texte fichier -n pour afficher les num\u00e9ros de lignes -v permet d'inverser la recherche et d'afficher uniquement les lignes qui ne contiennent pas le mot recherch\u00e9 -c permet de compter le nombre de lignes au lieu de les afficher -r permet de faire une recherche r\u00e9cursive dans tous les sous-dossiers et fichiers, par exemple grep -r machaine dossier/ . Le nom du fichier o\u00f9 la cha\u00eene a \u00e9t\u00e9 trouv\u00e9 s'affiche au d\u00e9but de la ligne -E permet d'utiliser des expressions r\u00e9guli\u00e8res on peut utiliser egrep \u00e0 la place de grep -E -E n'est pas obligatoire car les expressions r\u00e9guli\u00e8res sont activ\u00e9es de base sur Linux. C'est utile sur les autres syst\u00e8mes Unix . caract\u00e8re quelconque, ^ d\u00e9but de ligne, $ fin de ligne, [] un des caract\u00e8res entre les crochets, ? l'\u00e9l\u00e9ment pr\u00e9c\u00e9dent est optionnel (peut \u00eatre pr\u00e9sent 0 ou 1 fois), * l'\u00e9l\u00e9ment pr\u00e9c\u00e9dent peut \u00eatre pr\u00e9sent 0, 1 ou plusieurs fois, + l\u00b2'\u00e9l\u00e9ment pr\u00e9c\u00e9dent doit \u00eatre pr\u00e9sent 1 ou plusieurs fois, | ou, () groupement d'expressions par exemple grep -E ^alias .bashrc pour rechercher le mot alias uniquement en d\u00e9but de ligne grep -E [Aa]lias .bashrc renvoie les lignes qui contiennent alias ou Alias grep -E [0-4] .bashrc renvoie les lignes qui contiennent un chiffre entre 0 et 4 sort permet de trier les lignes sort fichier trie les lignes du fichier par ordre alphab\u00e9tique et affiche le r\u00e9sultat dans la console, en ignorant la casse -o permet d'\u00e9crire le r\u00e9sultat dans un fichier : sort -o resultatTri\u00e9 fichierATrier -r permet de trier en ordre inverse, sort -r fichier -R permet de trier al\u00e9atoirement -n permet de trier des nombres. Sans cette option, ils sont tri\u00e9s alphab\u00e9tiquement donc par exemple 150 serait avant 18 wc pour word count permet de compter le nombre de lignes, de mots, de caract\u00e8res, d'octets wc fichier retourne le nombre de lignes, de mots et d'octets -l retourne le nombre de lignes, wc -l fichiers -w retourne le nombre de mots -c retourne le nombre d'octets -m retourne le nombre de caract\u00e8res uniq permet de supprimer les doublons (lignes identiques) seulement si elles se suivent, il faut donc travailler sur un fichier tri\u00e9 uniq fichier affiche dans la console la liste des lignes sans doublons uniq fichierATraiter fichierSansDoublons enregistre le r\u00e9sultat dans un fichier -c compte le nombre d'occurence, affiche devant chaque ligne le nombre de fois qu'elle est pr\u00e9sente dans le fichier, par exemple uniq -c fichier -d affiche uniquement les lignes pr\u00e9sentes plusieurs fois cut permet de couper les lignes d'un fichier afin de conserver uniquement une partie de chaque ligne -c pour couper selon le nombre de caract\u00e8res. cut -c 2-5 noms.txt affiche les caract\u00e8res 2 \u00e0 5 de chaque ligne, cut -c -3 du 1er au 3 et cut -c 3- du 3e au dernier couper selon un d\u00e9limiteur, -d pour pr\u00e9ciser le d\u00e9limiteur, -f pour indiquer le num\u00e9ro du ou des champs \u00e0 couper. cut -d , -f 1 fichier conserve le 1er champ de chaque ligne, -f 2-4 conserve les champs 2, 3 et 4, -f 1,3 les champs 1 et 3","title":"Les commandes de base"},{"location":"tutoriel-linux/#les-editeurs-de-texte","text":"Il en existe plusieurs. Les plus connus sont Nano, Vim et Emacs. - Nano - \u00e9diteur de texte simple compar\u00e9 \u00e0 Vim et Emacs - nano pour lancer l'\u00e9diteur vide - nano fichier lance l'\u00e9diteur en ouvrant le fichier - -m pour autoriser l'utilisation de la souris - -i pour l'indentation automatique, c'est-\u00e0-dire que la tabulation de la ligne pr\u00e9c\u00e9dente sera respect\u00e9 lorsqu'on va \u00e0 la ligne - Nano se configure dans le fichier .nanorc , situ\u00e9 \u00e0 la racine du home pour son propre fichier de configuration ( /home/user/.nanorc ), o\u00f9 dans le fichier nanorc situ\u00e9 dans le dossier etc ( /etc/nanorc ). Ce dernier n\u00e9cessite d'\u00eatre en root pour le modifier. Il contient d\u00e9j\u00e0 plusieurs options mises en commentaires pour l'exemple Emacs : puissant \u00e9diteur de texte d\u00e9velopp\u00e9 par Richard Stallman, le fondateur du projet GNU Vim : autre puissant \u00e9diteur de texte g\u00e9n\u00e9ralement disponible par d\u00e9faut sur Linux Vi existe en plusieurs versions : vi , le clone elvis , vim (VI iMproved, version am\u00e9lior\u00e9e de Vi),ou encore gvim dot\u00e9e d'une interface graphique Vimtutor pour apprendre \u00e0 s'en servir","title":"Les \u00e9diteurs de texte"},{"location":"tutoriel-linux/#configuration-de-la-console","text":"Il faut modifier le fichier .bashrc personnel situ\u00e9 dans le r\u00e9pertoire personnel, ou le fichier bashrc global situ\u00e9 dans le r\u00e9pertoire /etc/bash.bashrc . On peut par exemple personnaliser l'invite de commande, ou aussi y cr\u00e9er des alias qui sont persistants. Il existe \u00e9galement un fichier ~/.profile et un fichier /etc/profile qui est lu dans les consoles o\u00f9 on se logue (les consoles Alt+Ctrl+F1 \u00e0 F6), alors que le .bashrc est lu dans les consoles o\u00f9 on ne se logue pas, comme les consoles en mode graphique. Le .profile fait appel au .bashrc par d\u00e9faut, donc faire des modifications dans le .bashrc modifiera les options pour les consoles avec et sans login.","title":"Configuration de la console"},{"location":"tutoriel-linux/#les-utilisateurs-et-les-droits","text":"Chaque personne \u00e0 son propre compte utilisateur avec des droits limit\u00e9s. Il existe un super-utilisateur appel\u00e9 root qui a tous les droits, qui ne doit servir que rarement, lorsque c'est n\u00e9cessaire. sudo pour Substitute User DO ou encore faire en se substituant \u00e0 l'utilisateur, permet de devenir root temporairement le temps d'ex\u00e9cuter une commande en faisant sudo commande sudo su pour switch user , permet de devenir root et de le rester dans Ubuntu su - est suffisant dans les autres distributions, le tiret rend accessible certains programmes destin\u00e9s seulement \u00e0 root, et nous place dans le dossier personnel de root ( /root ) le symbole # \u00e0 la fin de l'invite de commandes indique que l'on est devenu super-utilisateur exit permet de quitter le mode root , permet aussi de fermer la console dans une session normale su - test permet de se connecter avec le compte utilisateur test , le tiret indique que l'on souhaite utiliser ses variables d'environnement whoami permet de savoir avec quel utilisateur on est connect\u00e9 id permet d'afficher l'UID (User Identification), le GID (Group Identification) et la liste de groupe secondaires de l'utilisateur connect\u00e9, par exemple affiche uid=1000(gaetan) gid=1000(gaetan) groupes=1000(gaetan),4(adm),24(cdrom),27(sudo),30(dip),46(plugdev),113(lpadmin),130(sambashare) id user affiche les m\u00eames informations pour l'utilisateur user id -u affiche uniquement le num\u00e9ro uid id -g affiche uniquement le num\u00e9ro gid id -gn affiche uniquement le nom du groupe id -Gn ou groups affiche les noms des groupes dont l'utilisateur est membre finger user affiche les donn\u00e9es GECOS de user , c'est-\u00e0-dire son login, son nom, son home, son shell, etc... le fichier /etc/passwd contient les informations des utilisateurs concernant leur connexion, par exemple : gaetan:x:1000:1000:Ga\u00ebtan Varlet,,,:/home/gaetan:/bin/bash . utilisateur root, uid=0 utilisateurs syst\u00e8me, uid compris entre 1 et 99 utilisateurs normaux avec uid sup\u00e9rieur ou \u00e9gal \u00e0 1000 les mdp sont dans le fichier /etc/shadow , uniquement accessible par root","title":"Les utilisateurs et les droits"},{"location":"tutoriel-linux/#gestion-des-utilisateurs","text":"commandes r\u00e9serv\u00e9s \u00e0 root adduser permet d'ajouter un utilisateur, avec au minimum le nom d'utisateur \u00e0 cr\u00e9er, par exemple adduser louis r\u00e9pertoire personnel est cr\u00e9\u00e9 on doit choisir un mot de passe passwd permet de changer le mot de passe du compte en param\u00e8tre, par exemple passwd louis sans param\u00e8tre, c'est le mdp de l'utilisateur connect\u00e9 que l'on modifie deluser permet de supprimer un compte, par exemple deluser louis ne supprime pas le r\u00e9pertoire personnel. Si on souhaite le faire, ajouter l'option --remove-home , par exemple deluser --remove-home louis ou encore userdel -r louis adduser et deluser n'existent que sous Debian et ses descendants dont Ubuntu. Ailleurs, il faut utiliser les commandes Unix traditionnelles useradd et userdel qui font la m\u00eame chose de mani\u00e8re plus basique, par exemple il faut appeler passwd pour d\u00e9finir un mdp et activer le compte","title":"Gestion des utilisateurs"},{"location":"tutoriel-linux/#gestion-des-groupes","text":"chaque utilisateur appartient \u00e0 un groupe. Par d\u00e9faut, un groupe du m\u00eame nom que l'utilisateur est cr\u00e9\u00e9 addgroup permet de cr\u00e9er un groupe, par exemple addgroup famille delgroup permet de supprimer un groupe, par exemple delgroup famille usermod permet de modifier un utilisateur -l renomme l'utilisateur sans renommer son r\u00e9pertoire personnel -g change de groupe, par exemple usermod -g famille louis pour mettre Louis dans le groupe famille et usermod -g louis louis pour le remettre dans le groupe louis -G permet \u00e0 un utilisateur d'avoir plusieurs groupes, par exemple usermod -G famille,amis louis . L'utilisateur ne sera plus dans les groupes dans lesquels il \u00e9tait avant. -a permet d'ajouter des groupes \u00e0 un utilisateur sans perdre les groupes auxquels il appartient, par exemple usermod -aG famille louis gpasswd -d permet de supprimer l'appartenance d'un utilisateur \u00e0 un groupe, par exemple gpasswd -d louis audio le fichier /etc/group contient la liste des groupes avec leur GID et la liste de des membres des groupes addgroup et delgroup n'existent que sous Debian et ses d\u00e9riv\u00e9s. Les commandes traditionnelles sont groupadd et groupdel qui offrent moins d'options","title":"Gestion des groupes"},{"location":"tutoriel-linux/#gestion-des-proprietaires-dun-fichier","text":"seul l'utilisateur root peut changer le propri\u00e9taire d'un fichier chown pour change owner , permet de changer le propri\u00e9taire d'un fichier, en renseignant le nom du nouveau propri\u00e9taire et le nom du fichier, par exemple chown louis fichier . Cela ne change pas le groupe du fichier chown louis:famille fichier permet de changer le propri\u00e9taire et le groupe en m\u00eame temps -R pour recursive permet d'affecter tous les sous-dossiers et fichiers contenu dans le dossier, par exemple chown -R louis:louis /home/gaetan/dossier/ chgrp permet de changer le groupe propri\u00e9taire du fichier, par exemple chgrp famille fichier","title":"Gestion des propri\u00e9taires d'un fichier"},{"location":"tutoriel-linux/#modifier-les-droits-dacces","text":"chaque fichier et dossier poss\u00e8de des droits : voir, modifier et ex\u00e9cuter la commande ls -l permet de voir les droits, il s'agit des 10 premiers caract\u00e8res le 1er d pour directory si c'est un dossier, l pour link ou - si c'est un fichier 3 triplets qui correspondent aux droits de l'utilisateur, du groupe et des autres. Un triplet correspond \u00e0 rwx pour read , write et execute Ce dernier n'est utile que pour les fichiers ex\u00e9cutables (programmes et scripts). si la lettre appara\u00eet, c'est que le droit existe. S'il y a un tiret \u00e0 la place, c'est qu'il n'y a aucun droit. si c'est un dossier, x indique qu'on peut se placer dans le r\u00e9pertoire avec la commande cd , et voir son contenu si on a les droits en lecture dessus r . les droits de modification donnent aussi les droits de suppression root \u00e0 tous les droits chmod permet de modifier les droits d'acc\u00e8s. Pas besoin d'\u00eatre root, il suffit d'\u00eatre propri\u00e9taire du fichier pour modifier les droits d'acc\u00e8s plusieurs m\u00e9thodes d'attribution des droits avec des chiffres : r=4, w=2, x=1. On les combine en additionnant, par exemple 6 donne les droits en lecture et \u00e9criture. \u00e7a va de 0 \u00e0 7. chmod 777 fichier donne tous les droits \u00e0 tout le monde, chmod 000 fichier ne donne aucun droit \u00e0 personne, sauf \u00e0 root avec des lettres : u=user, g=group, o=other. + =ajouter, - =supprimer et = =affecter. Par exemple chmod g+w fichier ajoute le droit en \u00e9criture au groupe -R pour affecter r\u00e9cursivement tous les sous-dossiers et fichiers, par exemple chmod -R 700 /home/louis umask permet de voir les permissions par d\u00e9faut. Un fichier cr\u00e9\u00e9 ne peut avoir de base les droits d'ex\u00e9cution.","title":"Modifier les droits d'acc\u00e8s"},{"location":"tutoriel-linux/#installer-des-programmes","text":"paquet : c'est un programme \u00ab pr\u00eat \u00e0 l'emploi \u00bb, l'\u00e9quivalent des programmes d'installation sous Windows en quelque sorte. C'est une sorte de dossier zipp\u00e9 qui contient tous les fichiers du programme. Il se pr\u00e9sente sous la forme d'un fichier .deb et contient toutes les instructions n\u00e9cessaires pour installer le programme d\u00e9pendance : un paquet peut avoir besoin de plusieurs autres paquets pour fonctionner, on dit qu'il a des d\u00e9pendances d\u00e9p\u00f4t : c'est le serveur sur lequel on va t\u00e9l\u00e9charger nos paquets programme graphique qui g\u00e8re les paquets ou utiliser un programme en ligne de commande comme apt-get ou aptitude apt-get update met \u00e0 jour le cache (liste des paquets existant propos\u00e9 par le d\u00e9p\u00f4t) apt-cache search paquetRecherch\u00e9 recherche le paquet que l'on veut t\u00e9l\u00e9charger si on ne connait pas le nom exact apt-get install monPaquet t\u00e9l\u00e9charge et installe le paquet apt-get upgrade met \u00e0 jour tous les paquets install\u00e9s, apr\u00e8s avoir fait un apt-get update car apt-get comapre la version des paquets install\u00e9s avec ceux pr\u00e9sents dans le cache apt-get autoremove monPaquet permet de d\u00e9sinstaller un paquet et les d\u00e9pendances devenues inutiles alors apt-get remove monPaquet ne supprime que le paquet en param\u00e8tre Programmes absents des d\u00e9p\u00f4ts officiels Si un programme est absent des d\u00e9p\u00f4ts officiels, on peut parfois trouver sur le site web du logiciel un paquetage .deb , sp\u00e9cifique \u00e0 Debian et ses distributions d\u00e9riv\u00e9es. Par exemple, Red Hat utilise des .rpm . - t\u00e9l\u00e9charger le .deb et double-cliquer dessus. - s'il n'y a pas d'erreurs, on peut installer le programme - sinon, le programme ne correspond pas \u00e0 notre machine (32 bits au lieu de 64 bits par exemple) ou alors qu'il manque des d\u00e9pendances qu'il faut installer manuellement Si le .deb n'est pas disponible, il faut alors r\u00e9cup\u00e9rer le code source du programme et le compiler pour avoir un ex\u00e9cutable pour sa machine - le programme build-essential est n\u00e9cessaire pour compiler le code source d'un programme - trouver le code source sur le site du programme et le t\u00e9l\u00e9charger, et \u00e9ventuellement le d\u00e9compresser - ex\u00e9cuter le programme configure avec la commande ./configure . Cela analyse notre ordinateur et v\u00e9rifie si tous les outils n\u00e9cessaires \u00e0 la compilation du logiciel que l'on souhaite installer sont bien pr\u00e9sents - s'il y a une erreur, il y a s\u00fbrement des paquets manquants. Il faut le trouver, l'installer puis relancer ./configure jusqu'\u00e0 qu'il n'y ait plus d'erreurs - une fois qu'il n'y a plus d'erreur, lancer la compilation avec la commande make qui cr\u00e9e l'ex\u00e9cutable - installer le programme avec la commande sudo make install . Une fois termin\u00e9, le programme est install\u00e9 et on peut le lancer en \u00e9crivant son nom dans la ligne de commande - pour le d\u00e9sinstaller, ex\u00e9cuter la commande sudo make uninstall depuis le r\u00e9pertoire o\u00f9 il a \u00e9t\u00e9 compil\u00e9. Si on supprime le r\u00e9pertoire avec le code source, on ne pourra plus lancer la commande de d\u00e9sinstallation","title":"Installer des programmes"},{"location":"tutoriel-linux/#les-flux-de-redirection","text":"Au lieu d'afficher le r\u00e9sultat d'une commande dans la console (comportement par d\u00e9faut), on peut le rediriger - dans un fichier - en entr\u00e9e d'une autre commande pour effectuer des cha\u00eenes de commandes - dans la \"corbeille\", commande > /dev/null , tout est supprim\u00e9 imm\u00e9diatement, si on ne veut ni l'afficher dans la console ni dans un fichier > et >> permettent de rediriger le r\u00e9sultat dans un nouveau fichier pour > et \u00e0 la fin d'un fichier pour >> echo Bonjour affiche Bonjour dans la console echo Bonjour > test.txt enregistre Bonjour dans un fichier test.txt . Si le fichier existe d\u00e9j\u00e0, il est \u00e9cras\u00e9 echo Bonjour >> test.txt ajoute une ligne au fichier test.txt .Si le fichier n'existe pas, il sera cr\u00e9\u00e9 2>, 2>> et 2>&1 permettent de rediriger les erreurs toutes les commandes produisent deux flux de donn\u00e9es : la sortie standard et la sortie d'erreur . Par d\u00e9faut, les deux s'affichent dans la console avec > et >> , seule la sortie standard est redirig\u00e9e vers le fichier, les erreurs continuent \u00e0 \u00eatre affich\u00e9 dans la console 2> permet de rediriger les erreurs dans un fichier \u00e0 part, par exemple ls -l /root/ > test 2> erreur redirige la sortie standard dans le fichier test et la sortie d'erreur dans le fichier erreur 2>> permet d'ajouter les erreurs \u00e0 la fin du fichier 2>&1 permet de fusionner les sorties dans un seul fichier, par exemple ls -l / > testFusion 2>&1 < et << permet de lire depuis un fichier pour < , et de lire progressivement depuis le clavier pour << l'entr\u00e9e d'une commande vient des param\u00e8tres de la commande, mais elle peut aussi venir d'un fichier ou d'une saisie au clavier cat < fichier affiche le contenu de fichier . La commande cat re\u00e7oit le contenu du fichier qu'elle affiche, alors que la commande cat fichier re\u00e7oit le nom du fichier qu'elle doit d'abord ouvrir pour ensuite afficher son contenu. Le r\u00e9sultat est le m\u00eame mais ce qui se passe derri\u00e8re est diff\u00e9rent << passe la console en mode saisie au clavier ligne par ligne. Toutes ces lignes seront envoy\u00e9es \u00e0 la commande lorsque le mot-cl\u00e9 de fin aura \u00e9t\u00e9 \u00e9crit. Par exemple : wc -m << FIN Combien de caract\u00e8res dans cette phrase ? FIN | permet de cha\u00eener les commandes connecter la sortie d'une commande \u00e0 l'entr\u00e9e d'une autre commande exemple : du | sort -nr | head permet d'afficher les 10 dossiers les plus lourds tri\u00e9s par taille","title":"Les flux de redirection"},{"location":"tutoriel-linux/#surveiller-lactivite-du-systeme","text":"w permet de voir qui est connect\u00e9 et ce qu'ils font l'heure, aussi accessible via date l'uptime, aussi accessible via uptime , qui indique depuis combien de temps l'ordinateur n'a pas \u00e9t\u00e9 red\u00e9marr\u00e9 la charge, aussi accessible via uptime et tload . Il s'agit de la charge moyenne depuis 1, 5 et 15 minutes, plus pr\u00e9cis\u00e9ment le nombre de processus qui r\u00e9clament le processeur. La charge maximale correspond au nombre de processeur, au del\u00e0, il y a surcharge la liste des personnes connect\u00e9s sur la machine, accessible aussi via who free -m mesure la consommation m\u00e9moire. L'option -m permet d'avoir l'information en Mo ps et top pour lister les processus un processus est un programme qui tourne en m\u00e9moire. Certains programmes ne font tourner qu'un processus, d'autres plusieurs comme Chrome qui cr\u00e9e un processus par onglet ps permet d'avoir la liste statique des processus en cours PID est l'identifiant du processus par d\u00e9faut, seul les processus lanc\u00e9s par l'utilisateur dans la console sont affich\u00e9s ps -x affiche l'ensemble des processus de l'utilisateur -a ajoute ceux de tous les utilisateurs -u donne des informations suppl\u00e9mentaires comme le propri\u00e9taire du processus, l'utilisation du processus et de la m\u00e9moire ps -ef permet d'afficher tous les processus et ps -ejH de les afficher en arbre pstree , ou pstree | less affiche l\u2019organisation hi\u00e9rarchique de tous les processus en cours du syst\u00e8me top permet d'avoir la liste dynamique des processus et permet de mesurer la consommation en ressources de chaque processus affiche les processus tri\u00e9 sur le taux d'utilisation du processeur h permet d'afficher l'aide Ctrl + C ou kill pour arr\u00eater un processus Ctrl + C permet d'arr\u00eater un processus lanc\u00e9 en console kill permet d'arr\u00eater proprement un processus lanc\u00e9 en arri\u00e8re-plan en indiquant son PID , par exemple kill 12345 kill -9 permet de tuer un processus sans lui laisser le temps de s'arr\u00eater proprement, s'il refuse de se fermer normalement. Par exemple kill -9 12345 killall permet de tuer tous les processus d'un m\u00eame programme, par exemple killall find \u00e9teindre l'ordinateur halt , poweroff et reboot -p arr\u00eatent le syst\u00e8me en tuant tous les processus sans pr\u00e9venir personne reboot redem\u00e9arre le syst\u00e8me de la m\u00eame mani\u00e8re shutdown arr\u00eate ou red\u00e9marre le syst\u00e8me proprement : shutdown -h now et shutdown -r now","title":"Surveiller l'activit\u00e9 du syst\u00e8me"},{"location":"tutoriel-linux/#executer-des-programmes-en-arriere-plan","text":"un service , ou demon est un processus qui s'ex\u00e9cute en arri\u00e8re-plan plut\u00f4t que sous le contr\u00f4le direct d'un utilisateur & permet de lancer un processus en arri\u00e8re-plan, par exemple cp fichier copie & les messages renvoy\u00e9s par les commandes s'affichent toujours dans la console. On peut donc les envoyer dans un fichier, par exemple find / -name \"*log\" > sortiefind & nohup permet de d\u00e9tacher le processus de la console. Si l'utilisateur se d\u00e9connecte ou si la console est ferm\u00e9e, le processus continuera. Exemple : nohup fichier copie Ctrl+Z met en pause un processus ex\u00e9cut\u00e9 au premier plan, sans & donc bg pour background , passe le processus en pause en arri\u00e8re-plan jobs permet de conna\u00eetre les processus qui tournent en arri\u00e8re-plan fg pour foreground , permet de reprendre un processus au premier plan fg s'il y a un seul processus en arri\u00e8re-plan list\u00e9 dans jobs fg %x s'il y a plusieurs processus en arri\u00e8re-plan pour reprendre le processus x screen est un programme qui permet d'ouvrir plusieurs consoles virtuelles au sein d'une seule et m\u00eame console, et d'ex\u00e9cuter facilement plusieurs processus en parall\u00e8le","title":"Ex\u00e9cuter des programmes en arri\u00e8re-plan"},{"location":"tutoriel-linux/#executer-des-programmes-a-une-heure-differee","text":"date permet d'afficher la date date \"+%H:%M:%S\" permet de personnaliser l'affichage sudo date MMDDhhmmYYYY permet de modifier la date syst\u00e8me at permet d'ex\u00e9cuter une commande plus tard une seule fois 1) on indique quand on veut ex\u00e9cuter la commande, par exemple at 18:17 ou at 18:17 tomorrow ou at 18:17 04/12/18 (12 avril, attention \u00e0 l'ordre MM/DD/YY) ou encore at now +5 minutes (minutes, hours, days, weeks, months, years) 2) taper la ou les commandes que l'on veut ex\u00e9cuter \u00e0 cette heure l\u00e0 3) faire Ctrl + D . Le symbole <EOT> s'affiche et nous donne le num\u00e9ro de la t\u00e2che (job en anglais) atq permet d'avoir la liste des jobs en attente atrm permet de supprimer un job en attente, par exemple atrm 5 pour supprimer le job n\u00b05 il est possible d'encha\u00eener des commandes : avec le point-virgule, par exemple touch fichier; rm fichier avec les && , par exemple touch fichier && sleep 10 && rm fichier . Les instructions ne s'encha\u00eeneront que si elles se sont correctement ex\u00e9cut\u00e9es sleep permet de faire une pause, par exemple touch fichier; sleep 10; rm fichier ou une pause de 10 secondes aura lieu on peut r\u00e9gler l'unit\u00e9 de sleep qui est par d\u00e9faut la seconde : m pour minute, h pour heure et d pour jour. Exemple : sleep 1m crontab permet ex\u00e9cuter une commande r\u00e9guli\u00e8rement crontab permet de lire et modifier un fichier appel\u00e9 la crontab , qui contient la liste des programmes \u00e0 ex\u00e9cuter r\u00e9guli\u00e8rement, et l'heure \u00e0 laquelle ils soient ex\u00e9cut\u00e9s -l permet d'afficher la crontab, -e la modifier, -r la supprimer sans confirmation syntaxe : m h dom mon dow command pour minute (0-59), hour (0-23), day of month (1-31), month (1-12), day of week (0-6, 0=dimanche) on peut mettre une \u00e9toile \u00e0 la place d'un chiffre pour dire tous les chiffres 3,5,10 pour les 3 valeurs, 3-7 pour les valeurs 3 \u00e0 7, */3 pour les multiples de 3, par exemple 0, 3, 6, 9... le r\u00e9sultat de la commande n'appara\u00eet pas dans la console, il est normalement envoy\u00e9 par mail le rediriger dans un fichier : 45 18 * * * touch /home/louis/fichier >> /home/louis/cron.log 2>&1 le rediriger dans le trou noir pour suppression imm\u00e9diate : * * * * * commande > /dev/null 2>&1 exemples : 45 18 * * * commande est ex\u00e9cut\u00e9 tous les jours \u00e0 18h45 0 0 * * 1 commande tous les lundis \u00e0 minuit (nuit de dimanche \u00e0 lundi) 0 4 1 * * commande tous les premiers du mois \u00e0 4h 0 4 * 12 * commande tous les jours du mois de d\u00e9cembre * * * * * toutes les minutes, c'est la fr\u00e9quence minimale","title":"Ex\u00e9cuter des programmes \u00e0 une heure diff\u00e9r\u00e9e"},{"location":"tutoriel-linux/#archiver-et-compresser","text":"tar , pour tape archiver , est un programme d'archivage. Il permet : d'assembler des fichiers dans une archive regroupement des fichiers dans un m\u00eame dossier cr\u00e9ation de l'archive tar : tar -cvf nomArchive.tar nomDossier/ . -c pour la cr\u00e9ation de l'archive, -v pour l'affichage des d\u00e9tails de l'op\u00e9ration et -f pour assembler l'archive dans un fichier d'afficher le contenu d'une archive sans l'extraire, par exemple tar -tf archive.tar d'ajouter un fichier \u00e0 une archive existante, par exemple tar -rvf archive.tar nouveauFichier d'extraire les fichiers d'une archive, par exemple tar -xvf archive.tar avec -x pour extract . Le contenu de l'archive est extrait dans le r\u00e9pertoire courant Les diff\u00e9rents programmes de compression d'une archive - gzip , pour GNU Zip , est le plus connu et le plus utilis\u00e9 - gzip archive.tar compresse l'archive qui devient archive.tar.gz - gunzip archive.tar.gz ou gzip -d archive.tar.gz d\u00e9compresse l'archive qui redevient archive.tar - bzip2 compresse mieux mais plus lentement - bzip2 archive.tar compresse l'archive qui devient archive.tar.bz2 - bunzip2 archive.tar.bz2 ou bzip2 -d archive.tar d\u00e9compresse l'archive qui redevient archive.tar - compress n'est plus utilis\u00e9 car moins performant que gzip et bzip2 - contrairement \u00e0 zip et rar , gzip et bzip2 ne peuvent compresser qu'un seul fichier \u00e0 la fois, c'est pour cela qu'il faut cr\u00e9er une archive tar auparavant Archiver et compresser en m\u00eame temps avec tar - avec gzip - -zcvf permet d'archiver et compresser, par exemple tar -zcvf nomArchive.tar.gz nomDossier/ - -zxvf permet de d\u00e9compresser, par exemple tar -zxvf nomArchive.tar.gz - avec bzip2 - -jcvf permet d'archiver et compresser, par exemple tar -zcvf nomArchive.tar.bz2 nomDossier/ - -jxvf permet de d\u00e9compresser, par exemple tar -zxvf nomArchive.tar.bz2 Lecture d'un fichier compress\u00e9 - on peut compresser directement un fichier en faisant gzip fichier - si on veut le lire, par exemple en faisant cat fichier , des caract\u00e8res bizarres s'affichent \u00e0 cause de la compression. A la place, on peut utiliser zcat , zmore ou zless qui permettent de lire un fichier compress\u00e9. Exemple zmore fichier D\u00e9compresser les zip et les rar - unzip permet de d\u00e9compresser un .zip - exemple unzip archive.zip - -l permet d'afficher le contenu sans l'extraire, par exemple unzip -l archive.zip - zip permet de cr\u00e9er un zip , par exemple zip -r dossier.zip dossier/ - unrar permet de d\u00e9compresser un rar - exemple unrar e toto.rar sans tiret devant le e - unrar l toto.rar permet d'afficher le contenu sans l'extraire - il n'est pas possible gratuitement de cr\u00e9er des rar car c'est un format propri\u00e9taire. Le paquet rar est payant","title":"Archiver et compresser"},{"location":"tutoriel-linux/#les-connexions-a-distance","text":"","title":"Les connexions \u00e0 distance"},{"location":"tutoriel-linux/#les-protocoles","text":"on peut configurer une machine Linux pour s'y connecter \u00e0 distance \u00e0 condition qu'elle reste allum\u00e9e pour communiquer entre eux, deux ordinateurs doivent utiliser le m\u00eame protocole il en existe plein, par exemple HTTP pour s'\u00e9changer des pages web, FTP protocole de transfert de fichier, IMAP protocole pour s'\u00e9changer des emails... Telnet est un protocole simple cr\u00e9\u00e9 dans les ann\u00e9es 80 pour \u00e9changer des messages en clair d'une machine \u00e0 une autre, qui peuvent donc \u00eatre intercept\u00e9s et lus par n'importe qui SSH est un protocole qui permet de chiffrer les \u00e9changes cr\u00e9ation d'un tunnel s\u00e9curis\u00e9 avec SSH (tout ce fait automatiquement) : utilisation du chiffrement asym\u00e9trique pour s'\u00e9changer une cl\u00e9 de chiffrement sym\u00e9trique : le serveur envoie la cl\u00e9 publique en clair au client pour qu'il puisse chiffrer le client g\u00e9n\u00e8re une cl\u00e9 de chiffrement sym\u00e9trique qu'il chiffre gr\u00e2ce \u00e0 la cl\u00e9 publique qu'il a re\u00e7ue, et l'envoi au serveur, qui d\u00e9chiffre la cl\u00e9 re\u00e7ue gr\u00e2ce \u00e0 sa cl\u00e9 priv\u00e9e ensuite, utilisation du chiffrement sym\u00e9trique pour chiffrer tous les \u00e9changes car le chiffrement asym\u00e9trique est beaucoup plus lent que le chiffrement sym\u00e9trique. une fois le tunnel mis en place, le client peut se connecter au serveur avec son login et son mot de passe","title":"Les protocoles"},{"location":"tutoriel-linux/#transformer-sa-machine-en-serveur-et-sy-connecter-en-ssh","text":"transformer son pc en serveur : il faut installer le paquet openssh-server sudo apt-get install openssh-server normalement, le serveur SSH sera lanc\u00e9 \u00e0 chaque d\u00e9marrage sudo /etc/init.d/ssh start permet de le lancer \u00e0 tout moment sudo /etc/init.d/ssh stop permet de l'arr\u00eater \u00e0 tout moment au besoin, le fichier de configuration se trouve dans /etc/ssh/ssh_config . Il faut ensuite recharger SSH avec la commande sudo /etc/init.d/ssh reload pour que les changements soient pris en compte se connecter via SSH \u00e0 partir d'une machine Linux ssh login@ip en rempla\u00e7ant login par notre login et ip par l'adresse IP de notre ordinateur que l'on peut obtenir par exemple via le site www.whatismyip.com ou l'IP locale si on se connecte depuis un autre ordinateur sur le m\u00eame reseau local ssh login@localhost ou ssh login@127.0.0.1 permet de se connecter depuis son propre PC exit ou logout permet de se d\u00e9connecter le port 22 est le port utilis\u00e9 par d\u00e9faut par SSH. Si le serveur tourne sur un autre port, il faut le pr\u00e9ciser comme ceci : ssh login@ip -p 12345 si le serveur fonctionne sur le port 12345 le fingerprint du serveur, ou empreinte, est un num\u00e9ro unique qui permet d'identifier le serveur. Si quelqu'un essaie de se faire passer pour le serveur, le fingerprint changera et on sera averti se connecter via SSH \u00e0 partir d'une machine Windows renseigner l'adresse IP dans Host Name et le port (22 par d\u00e9faut) lors de la premi\u00e8re connexion, Putty nous demande une confirmation en nous donnant l'empreinte du serveur le serveur demande le login et le mot de passe. La connexion est maintenant \u00e9tablie","title":"Transformer sa machine en serveur et s'y connecter en SSH"},{"location":"tutoriel-linux/#lidentification-automatique-par-cle","text":"Les m\u00e9thodes les plus utilis\u00e9es pour s'authentifier aupr\u00e8s du serveur sont l'authentification par mot de passe l'authentification par cl\u00e9s publique et priv\u00e9e du client . cette m\u00e9thode \u00e9vite de renseigner son mot de passe \u00e0 chaque fois la cl\u00e9 publique ainsi g\u00e9n\u00e9r\u00e9e doit \u00eatre envoy\u00e9e sur le serveur, la cl\u00e9 priv\u00e9e reste sur le PC du client. La connexion se fait alors sans mot de passe et reste s\u00e9curis\u00e9e Authentification par cl\u00e9 depuis Linux g\u00e9n\u00e9rer une paire de cl\u00e9s publique/priv\u00e9e avec la commande ssh-keygen -t rsa sur le client rsa \u00e9tant un algorithme de chiffrement asym\u00e9trique, on peut aussi utiliser dsa qui est un autre algorithme de chiffrement les cl\u00e9s sont enregistr\u00e9es dans des fichiers. Laisser les valeurs par d\u00e9faut, ~/.ssh/id_rsa.pub pour la cl\u00e9 publique et ~/.ssh/id_rsa pour la cl\u00e9 priv\u00e9e. Le dossier .ssh/ contient aussi un fichier known_hosts qui est la liste des fingerprint que votre PC de client tient \u00e0 jour on nous demande une passphrase qui sert \u00e0 chiffrer la cl\u00e9 priv\u00e9e pour plus de s\u00e9curit\u00e9. On peut ne pas la renseigner si personne d'autre n'utilise le PC ou ne peut lire le fichier contenant la cl\u00e9 priv\u00e9e. envoyer la cl\u00e9 publique au serveur, pour qu'il puisse chiffrer les messages qu'il nous envoi ssh-copy-id -i id_rsa.pub login@ip avec le login et l'ip du serveur on envoie la cl\u00e9 publique id_rsa.pub sur le serveur dans son fichier authorized_keys on peut maintenant se connecter avec la commande ssh login@ip . Si on n'a pas mis de passphrase on est directement connect\u00e9, sinon il faut renseigner la passphrase pour \u00e9viter de renseigner la passphrase \u00e0 chaque fois, on peut utiliser l'agent SSH qui permet de la renseigner une seule fois. C'est un programme qui tourne en m\u00e9moire qui retient les cl\u00e9s priv\u00e9es pendant toute la dur\u00e9e de la session. Lancer le programme avec ssh-add sur le client, qui va lire notre cl\u00e9 priv\u00e9e et va nous demander notre passphrase pour la d\u00e9chiffrer. On peut maintenant se connecter plusieurs fois sur le m\u00eame serveur ou sur diff\u00e9rents serveurs sans retaper le passphrase Authentification par cl\u00e9 depuis Windows avec Putty m\u00eame principe : g\u00e9n\u00e9rer une paire de cl\u00e9s publique/priv\u00e9e sur le client et envoyer la cl\u00e9 publique au serveur g\u00e9n\u00e9rer la paire de cl\u00e9 avec Puttygen en laissant les valeurs par d\u00e9faut. on peut \u00e9ventuellement renseigner une passphrase enregistrer les cl\u00e9s dans des fichiers, par exemple cle.pub et cle.ppk se connecter au serveur avec son login/mdp et ajouter la cl\u00e9 publique dans les cl\u00e9 autoris\u00e9es \u00e0 la fin du fichier : cd .ssh pour aller dans le dossier .ssh de notre dossier personnel puis echo \"cle_publique\" >> authorized_keys se d\u00e9connecter pour configurer Putty pour se connecter avec la cl\u00e9. Dans Connection \u2192 SSH \u2192 Auth , indiquer le chemin du fichier contenant la cl\u00e9 priv\u00e9e, et dans Connection \u2192 Data renseigner le login dans Auto-login username se connecter en cliquant sur Open, le login est d\u00e9j\u00e0 renseign\u00e9, il faut renseigner la passphrase pour \u00e9viter de renseigner la passphrase \u00e0 chaque fois, on peut utiliser l'agent SSH Pageant , install\u00e9 avec Putty. Il est possible de le lancer automatiquement au d\u00e9marrage. Cliquer sur addkey , pr\u00e9ciser l'emplacement du fichier et renseigner la passphrase. Se connecter \u00e0 un serveur en s\u00e9lectionnant Saved Sessions","title":"L'identification automatique par cl\u00e9"},{"location":"tutoriel-linux/#le-transfert-de-fichiers","text":"wget permet de t\u00e9l\u00e9charger des fichiers en indiquant l'adresse HTTP ou FTP exemple wget https://thumbs.dreamstime.com/z/chat-mignon-2507126.jpg -c permet de reprendre un t\u00e9l\u00e9chargement arr\u00eat\u00e9 si le bout de fichier t\u00e9l\u00e9charg\u00e9 est toujours l\u00e0 : wget -c adresseHttp --background permet de laner un t\u00e9l\u00e9chargement en t\u00e2che de fond (tout comme la commande nohup ) scp pour secure copy , permet de copier des fichiers sur le r\u00e9seau d'un ordinateur \u00e0 un autre de mani\u00e8re s\u00e9curis\u00e9e rcp pour remote copy fait la m\u00eame chose sans cryptage syntaxe : scp origine destination , sous la forme login@ip:nom_fichier . Le login et l'IP sont facultatifs. S'ils sont absents, la commande consid\u00e8re que le fichier est sur notre ordinateur exemple : scp louis@12.345.67.890:image.png copie.png copie l'image sur l'ordinateur distant sur mon ordinateur sous le nom copie.png scp louis@12.345.67.890:image.png . fait la m\u00eame copie sans changer le nom du fichier, le . signifie r\u00e9pertoire courant si le serveur SSH sur lequel on se connecte n'est pas sur le port par d\u00e9faut (22), il faut indiquer le num\u00e9ro de port avec -P . Par exemple scp -P 12345 louis@12.345.67.890:image.png . avec un P majuscule contrairement \u00e0 la commande ssh qui utilise le p minuscule pour le port ftp et sftp permettent de transf\u00e9rer des fichiers Le FTP pour File Transfer Protocol est un protocole permettant d'\u00e9changer des fichiers sur le r\u00e9seau. Il est assez ancien (1985) et toujours utilis\u00e9 \u00e0 l'heure actuelle pour transf\u00e9rer des fichiers On l'utilise pour t\u00e9l\u00e9charger depuis un serveur FTP public, notamment lorsqu'on clique sur un lien de t\u00e9l\u00e9chargement via un navigateur. La connexion se fait alors en mode anonyme . On l'utilise aussi pour transf\u00e9rer des fichiers vers un serveur FTP priv\u00e9 (et aussi t\u00e9l\u00e9charger). La connexion se fait donc en mode authentifi\u00e9 FileZilla est un logiciel graphique qui permet de faire des transferts de fichiers via FTP ftp adresseServeurFtp permet de se connecter \u00e0 un serveur FTP exemple : ftp speedtest.tele2.net ou via un navigateur web ftp://speedtest.tele2.net/ sur les serveur public, le login est toujours anonymous et pour le mot de passe, tout fonctionne. On fait ensuite face \u00e0 un prompt ftp> les commandes sont pour la plupart les m\u00eames que celles qu'on connait : ls liste les fichiers du r\u00e9pertoire courant, pwd affiche le chemin du r\u00e9pertoire actuel, cd change de r\u00e9pertoire... pour utiliser les commandes sur son poste, il faut ajouter un point d'exclamation au d\u00e9but, par exemple !pwd pour savoir dans quel r\u00e9pertoire on est sur notre ordinateur put et get permettent d'envoyer un fichier vers le serveur et de t\u00e9l\u00e9charger un fichier depuis le serveur exemple : get fichier.zip pour t\u00e9l\u00e9charger fichier.zip delete permet de supprimer un fichier et non rm bye , exit , quit et Ctrl+D permet de fermer la session sftp est un FTP s\u00e9curis\u00e9 contrairement \u00e0 FTP ou les donn\u00e9es circulent en clair repose sur SSH pour s\u00e9curiser la connexion : sftp login@ip et on nous demande ensuite notre mot de passe (ou connexion via cl\u00e9 publique/priv\u00e9e) les commandes sont globalement les m\u00eames qu'avec ftp , sauf pour supprimer un fichier, il faut utiliser rm et non plus delete par d\u00e9faut, on utilise le port 22 comme pour SSH. Si le port est diff\u00e9rent, il faut le pr\u00e9ciser comme ceci : sftp -oPort=27401 login@ip rsync permet de synchroniser des fichiers pour une sauvegarde permet d'effectuer une synchronisation entre deux r\u00e9pertoires, que ce soit sur le m\u00eame PC ou entre deux ordinateurs reli\u00e9s en r\u00e9seau utilis\u00e9 pour effectuer des sauvegardes incr\u00e9mentielles : rsync compare et analyse les diff\u00e9rences entre deux dossiers puis copie uniquement les changements rsync -arv dossierASauvegarder/ backup/ fait une sauvegarde dans un autre dossier du m\u00eame ordinateur -a conserve les infos sur les fichiers (droits, date de modification...) -r pour sauvegarder tous les sous-dossiers -v mode verbeux pour afficher les d\u00e9tails par d\u00e9faut, rsync ne supprime pas les fichiers dans le r\u00e9pertoire de copie. Il faut ajouter l'option --delete . Exemple : rsync -arv --delete dossierASauvegarder/ backup/ sauvegarder les fichiers supprim\u00e9s --backup garde de c\u00f4t\u00e9 les fichiers supprim\u00e9s qui prennent un suffixe dans le r\u00e9pertoire de sauvegarde --backup-dir=/chemin d\u00e9place les fichiers supprim\u00e9s dans un dossier d\u00e9di\u00e9. Exemple : rsync -arv --delete --backup --backup-dir=/home/louis/backups_supprimes Images/ backups/ --exclude permet d'exclure un dossier de la sauvegarde rsync permet de sauvegarder sur un autre ordinateur, le plus couramment en utilisant SSH rsync -arv --delete --backup --backup-dir=/home/louis/fichiersSupprimes Images/ louis@ip:backup/ rsync -arv --delete --backup --backup-dir=/home/louis/fichiersSupprimes Images/ louis@ip:backup/ -e \"ssh -p 12345\" si le serveur SSH \u00e9coute sur un autre port que celui par d\u00e9faut","title":"Le transfert de fichiers"},{"location":"tutoriel-linux/#le-reseau","text":"adresse IP : chaque ordinateur reli\u00e9 \u00e0 Internet est identifi\u00e9 par une adresse IP format IPv4 : 86.172.120.28 format IPv6 : fe80::209:62fa:fb80:29f2 nom d'h\u00f4te, hostname en anglais, \u00e9quivalent \u00e0 l'IP mais plus simple \u00e0 retenir host donne le nom d'h\u00f4te \u00e0 partir de l'adresse IP et inversement. Exemple : host siteduzero.com et host 92.243.25.239 les serveurs DNS fournissent la liste des correspondances IP <-> noms d'h\u00f4te le fichier /etc/hosts permet de modifier la liste de correspondance personnalis\u00e9e de notre ordinateur, par exemple ajouter un nom d'h\u00f4te \u00e0 chaque PC pour s'y connecter sans retenir l'IP whois donne des renseignements sur un nom de domaine. Exemple : whois siteduzero.com ifconfig liste les interfaces r\u00e9seau et permet aussi de faire des r\u00e9glages r\u00e9seau exemple : eth0 pour une connexion par c\u00e2ble r\u00e9seau, lo pour la boucle locale, c'est-\u00e0-dire une connexion \u00e0 soi-m\u00eame, wlan0 pour une connexion sans-fil Wi-Fi ifconfig interface etat permet d'activer/d\u00e9sactiver une interface r\u00e9seau, par exemple ifconfig eth0 down ou ifconfig eth0 up netstat permet d'avoir des statistiques sur le r\u00e9seau netstat -i donnent des stats par interface r\u00e9seau netstat -uta liste toutes les connexions ouvertes -u pour les connexions UDP, -t pour les connexions TCP, -a pour afficher toutes les connexions quelque soit leur \u00e9tat permet de voir les ports sur lequels se sont les connexions. -n permet d'avoir les num\u00e9ros des ports plutot qu'une description en toutes lettres -l permet de filter uniquement les connexions \u00e0 l'\u00e9tat LISTEN netstat -s permet d'avoir des statistiques r\u00e9sum\u00e9es iptables est un pare-feu Linux. Il permet d'\u00e9tablir des r\u00e8gles \u00e0 quels ports on peut se connecter \u00e0 votre ordinateur \u00e0 quels ports vous avez le droit de vous connecter filtrer par IP iptables -L affiche les r\u00e8gles actuellement en place Chain INPUT correspond aux r\u00e8gles manipulant le trafic entrant, Chain FORWARD correspond aux r\u00e8gles manipulant la redirection du trafic, Chain OUTPUT correspond aux r\u00e8gles manipulant le trafic sortant policy ACCEPT signifie que par d\u00e9faut, tout le trafic est accept\u00e9, alors que policy DROP permet de resufer toutes les connexions que nous n'avons pas autoris\u00e9 iptables -F permet de r\u00e9initialiser toutes les r\u00e8gles iptables l'ajout et la suppression de r\u00e8gles : TODO","title":"Le r\u00e9seau"},{"location":"javascript/","text":"Tutoriel JavaScript Sommaire Les bases de JavaScript - Introduction - D\u00e9boguer votre code - Premiers pas - Les variables - Les conditions - Les boucles - Les fonctions - Les objets et les tableaux Vraiment bien comprendre JavaScript - Les variables - Les scopes - Les fonctions - Les objets D\u00e9veloppement moderne Javascript et ES6, ES7 - Nouveaut\u00e9s ES6 - Classes ES6 - Modules ES6 - Nouveaut\u00e9s ES7 - D\u00e9veloppement moderne Javascript - Npm - Webpack - Babel Objets et fonctions utiles Javascript - L'Objet Math - L'Objet Date - Expressions R\u00e9guli\u00e8res - SetTimeout et SetInterval - Fonctions de String - Fonctions de Array - L'Objet JSON Javascript d\u00e9barque dans le navigateur - Introduction - Le DOM - Les \u00e9v\u00e9nements - Les requ\u00eates HTTP Ajax Les biblioth\u00e8ques et frameworks JavaScript (TODO) - D\u00e9couverte des principaux frameworks JavaScript Modeler vos pages web (RECUP DES CHOSES PUIS SUPPRIMER) - Manipuler le code HTML (partie 1/2) - Manipuler le code HTML (partie 2/2) - Les \u00e9v\u00e9nements - Les formulaires Exercices exercice de cr\u00e9ation du jeu du snake (version avec webpack) d\u00e9p\u00f4t page Web exercice de cr\u00e9ation de l'application World Bucket List d\u00e9p\u00f4t page Web","title":"Sommaire"},{"location":"javascript/#tutoriel-javascript","text":"","title":"Tutoriel JavaScript"},{"location":"javascript/#sommaire","text":"Les bases de JavaScript - Introduction - D\u00e9boguer votre code - Premiers pas - Les variables - Les conditions - Les boucles - Les fonctions - Les objets et les tableaux Vraiment bien comprendre JavaScript - Les variables - Les scopes - Les fonctions - Les objets D\u00e9veloppement moderne Javascript et ES6, ES7 - Nouveaut\u00e9s ES6 - Classes ES6 - Modules ES6 - Nouveaut\u00e9s ES7 - D\u00e9veloppement moderne Javascript - Npm - Webpack - Babel Objets et fonctions utiles Javascript - L'Objet Math - L'Objet Date - Expressions R\u00e9guli\u00e8res - SetTimeout et SetInterval - Fonctions de String - Fonctions de Array - L'Objet JSON Javascript d\u00e9barque dans le navigateur - Introduction - Le DOM - Les \u00e9v\u00e9nements - Les requ\u00eates HTTP Ajax Les biblioth\u00e8ques et frameworks JavaScript (TODO) - D\u00e9couverte des principaux frameworks JavaScript Modeler vos pages web (RECUP DES CHOSES PUIS SUPPRIMER) - Manipuler le code HTML (partie 1/2) - Manipuler le code HTML (partie 2/2) - Les \u00e9v\u00e9nements - Les formulaires","title":"Sommaire"},{"location":"javascript/#exercices","text":"exercice de cr\u00e9ation du jeu du snake (version avec webpack) d\u00e9p\u00f4t page Web exercice de cr\u00e9ation de l'application World Bucket List d\u00e9p\u00f4t page Web","title":"Exercices"},{"location":"javascript/developpementModerneJavascript/","text":"D\u00e9veloppement Moderne JavaScript ---- Nouveaut\u00e9s ES6 Rappels Dans la partie pr\u00e9c\u00e9dente ont d\u00e9j\u00e0 \u00e9t\u00e9 vu des nouveaut\u00e9s ES6 : - les nouveaux mots cl\u00e9s let et var pour d\u00e9clarer une variable - les scopes de bloc - quand utiliser var , let et const - les fonctions fl\u00e9ch\u00e9s - le concept de classe Les param\u00e8tres par d\u00e9faut On peut maintenant utiliser des param\u00e8tres par d\u00e9faut dans les fonctions. Quand il y a une valeur par d\u00e9faut \u00e0 un param\u00e8tre, si on renseigne une valeur pour ce param\u00e8tre, la valeur sp\u00e9cifi\u00e9e sera prise en compte. Si aucune valeur n'est sp\u00e9cif\u00e9e, la valeur par d\u00e9faut est prise en compte. function nomComplet(prenom, nom){ console.log(prenom + \" \" + nom) } nomComplet(\"Brad\",\"Pitt\") // affiche Brad Pitt function nomComplet(prenom, nom){ console.log(prenom + \" \" + nom) } nomComplet(\"Brad\") // affiche Brad undefined function nomComplet(prenom, nom=\"Cruise\"){ console.log(prenom + \" \" + nom) } nomComplet(\"Brad\") // affiche Brad Cruise nomComplet(\"Brad\",\"Pitt\") // affiche Brad Pitt Les arguments sont \u00e9valu\u00e9s de gauche \u00e0 droite, il faut donc mettre les param\u00e8tres avec des valeurs par d\u00e9faut en dernier. function nomComplet(prenom=\"Brad\", nom){ console.log(prenom + \" \" + nom) } nomComplet(\"Pitt\") // affiche Pitt undefined function nomComplet(nom, prenom=\"Brad\"){ console.log(prenom + \" \" + nom) } nomComplet(\"Pitt\") // affiche Brad Pitt On peut utiliser des variables d\u00e9finies dans le scope global dans les param\u00e8tres par d\u00e9faut const nomActeur = \"Pitt\" function nomComplet(prenom, nom=nomActeur){ console.log(prenom + \" \" + nom) } nomComplet(\"Brad\") // affiche Brad Pitt Les param\u00e8tres Rest L'id\u00e9e est de sp\u00e9cifier des param\u00e8tres \u00e0 une fonction et que ces param\u00e8tres soient stock\u00e9es dans un tableau. Le nombre de ces param\u00e8tres est libre. Il faut pour cela utiliser ... Exemple sans les param\u00e8tres Rest o\u00f9 il faut donner un tableau const mesNombres = [1, 2, 3, 4] function faireSomme(nombres){ let somme = 0 for(let i =0 ; i < nombres.length ; i++){ somme += nombres[i] } return somme } console.log(faireSomme(mesNombres)) // affiche 10 Exemple avec les param\u00e8tres Rest o\u00f9 l'on peut fournir des valeurs libres qui sont stock\u00e9es dans un tableau gr\u00e2ce aux ... function faireSomme(...nombres){ console.log(nombres) // affiche [1, 2, 3, 4] let somme = 0 for(let i =0 ; i < nombres.length ; i++){ somme += nombres[i] } return somme } console.log(faireSomme(1, 2, 3, 4)) // affiche 10 L'op\u00e9ration Spread L'op\u00e9rateur Spread est l'inverse des param\u00e8tres Rest. Les param\u00e8tres Rest prennent des valeurs libres et les transforment en tableau. L'op\u00e9rateur Spread prend un tableau et le transforme en valeurs libres. Il s'utilise comme pour les param\u00e8tres Rest avec ... . Ce qui va les diff\u00e9rencier est quand on les utilise : si on lui donne des valeurs libres, il va les regrouper dans un tableau, et inversement. const mesNombres = [1, 2, 3] function faireSomme3Nombres(nb1, nb2, nb3){ console.log(nb1) // affiche [1, 2, 3] console.log(nb2) // affiche undefined console.log(nb3) // affiche undefined return nb1 + nb2 + nb3 } console.log(faireSomme3Nombres(mesNombres)) Cet exemple ne fonctionne pas, il faudrait fournir chaque \u00e9l\u00e9ment du tableau \u00e0 la fonction en faisant : console.log(faireSomme3Nombres(mesNombres[0], mesNombres[1], mesNombres[2])) On peut le faire plus simplement en utilisant l'op\u00e9rateur Spread : const mesNombres = [1, 2, 3] function faireSomme3Nombres(nb1, nb2, nb3){ console.log(nb1) // affiche 1 console.log(nb2) // affiche 2 console.log(nb3) // affiche 3 return nb1 + nb2 + nb3 } console.log(faireSomme3Nombres(...mesNombres)) // affiche 6 On peut aussi utiliser l'op\u00e9rateur Spread ailleurs que dans une fonction, par exemple pour regrouper deux tableaux en un. const fruits = [\"Pomme\", \"Melon\"] const legumes = [\"Tomate\", \"Concombre\"] // en faisant \u00e7a, on aura un tableau qui contient 2 tableaux de 2 \u00e9l\u00e9ments et pas un seul tableau de 4 \u00e9l\u00e9ments. const fruitsEtLegumes = [fruits, legumes] console.log(fruitsEtLegumes) // ici, on \u00e9clate nos 2 tableaux en valeurs libres pour recr\u00e9er un unique tableau const fruitsEtLegumesSpread = [...fruits, ...legumes] console.log(fruitsEtLegumesSpread) // affiche [\"Pomme\", \"Melon\", \"Tomate\", \"Concombre\"] // on peut aussi ajouter une valeur libre au milieu const fruitsEtLegumesSpread2 = [...fruits, \"Banane\", ...legumes] console.log(fruitsEtLegumesSpread2) // affiche [\"Pomme\", \"Melon\", \"Banane\", \"Tomate\", \"Concombre\"] L'op\u00e9rateur Spread est utile pour cr\u00e9er un nouveau tableau \u00e0 partir d'un ancien en changeant la r\u00e9f\u00e9rence de celui-ci. Sans l'op\u00e9rateur Spread, en faisant comme \u00e7a, ajouter un \u00e9l\u00e9ment \u00e0 un deux deux tableaux l'ajoute aux deux tableaux car fruits et fruits2 poitent vers le m\u00eame tableau. const fruits = [\"Pomme\", \"Melon\"] const fruits2 = fruits fruits2.push(\"Banane\") console.log(fruits) // affiche [\"Pomme\", \"Melon\", \"Banane\"] console.log(fruits2) // affiche [\"Pomme\", \"Melon\", \"Banane\"] Avec l'op\u00e9rateur Spread, un nouveau tableau fruits2 est cr\u00e9\u00e9 qui a une r\u00e9f\u00e9rence diff\u00e9rente que le premier tableau. Un changement sur l'un n'impactera pas l'autre. const fruits = [\"Pomme\", \"Melon\"] const fruits2 = [...fruits] fruits2.push(\"Banane\") console.log(fruits) // affiche [\"Pomme\", \"Melon\"] console.log(fruits2) // affiche [\"Pomme\", \"Melon\", \"Banane\"] for of Pour passer sur les \u00e9l\u00e9ments d'un tableau, on peut utiliser une boucle for classique. Avec ES6, une nouvelle syntaxe permet de parcourir les tableaux : le for of . Exemple en ES5 : const fruits = [\"Pomme\", \"Melon\", \"Fraise\"] for(let i = 0 ; i < fruits.length ; i++){ console.log(fruits[i]) } // affiche Pomme, puis Melon, puis Fraise Exemple avec for of qui fait exactement la m\u00eame chose. Il faut nommer une variable qui correspond \u00e0 la valeur courante du tableau que l'on parcourt. const fruits = [\"Pomme\", \"Melon\", \"Fraise\"] for(let fruit of fruits){ console.log(fruit) } // affiche Pomme, puis Melon, puis Fraise Les Template Literals ou Template String Les template literals permettent de simplifier la concat\u00e9nation. Il faut utiliser les back tilt (Alt Gr + 7) \u00e0 la place des guillemets dans le console.log() et mettre la variable entre accolades avec un dollar devant \u00e0 la place des plus. Exemple de concat\u00e9nation classique : const nom = \"Louis\" console.log(\"Je m'appelle \" + nom + \" !\") Exemple avec le template literal : const nom = \"Louis\" console.log(`Je m'appelle ${nom} !!!`) L'avantage est que l'on peut aussi cr\u00e9er des string multiligne : const maString = `Je suis sur la ligne 1 Je suis sur la ligne 3 Je suis sur la ligne 4` console.log(maString) Destructuring Arrays Si on veut cr\u00e9er des variables \u00e0 partir des valeurs d'un tableau, il faut pr\u00e9ciser pour chaque variable quel \u00e9l\u00e9ment du tableau on souhaite r\u00e9cup\u00e9rer. Avec l'ES6, il est possible de d\u00e9structurer le tableau pour simplifier la r\u00e9cup\u00e9ration des valeurs d'un tableau. Exemple en ES5 : const nombres = [1, 2, 3] const a = nombres[0] const b = nombres[1] console.log(a) // affiche 1 console.log(b) // affiche 2 Exemple en ES6 qui fait la m\u00eame chose : const nombres = [1, 2, 3] const [a,b] = nombres console.log(a) console.log(b) Il est possible de faire d'autres choses : const nombres = [1, 2, 3] const [a,b,c,d] = nombres console.log(a) console.log(b) console.log(c) console.log(d) // affiche undefined const nombres = [1, 2, 3] const [a,b,c,d=10] = nombres console.log(a) console.log(b) console.log(c) console.log(d) // affiche 10 const nombres = [1, 2, 3] const [a, ...b] = nombres console.log(a) // affiche 1 console.log(b) // affiche [2, 3] const nombres = [1, 2, 3] const [a, ,b] = nombres console.log(a) // affiche 1 console.log(b) // affiche 3 On peut aussi intervertir la valeur de 2 variables sans passer par une troisi\u00e8me variable (ne fonctionne pas sur mon poste) : let a = 1 let b = 2 [b,a] = [a,b] console.log(a) //affiche 2 console.log(b) // affiche 1 Destructuring Objects Il aussi possible de d\u00e9structurer un objet. La diff\u00e9rence avec le destructuring de tableau est qu'il est bas\u00e9 sur l'ordre des valeurs dans le tableau alors qu'avec les objets, il faut que les variables aient le m\u00eame nom que les propri\u00e9t\u00e9s de l'objet, sinon la variable ne sera pas renseign\u00e9e. const myObject ={ name:\"Louis\", age: 0 } const {name, age} = myObject console.log(name) // affiche Louis console.log(age) // affiche 0 const {name1, age1} = myObject console.log(name1) // affiche undefined console.log(age1) // affiche undefined Si on veut donner un nom diff\u00e9rent que le nom des propri\u00e9t\u00e9s de l'objet, il faut utiliser les alias : const myObject ={ name:\"Louis\", age: 0, present: function(){console.log(\"Hello\")} } const {name, age:age1, present:hello} = myObject console.log(name) // affiche Louis console.log(age1) // affiche 0 hello() // affiche Hello ---- Les classes (ES6) La notion de classe Comme vu dans la partie pr\u00e9c\u00e9dente, pour construire un objet, au lieu de faire une fonction constructeur et ajouter des m\u00e9thodes sur le prototype, on peut cr\u00e9er une classe. L'h\u00e9ritage (Inheritance) Si on veut d\u00e9finir une classe qui a les m\u00eames propri\u00e9t\u00e9s qu'une autre classe avec une propri\u00e9t\u00e9 en plus, on peut h\u00e9riter de cette classe plut\u00f4t que de la red\u00e9finir de z\u00e9ro, ce qui \u00e9vitera une duplication de code. - le mot cl\u00e9 extends permet de dire de quelle clase on h\u00e9rite - le mot cl\u00e9 super dans le constructeur permet d'ex\u00e9cuter le constructeur de la classe parent - il est aussi possible d'ex\u00e9cuter une m\u00e9thode parent dans une m\u00e9thode enfant avec super en faisant super.nomMethodeParent() - il est possible d'utiliser les m\u00e9thodes parent sans les d\u00e9finir dans la classe enfant class Person { constructor(name, age){ this.name = name this.age = age } present(){ console.log(`Hello my name is ${this.name}`) } } class Hero extends Person{ constructor(name, age, power){ super(name, age) // ex\u00e9cute le constructeur de la classe parent avec ses param\u00e8tres this.power = power } usePower(){ console.log(`I am using my power ${this.power}`) } presentHero(){ super.present() console.log(`My power is ${this.power}`) } } let louis = new Person(\"Louis\", 0) louis.present() // affiche : Hello my name is Louis //louis.usePower() // il y aura une erreur car on ne peut utiliser la m\u00e9thode de Hero avec un objet Person let superman = new Hero(\"Superman\", 30, \"fly\") superman.present() // affiche : Hello my name is Superman superman.usePower() // affiche : I am using my power fly superman.presentHero() // affiche : Hello my name is Superman, puis affiche : My power is fly Etendre les objets int\u00e9gr\u00e9s (Extend Built-In Objects) Depuis ES6, on peut aussi \u00e9tendre des objets int\u00e9gr\u00e9s \u00e0 JavaScript comme Array ou Function Par exemple, on va cr\u00e9er une classe qui h\u00e9rite d' Array et qui d\u00e9finit une m\u00e9thode qui renvoit un tableau avec tous les \u00e9l\u00e9ments en majuscules : class UpperCaseArray extends Array{ upperCase(){ let newArray = [] this.forEach(element => {newArray.push(element.toUpperCase())}) return newArray } } const myArray = new UpperCaseArray() myArray.push(\"louis\") myArray.push(\"k\u00e9vin\") myArray.push(\"Thibaut\") console.log(myArray.upperCase()) // affiche : [\"LOUIS\", \"K\u00c9VIN\", \"THIBAUT\"] M\u00e9thodes Statiques On peut aussi utiliser les classes pour regrouper les fonctions qui concernent un m\u00eame sujet. Par exemple, on peut faire une classe Mathematiques : class Mathematique{ addition(number1, number2){ return number1 + number2 } multiplication(number1, number2){ return number1 * number2 } } const myMath = new Mathematique() console.log(myMath.addition(2,3)) // affiche 5 console.log(myMath.multiplication(2,3)) // affiche 6 C'est inutile dans ce cas de cr\u00e9er une instance de classe pour utiliser les m\u00e9thodes, car rien n'est li\u00e9 \u00e0 une m\u00e9thode sp\u00e9cifique. Pour faire cela, on va d\u00e9clarer nos m\u00e9thodes static et on pourra utiliser les m\u00e9thodes sans instancier la classe. class Mathematique{ static addition(number1, number2){ return number1 + number2 } static multiplication(number1, number2){ return number1 * number2 } } console.log(Mathematique.addition(2,3)) console.log(Mathematique.multiplication(2,3)) Get et Set De base, rien n'emp\u00eache d'acc\u00e9der et de modifier les propri\u00e9t\u00e9s de nos objets : class Person{ constructor(name){ this.name = name } } let louis = new Person(\"Louis\") console.log(louis.name) // affiche : Louis louis.name = \"Loulou\" // modifie le nom de l'objet louis console.log(louis.name) // affiche : Loulou Pour \u00e9viter cela, on peut utiliser get et set pour contr\u00f4ler l'acc\u00e8s aux propri\u00e9t\u00e9s de nos objets, choisir ce qu'on renvoit et dans quelle condition la propri\u00e9t\u00e9 peut \u00eatre modifi\u00e9e : class Person{ constructor(name){ this._name = name // par convention, on met un _ devant les propri\u00e9t\u00e9s que l'on veut rendre \"semi priv\u00e9\" } get name(){ return `b\u00e9b\u00e9 ${this._name}` } set name(value){ if(value.length > 2){ this._name = value } } } let louis = new Person(\"Louis\") console.log(louis.name) // affiche : b\u00e9b\u00e9 Louis louis.name = \"Lo\" console.log(louis.name) // affiche : b\u00e9b\u00e9 Louis, la modification n'a pas eu lieu car la taille du nom soumis n'est pas sup\u00e9rieur \u00e0 2 louis.name = \"Loulou\" console.log(louis.name) // affiche : b\u00e9b\u00e9 Loulou // On peut toujours acc\u00e9der \u00e0 la propri\u00e9t\u00e9 _name et la modifier directement console.log(louis._name) // affiche : Loulou louis._name = \"az\" console.log(louis._name) // affiche : az console.log(louis.name) // affiche : b\u00e9b\u00e9 az ---- Les modules (ES6) ## Modules Sur des gros projets, il faut organiser le code JavaScript en plusieurs fichiers. Pour charger les diff\u00e9rents fichiers JavaScript, on peut les charger chacun un tag <script src=\"script.js\"></script> dans la page html. ``js // script1.js const myLog = message => console.log( My Log : ${message}`) // script2.js myLog(\"Hello !\") // index.html <!DOCTYPE html> Modules JavaScript // affiche dans la console : My Log : Hello ! Cette solution n'est pas id\u00e9ale pour plusieurs raisons : - \u00e0 chaque tag `script`, une nouvelle requ\u00eate est faite au serveur pour r\u00e9cup\u00e9rer le fichier - il faut faire attention \u00e0 l'ordre des fichiers en mettant d'abord les fichiers avec du code qui sert dans les fichiers suivant, sinon \u00e7a ne fonctionnera pas - tous les fichiers partagent le m\u00eame scope global, on s'expose donc aux accidents de variables si par exemple des variables ont le m\u00eame nom dans diff\u00e9rents fichiers ce qui fait que des variables vont s'\u00e9craser Pour r\u00e9pondre \u00e0 ces probl\u00e8mes, ES6 a amen\u00e9 **les modules**. Chaque module peut exporter certaines de ces fonctionnalit\u00e9s et importer des fonctionnalit\u00e9s d'autres modules. La probl\u00e8me est que la plupart des navigateurs ne supportent pas encore les modules ES6. Avec Chrome, il faut au moins la version 60 et aller dans l'url `chrome://flags/` et activer `Experimental Web Platform features`. Avec Firefox en version 61 (et peut-\u00eatre les versions plus anciennes ?), les modules sont pris en charge nativement. Dans le script 1, il faut exporter la fonction avec le mot cl\u00e9 `export` et dans le script 2, il faut l'importer. Dans le fichier html, on laisse qu'un seul script JavaScript, notre fichier point d'entr\u00e9e script2.js et on ajoute le type module dans la balise script. Le r\u00e9sultat sera le m\u00eame. ```js // script1.js export const myLog = message => console.log(`** My Log ** : ${message}`) // script2.js import {myLog} from \"./script1.js\" myLog(\"Hello !\") // index.html <!DOCTYPE html> <html> <head> <title>Modules JavaScript</title> <meta charset=\"UTF-8\"> </head> <body> <script type=\"module\" src=\"script2.js\"></script> </body> </html> ## Import et Export Avec les modules, l'import et l'export se fait par r\u00e9f\u00e9rence, c'est-\u00e0-dire qu'on ne cr\u00e9e pas une nouvelle variable mais on importe la variable de l'autre module. Pour exporter plusieurs choses d'un m\u00eame module, on fait deux exports et on fait les deux imports sur une seule ligne ``js // script1.js export const myLog = message => console.log( My Log : ${message}`) export let myVariable = \"Coucou !\" // script2.js import {myLog, myVariable} from \"./script1.js\" myLog(myVariable) On peut aussi faire l'export \u00e0 la fin du fichier au lieu de le faire au moment de la d\u00e9claration. ```js // script1.js const myLog = message => console.log(`** My Log ** : ${message}`) let myVariable = \"Coucou !\" export {myLog, myVariable} Une variante de l'export et l' export default . Il ne peut y en avoir qu'un par fichier. Lorsqu'on l'importe, on ne met pas les accolades et on lui donne le nom qu'on veut car lorsqu'on ne met pas les accolades, c'est forc\u00e9ment lque \u00e7a correspond \u00e0 l'export default. // script1.js const myLog = message => console.log(`** My Log ** : ${message}`) let myVariable = \"Coucou !\" let myVariable2 = \"Important\" export {myLog, myVariable} export default myVariable2 // script2.js import {myLog, myVariable} from \"./script1.js\" import myVariable2 from \"./script1.js\" myLog(myVariable) myLog(myVariable2) Exemple en renommant la variable de l'export default dans l'import : // script2.js import toto, {myLog, myVariable} from \"./script1.js\" myLog(myVariable) myLog(toto) // correspond \u00e0 l'export default de myVariable2 On peut aussi utiliser des alias pour renommer les export classiques : // script2.js import toto, {myLog as myLogImported, myVariable} from \"./script1.js\" myLogImported(myVariable) myLogImported(toto) Lorsqu'il y a plusieurs \u00e9l\u00e9ments \u00e0 importer, on peut utiliser l'\u00e9toile pour tout importer. // script2.js import * as external from \"./script1.js\" external.myLog(external.myVariable) # Les nouveaut\u00e9s ES7 ## Array.prototype.includes Lorsqu'on veut v\u00e9rifier la pr\u00e9sence d'un \u00e9l\u00e9ment dans un tableau, il faut utiliser la m\u00e9thode indexOf() qui renvoie la position de l'\u00e9l\u00e9ment dans le tableau, ou -1 si l'\u00e9l\u00e9ment est absent. const fruits = [\"pomme\", \"banane\", \"orange\"] console.log(fruits.indexOf(\"banane\")) // affiche 1 console.log(fruits.indexOf(\"melon\")) // affiche -1 const monFruit = \"banane\" if(fruits.indexOf(monFruit)>-1){ console.log(`${monFruit} est dans le tableau`) } else { console.log(`${monFruit} n'est pas dans le tableau`) } En ES7, on peut utiliser la m\u00e9thode includes() qui renvoie true ou false si l'\u00e9l\u00e9ment est pr\u00e9sent ou non dans le tableau. const fruits = [\"pomme\", \"banane\", \"orange\"] console.log(fruits.includes(\"banane\")) // affiche true console.log(fruits.includes(\"melon\")) // affiche false const monFruit = \"banane\" if(fruits.includes(monFruit)){ console.log(`${monFruit} est dans le tableau`) } else { console.log(`${monFruit} n'est pas dans le tableau`) } L'op\u00e9rateur d'exponentiation (op\u00e9rateur de puissance) l'ES7 am\u00e8ne un nouvel op\u00e9rateur qui est la puissance qui se note avec deux \u00e9toiles sous la forme x ** y pour x puissance y. Avant l'ES7, il fallait utiliser l'objet Math. const calcul = Math.pow(2,3) // 2*2*2 console.log(calcul) // affiche : 8 const newCalcul = 2 ** 3 console.log(newCalcul) // affiche : 8 On peut aussi utiliser ce nouvel op\u00e9rateur comme les op\u00e9rateurs classiques. let myVar = 2 myVar **= 3 // \u00e9quivaut \u00e0 myVar = myVar ** 3 console.log(myVar) // affiche 8 ---- D\u00e9veloppement moderne JavaScript Tous les navigateurs ne supportent pas encore ces nouveaut\u00e9s. Il existe des outils qui permettent de coder en ES6 et ES7 et que le code soit support\u00e9 par tous les navigateurs. ---- Npm Les bases de Npm Npm pour Node Package Manager va nous permettre de g\u00e9rer nos paquets JavaScript. Pour l'utiliser, il faut t\u00e9l\u00e9charger Node.js Pour v\u00e9rifier qu'il est bien install\u00e9 et v\u00e9rifier la version, tpaer la commande node -v puis npm -v . Jusqu'\u00e0 pr\u00e9sent, pour utiliser une biblioth\u00e8que externe comme JQuery, il faut t\u00e9l\u00e9charger la biblioth\u00e8que et l'ajouter dans le fichier HTML. Avec Npm, il est possible de t\u00e9l\u00e9charger la biblioh\u00e8que tr\u00e8s facilement, en faisant npm install jquery . Un dossier node_modules est cr\u00e9\u00e9 avec un sous-dossier jquery . Il faut ensuite l'ajouter au fichier HTML en pointant dans le sous-dossier dist (pour distribution) et on peut utiliser jquery dans le projet. <!DOCTYPE html> <html> <head> <title>NPM</title> <meta charset=\"UTF-8\"> </head> <body> <script src=\"./node_modules/jquery/dist/jquery.js\"></script> <script type=\"module\" src=\"script.js\"></script> </body> </html> // script.js import {myLog} from \"./external.js\" myLog(\"Hello !\") jQuery(document).ready(function(){ console.log(\"jQuery est pr\u00eat !\"); }); // external.js export const myLog = message => console.log(`** My Log ** : ${message}`) On peut d\u00e9sinstaller la biblioth\u00e8que avec la commande npm uninstall jquery , ce qui supprime le dossier jquery du dossier node_modules . On peut mettre \u00e0 jour la version de jquery avec la commande npm update jquery . Le fichier package.json G\u00e9n\u00e9ralement on a beaucoup de d\u00e9pendances, ce qui deviendrait lourd \u00e0 g\u00e9rer avec les commandes vues ici. Avec le fichier package.json , on va pouvoir noter toutes les d\u00e9pendances ainsi que leur version. Cela permettra aussi de reproduire le projet sur un autre poste sans y inclure toutes les d\u00e9pendances mais uniquement ce fichier. En lan\u00e7ant la commande npm install , toutes les d\u00e9pendances inscrites dans le fichier package.json seront install\u00e9es dans la version sp\u00e9cifi\u00e9. Ce fichier est un fichier de configuration, il sert \u00e9galement \u00e0 d'autres choses. Pour le cr\u00e9er, il faut ex\u00e9cuter la commande npm init . Lorsqu'on installe ou d\u00e9sinstalle une d\u00e9pendance, elle n'est pas renseign\u00e9e dans le fichier package.json . Pour que ce soit le cas il faut ajouter --save , par exemple npm install jquery --save et jquery sera inscrit dans les d\u00e9pendances avec son num\u00e9ro de version. Il y a deux types de d\u00e9pendances : - les d\u00e9pendances classiques dont notre code a besoin, comme par exemple jquery . Elles sont rensiegn\u00e9es donc dependencies - les d\u00e9pendances de d\u00e9veloppement qui correspond aux outils de d\u00e9veloppement, par exemple webpack que l'on verra au prochain chapitre. Elles sont rensiegn\u00e9es donc devDependencies . Pour cela, il faut utiliser la commande --save-dev , par exemple npm install --save-dev webpack webpack-cli En installant webpack , il y a maintenant plein de d\u00e9pendances dans node_modules car webpack a besoin d'autres d\u00e9pendances qui ont \u00e9t\u00e9 install\u00e9 \u00e9galement. ---- Webpack Qu'est-ce que Webpack Il est principalement utilis\u00e9 comme module bundler , c'est-\u00e0-dire qu'il va prendre tous nos fichiers pour faire un seul gros fichier. Ce fichier pourra \u00eatre inclus dans le fichier HTML, ce qui permet d'utiliser les modules ES6 directement avec webpack tout en \u00e9tant compatible avec les navigateurs anciens. Il faut cr\u00e9er un fichier de configuration webpack.config.js module.exports = { entry: \"./script.js\", // dit \u00e0 webpack le point d'entr\u00e9e de notre projet output: { filename: \"bundle.js\" // dit \u00e0 webpack le nom du fichier produit } } Il faut ensuite indiquer dans le fichier HTML que le fichier de script \u00e0 utiliser est celui cr\u00e9\u00e9 par webpack. On peut aussi enlever la d\u00e9pendance jquery du fichier HTML et l'importer dans le script o\u00f9 on l'utilise, webpack l'embarquera dans le fichier bundle.js qu'il va g\u00e9n\u00e9rer dans un dossier dist (pour distribution). <!DOCTYPE html> <html> <head> <title>NPM</title> <meta charset=\"UTF-8\"> </head> <body> <script src=\"./dist/bundle.js\"></script> </body> </html> // script.js import {myLog} from \"./external.js\" import jQuery from \"jquery\" myLog(\"Hello !\") jQuery(document).ready(function(){ console.log(\"jQuery est pr\u00eat !\"); }); // external.js export const myLog = message => console.log(`** My Log ** : ${message}`) Ex\u00e9cuter Webpack On va lancer l'ex\u00e9cutable de webpack. Dans le dossier .bin de node_modules, il y a tous les ex\u00e9cutables. Pour lancer webpack, on va ex\u00e9cuter la commande node_modules/.bin/webpack . Le fichier *bundle.js a \u00e9t\u00e9 cr\u00e9\u00e9 en enpaquetant nos fichiers javscript. On peut lancer notre page HTML et \u00e7a fonctionne comme avant san utiliser les modules. Pour \u00e9viter de lancer la commande node_modules/.bin/webpack \u00e0 chaque fois, on va cr\u00e9er une t\u00e2che dans le fichier package.json que l'on pourra ex\u00e9cuter \u00e0 la place de cette commande. Pour exc\u00e9cuter la t\u00e2che, on lancera la commande npm run build // package.json \"scripts\": { \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\", \"build\": \"webpack\" // ajout de la t\u00e2che build qui cr\u00e9e notre fichier bundle.js } ``` On peut faire mieux en disant \u00e0 webpack d'observer notre code et de recompiler le code pour recr\u00e9er *bundle.js* quand il observe des modifications sans relancer la commande de build. Pour cela, on va ajouter une propri\u00e9t\u00e9 dans le fichier de configuration de webpack. Lorsqu'on fait une modification et que l'on sauvegarde, il n'y a plus qu'\u00e0 rafra\u00eechir la page HTML pour voir le changement. ```js // webpack.config.js module.exports = { watch: true, // ajout de cette prori\u00e9t\u00e9 pour que webpack observe notre code et recompile lorsqu'il y a des changements entry: \"./script.js\", output: { filename: \"bundle.js\" } } Serveur local Webpack Pour \u00e9viter d'avoir \u00e0 recharger la page HTML \u00e0 chaque modification du code JavaScript, on va mettre en place un serveur de d\u00e9veloppement local. On va installer un nouveau paquet avec la commande npm install --save-dev webpack-dev-server . On va ex\u00e9cuter la commande node_modules/.bin/webpack-dev-server qui compile notre code et le met \u00e0 disposition \u00e0 l'adresse localhost:8080 . En faisant des modifications dans le code et que l'on enregistre, la page est relanc\u00e9 automatiquement. On peut cr\u00e9er une t\u00e2che dans les scripts dans le fichier package.json : \"start\": \"webpack-dev-server --open\" . --open permet de lancer la page HTML dans le navigateur avec la commannde npm run start . Architecture des fichiers Pour le moment, tous les fichiers sont mis \u00e0 la racine du projet. On va r\u00e9organiser tout \u00e7a - un dossier src qui contient le code de d\u00e9veloppement, les fichiers sources JavaScript - un dossier dist qui contient le code de distribution que voit le public, le fichier index.html et le fichier bundle.js Il faut mettre \u00e0 jour le fichier de configuration de webpack pour que \u00e7a fonctionne bien // webpack.config.js const path = require(\"path\") // permet de cr\u00e9er des chemins absolus \u00e0 partir des chemins relatifs car webpack attend \u00e0 certains endroits des chemins absolus module.exports = { watch: true, entry: \"./src/script.js\", // dit \u00e0 webpack le point d'entr\u00e9e de notre projet output: { path: path.resolve(__dirname, \"dist\"), filename: \"bundle.js\" // dit \u00e0 webpack le nom du fichier produit }, devServer: { contentBase: path.resolve(__dirname, \"dist\"), // dit au serveur de nous servir ce qu'il y a dans le dossier dist au lieu de la racine du projet open: true // lance le navigateur automatiquement au lancement du serveur, ce qui \u00e9vite de mettre --open dans la t\u00e2che } } // index.html <!DOCTYPE html> <html> <head> <title>NPM</title> <meta charset=\"UTF-8\"> </head> <body> <script src=\"bundle.js\"></script> </body> </html> ---- Babel Qu'est-ce que Babel Babel est un transpileur qui va traduire notre code ES6-ES7 en ES5 \u00e9quivalent, ce qui nous permettra d'\u00eatre compatible avec les anciennes versions des navigateurs. Babel loader C'est une fonctionnalit\u00e9 de webpack qui va permettre de transpiler le code en ES5 au moment de la cr\u00e9ation du fichier bundle.js . Il faut commencer par installer les d\u00e9pendances n\u00e9cessaires npm install --save-dev babel-loader babel-core babel-preset-env . Il faut ensuite mettre \u00e0 jour le fichier de configuration de webpack en ajoutant une partie. // webpack.config.js module: { rules: [ { // on teste si c'est un fichier JS test: /\\.js$/, // on ne traite pas les fichiers dans node_modules exclude: /node_modules/, use: { loader: \"babel-loader\", options: { presets: [\"env\"] } } } ] } Babel polyfill ES6-ES7 n'apportent pas que de la nouvelle syntaxe mais aussi de nouveaux \u00e9l\u00e9ments. Quand on utilise un nouvel \u00e9l\u00e9ment ES6, on ne peut pas le traduire en ES5, ce qui peut poser des probl\u00e8mes de compatibilit\u00e9 avec les anciens navigateurs. Dans ce cas, on peut utiliser un polyfill , qui est un bout de code qui contient ces nouveaux \u00e9l\u00e9ments, ce qui permet d'ajouter les \u00e9l\u00e9ments manquants au navigateur. On va utiliser Babel polyfill. Il faut commencer par l'installer avec la commande npm install --save babel-polyfill . Il faut ensuite mettre \u00e0 jour le fichier de configuration de webpack en ajoutant babel-polyfill dans les fichiers en entr\u00e9e. Il faut aussi importer babel-polyfill dans le fichier d'entr\u00e9e JavaScript. // webpack.config.js module.exports = { watch: true, entry: [\"babel-polyfill\", \"./src/script.js\"], // dit \u00e0 webpack le point d'entr\u00e9e de notre projet output: { path: path.resolve(__dirname, \"dist\"), filename: \"bundle.js\" // dit \u00e0 webpack le nom du fichier produit } // script.js import \"babel-polyfill\" import {myLog} from \"./external.js\" myLog(\"Hello !\")","title":"D\u00e9veloppement moderne Javascript et ES6, ES7"},{"location":"javascript/developpementModerneJavascript/#developpement-moderne-javascript","text":"","title":"D\u00e9veloppement Moderne JavaScript"},{"location":"javascript/developpementModerneJavascript/#-","text":"","title":"----"},{"location":"javascript/developpementModerneJavascript/#nouveautes-es6","text":"","title":"Nouveaut\u00e9s ES6"},{"location":"javascript/developpementModerneJavascript/#rappels","text":"Dans la partie pr\u00e9c\u00e9dente ont d\u00e9j\u00e0 \u00e9t\u00e9 vu des nouveaut\u00e9s ES6 : - les nouveaux mots cl\u00e9s let et var pour d\u00e9clarer une variable - les scopes de bloc - quand utiliser var , let et const - les fonctions fl\u00e9ch\u00e9s - le concept de classe","title":"Rappels"},{"location":"javascript/developpementModerneJavascript/#les-parametres-par-defaut","text":"On peut maintenant utiliser des param\u00e8tres par d\u00e9faut dans les fonctions. Quand il y a une valeur par d\u00e9faut \u00e0 un param\u00e8tre, si on renseigne une valeur pour ce param\u00e8tre, la valeur sp\u00e9cifi\u00e9e sera prise en compte. Si aucune valeur n'est sp\u00e9cif\u00e9e, la valeur par d\u00e9faut est prise en compte. function nomComplet(prenom, nom){ console.log(prenom + \" \" + nom) } nomComplet(\"Brad\",\"Pitt\") // affiche Brad Pitt function nomComplet(prenom, nom){ console.log(prenom + \" \" + nom) } nomComplet(\"Brad\") // affiche Brad undefined function nomComplet(prenom, nom=\"Cruise\"){ console.log(prenom + \" \" + nom) } nomComplet(\"Brad\") // affiche Brad Cruise nomComplet(\"Brad\",\"Pitt\") // affiche Brad Pitt Les arguments sont \u00e9valu\u00e9s de gauche \u00e0 droite, il faut donc mettre les param\u00e8tres avec des valeurs par d\u00e9faut en dernier. function nomComplet(prenom=\"Brad\", nom){ console.log(prenom + \" \" + nom) } nomComplet(\"Pitt\") // affiche Pitt undefined function nomComplet(nom, prenom=\"Brad\"){ console.log(prenom + \" \" + nom) } nomComplet(\"Pitt\") // affiche Brad Pitt On peut utiliser des variables d\u00e9finies dans le scope global dans les param\u00e8tres par d\u00e9faut const nomActeur = \"Pitt\" function nomComplet(prenom, nom=nomActeur){ console.log(prenom + \" \" + nom) } nomComplet(\"Brad\") // affiche Brad Pitt","title":"Les param\u00e8tres par d\u00e9faut"},{"location":"javascript/developpementModerneJavascript/#les-parametres-rest","text":"L'id\u00e9e est de sp\u00e9cifier des param\u00e8tres \u00e0 une fonction et que ces param\u00e8tres soient stock\u00e9es dans un tableau. Le nombre de ces param\u00e8tres est libre. Il faut pour cela utiliser ... Exemple sans les param\u00e8tres Rest o\u00f9 il faut donner un tableau const mesNombres = [1, 2, 3, 4] function faireSomme(nombres){ let somme = 0 for(let i =0 ; i < nombres.length ; i++){ somme += nombres[i] } return somme } console.log(faireSomme(mesNombres)) // affiche 10 Exemple avec les param\u00e8tres Rest o\u00f9 l'on peut fournir des valeurs libres qui sont stock\u00e9es dans un tableau gr\u00e2ce aux ... function faireSomme(...nombres){ console.log(nombres) // affiche [1, 2, 3, 4] let somme = 0 for(let i =0 ; i < nombres.length ; i++){ somme += nombres[i] } return somme } console.log(faireSomme(1, 2, 3, 4)) // affiche 10","title":"Les param\u00e8tres Rest"},{"location":"javascript/developpementModerneJavascript/#loperation-spread","text":"L'op\u00e9rateur Spread est l'inverse des param\u00e8tres Rest. Les param\u00e8tres Rest prennent des valeurs libres et les transforment en tableau. L'op\u00e9rateur Spread prend un tableau et le transforme en valeurs libres. Il s'utilise comme pour les param\u00e8tres Rest avec ... . Ce qui va les diff\u00e9rencier est quand on les utilise : si on lui donne des valeurs libres, il va les regrouper dans un tableau, et inversement. const mesNombres = [1, 2, 3] function faireSomme3Nombres(nb1, nb2, nb3){ console.log(nb1) // affiche [1, 2, 3] console.log(nb2) // affiche undefined console.log(nb3) // affiche undefined return nb1 + nb2 + nb3 } console.log(faireSomme3Nombres(mesNombres)) Cet exemple ne fonctionne pas, il faudrait fournir chaque \u00e9l\u00e9ment du tableau \u00e0 la fonction en faisant : console.log(faireSomme3Nombres(mesNombres[0], mesNombres[1], mesNombres[2])) On peut le faire plus simplement en utilisant l'op\u00e9rateur Spread : const mesNombres = [1, 2, 3] function faireSomme3Nombres(nb1, nb2, nb3){ console.log(nb1) // affiche 1 console.log(nb2) // affiche 2 console.log(nb3) // affiche 3 return nb1 + nb2 + nb3 } console.log(faireSomme3Nombres(...mesNombres)) // affiche 6 On peut aussi utiliser l'op\u00e9rateur Spread ailleurs que dans une fonction, par exemple pour regrouper deux tableaux en un. const fruits = [\"Pomme\", \"Melon\"] const legumes = [\"Tomate\", \"Concombre\"] // en faisant \u00e7a, on aura un tableau qui contient 2 tableaux de 2 \u00e9l\u00e9ments et pas un seul tableau de 4 \u00e9l\u00e9ments. const fruitsEtLegumes = [fruits, legumes] console.log(fruitsEtLegumes) // ici, on \u00e9clate nos 2 tableaux en valeurs libres pour recr\u00e9er un unique tableau const fruitsEtLegumesSpread = [...fruits, ...legumes] console.log(fruitsEtLegumesSpread) // affiche [\"Pomme\", \"Melon\", \"Tomate\", \"Concombre\"] // on peut aussi ajouter une valeur libre au milieu const fruitsEtLegumesSpread2 = [...fruits, \"Banane\", ...legumes] console.log(fruitsEtLegumesSpread2) // affiche [\"Pomme\", \"Melon\", \"Banane\", \"Tomate\", \"Concombre\"] L'op\u00e9rateur Spread est utile pour cr\u00e9er un nouveau tableau \u00e0 partir d'un ancien en changeant la r\u00e9f\u00e9rence de celui-ci. Sans l'op\u00e9rateur Spread, en faisant comme \u00e7a, ajouter un \u00e9l\u00e9ment \u00e0 un deux deux tableaux l'ajoute aux deux tableaux car fruits et fruits2 poitent vers le m\u00eame tableau. const fruits = [\"Pomme\", \"Melon\"] const fruits2 = fruits fruits2.push(\"Banane\") console.log(fruits) // affiche [\"Pomme\", \"Melon\", \"Banane\"] console.log(fruits2) // affiche [\"Pomme\", \"Melon\", \"Banane\"] Avec l'op\u00e9rateur Spread, un nouveau tableau fruits2 est cr\u00e9\u00e9 qui a une r\u00e9f\u00e9rence diff\u00e9rente que le premier tableau. Un changement sur l'un n'impactera pas l'autre. const fruits = [\"Pomme\", \"Melon\"] const fruits2 = [...fruits] fruits2.push(\"Banane\") console.log(fruits) // affiche [\"Pomme\", \"Melon\"] console.log(fruits2) // affiche [\"Pomme\", \"Melon\", \"Banane\"]","title":"L'op\u00e9ration Spread"},{"location":"javascript/developpementModerneJavascript/#for-of","text":"Pour passer sur les \u00e9l\u00e9ments d'un tableau, on peut utiliser une boucle for classique. Avec ES6, une nouvelle syntaxe permet de parcourir les tableaux : le for of . Exemple en ES5 : const fruits = [\"Pomme\", \"Melon\", \"Fraise\"] for(let i = 0 ; i < fruits.length ; i++){ console.log(fruits[i]) } // affiche Pomme, puis Melon, puis Fraise Exemple avec for of qui fait exactement la m\u00eame chose. Il faut nommer une variable qui correspond \u00e0 la valeur courante du tableau que l'on parcourt. const fruits = [\"Pomme\", \"Melon\", \"Fraise\"] for(let fruit of fruits){ console.log(fruit) } // affiche Pomme, puis Melon, puis Fraise","title":"for of"},{"location":"javascript/developpementModerneJavascript/#les-template-literals-ou-template-string","text":"Les template literals permettent de simplifier la concat\u00e9nation. Il faut utiliser les back tilt (Alt Gr + 7) \u00e0 la place des guillemets dans le console.log() et mettre la variable entre accolades avec un dollar devant \u00e0 la place des plus. Exemple de concat\u00e9nation classique : const nom = \"Louis\" console.log(\"Je m'appelle \" + nom + \" !\") Exemple avec le template literal : const nom = \"Louis\" console.log(`Je m'appelle ${nom} !!!`) L'avantage est que l'on peut aussi cr\u00e9er des string multiligne : const maString = `Je suis sur la ligne 1 Je suis sur la ligne 3 Je suis sur la ligne 4` console.log(maString)","title":"Les Template Literals ou Template String"},{"location":"javascript/developpementModerneJavascript/#destructuring-arrays","text":"Si on veut cr\u00e9er des variables \u00e0 partir des valeurs d'un tableau, il faut pr\u00e9ciser pour chaque variable quel \u00e9l\u00e9ment du tableau on souhaite r\u00e9cup\u00e9rer. Avec l'ES6, il est possible de d\u00e9structurer le tableau pour simplifier la r\u00e9cup\u00e9ration des valeurs d'un tableau. Exemple en ES5 : const nombres = [1, 2, 3] const a = nombres[0] const b = nombres[1] console.log(a) // affiche 1 console.log(b) // affiche 2 Exemple en ES6 qui fait la m\u00eame chose : const nombres = [1, 2, 3] const [a,b] = nombres console.log(a) console.log(b) Il est possible de faire d'autres choses : const nombres = [1, 2, 3] const [a,b,c,d] = nombres console.log(a) console.log(b) console.log(c) console.log(d) // affiche undefined const nombres = [1, 2, 3] const [a,b,c,d=10] = nombres console.log(a) console.log(b) console.log(c) console.log(d) // affiche 10 const nombres = [1, 2, 3] const [a, ...b] = nombres console.log(a) // affiche 1 console.log(b) // affiche [2, 3] const nombres = [1, 2, 3] const [a, ,b] = nombres console.log(a) // affiche 1 console.log(b) // affiche 3 On peut aussi intervertir la valeur de 2 variables sans passer par une troisi\u00e8me variable (ne fonctionne pas sur mon poste) : let a = 1 let b = 2 [b,a] = [a,b] console.log(a) //affiche 2 console.log(b) // affiche 1","title":"Destructuring Arrays"},{"location":"javascript/developpementModerneJavascript/#destructuring-objects","text":"Il aussi possible de d\u00e9structurer un objet. La diff\u00e9rence avec le destructuring de tableau est qu'il est bas\u00e9 sur l'ordre des valeurs dans le tableau alors qu'avec les objets, il faut que les variables aient le m\u00eame nom que les propri\u00e9t\u00e9s de l'objet, sinon la variable ne sera pas renseign\u00e9e. const myObject ={ name:\"Louis\", age: 0 } const {name, age} = myObject console.log(name) // affiche Louis console.log(age) // affiche 0 const {name1, age1} = myObject console.log(name1) // affiche undefined console.log(age1) // affiche undefined Si on veut donner un nom diff\u00e9rent que le nom des propri\u00e9t\u00e9s de l'objet, il faut utiliser les alias : const myObject ={ name:\"Louis\", age: 0, present: function(){console.log(\"Hello\")} } const {name, age:age1, present:hello} = myObject console.log(name) // affiche Louis console.log(age1) // affiche 0 hello() // affiche Hello","title":"Destructuring Objects"},{"location":"javascript/developpementModerneJavascript/#-_1","text":"","title":"----"},{"location":"javascript/developpementModerneJavascript/#les-classes-es6","text":"","title":"Les classes (ES6)"},{"location":"javascript/developpementModerneJavascript/#la-notion-de-classe","text":"Comme vu dans la partie pr\u00e9c\u00e9dente, pour construire un objet, au lieu de faire une fonction constructeur et ajouter des m\u00e9thodes sur le prototype, on peut cr\u00e9er une classe.","title":"La notion de classe"},{"location":"javascript/developpementModerneJavascript/#lheritage-inheritance","text":"Si on veut d\u00e9finir une classe qui a les m\u00eames propri\u00e9t\u00e9s qu'une autre classe avec une propri\u00e9t\u00e9 en plus, on peut h\u00e9riter de cette classe plut\u00f4t que de la red\u00e9finir de z\u00e9ro, ce qui \u00e9vitera une duplication de code. - le mot cl\u00e9 extends permet de dire de quelle clase on h\u00e9rite - le mot cl\u00e9 super dans le constructeur permet d'ex\u00e9cuter le constructeur de la classe parent - il est aussi possible d'ex\u00e9cuter une m\u00e9thode parent dans une m\u00e9thode enfant avec super en faisant super.nomMethodeParent() - il est possible d'utiliser les m\u00e9thodes parent sans les d\u00e9finir dans la classe enfant class Person { constructor(name, age){ this.name = name this.age = age } present(){ console.log(`Hello my name is ${this.name}`) } } class Hero extends Person{ constructor(name, age, power){ super(name, age) // ex\u00e9cute le constructeur de la classe parent avec ses param\u00e8tres this.power = power } usePower(){ console.log(`I am using my power ${this.power}`) } presentHero(){ super.present() console.log(`My power is ${this.power}`) } } let louis = new Person(\"Louis\", 0) louis.present() // affiche : Hello my name is Louis //louis.usePower() // il y aura une erreur car on ne peut utiliser la m\u00e9thode de Hero avec un objet Person let superman = new Hero(\"Superman\", 30, \"fly\") superman.present() // affiche : Hello my name is Superman superman.usePower() // affiche : I am using my power fly superman.presentHero() // affiche : Hello my name is Superman, puis affiche : My power is fly","title":"L'h\u00e9ritage (Inheritance)"},{"location":"javascript/developpementModerneJavascript/#etendre-les-objets-integres-extend-built-in-objects","text":"Depuis ES6, on peut aussi \u00e9tendre des objets int\u00e9gr\u00e9s \u00e0 JavaScript comme Array ou Function Par exemple, on va cr\u00e9er une classe qui h\u00e9rite d' Array et qui d\u00e9finit une m\u00e9thode qui renvoit un tableau avec tous les \u00e9l\u00e9ments en majuscules : class UpperCaseArray extends Array{ upperCase(){ let newArray = [] this.forEach(element => {newArray.push(element.toUpperCase())}) return newArray } } const myArray = new UpperCaseArray() myArray.push(\"louis\") myArray.push(\"k\u00e9vin\") myArray.push(\"Thibaut\") console.log(myArray.upperCase()) // affiche : [\"LOUIS\", \"K\u00c9VIN\", \"THIBAUT\"]","title":"Etendre les objets int\u00e9gr\u00e9s (Extend Built-In Objects)"},{"location":"javascript/developpementModerneJavascript/#methodes-statiques","text":"On peut aussi utiliser les classes pour regrouper les fonctions qui concernent un m\u00eame sujet. Par exemple, on peut faire une classe Mathematiques : class Mathematique{ addition(number1, number2){ return number1 + number2 } multiplication(number1, number2){ return number1 * number2 } } const myMath = new Mathematique() console.log(myMath.addition(2,3)) // affiche 5 console.log(myMath.multiplication(2,3)) // affiche 6 C'est inutile dans ce cas de cr\u00e9er une instance de classe pour utiliser les m\u00e9thodes, car rien n'est li\u00e9 \u00e0 une m\u00e9thode sp\u00e9cifique. Pour faire cela, on va d\u00e9clarer nos m\u00e9thodes static et on pourra utiliser les m\u00e9thodes sans instancier la classe. class Mathematique{ static addition(number1, number2){ return number1 + number2 } static multiplication(number1, number2){ return number1 * number2 } } console.log(Mathematique.addition(2,3)) console.log(Mathematique.multiplication(2,3))","title":"M\u00e9thodes Statiques"},{"location":"javascript/developpementModerneJavascript/#get-et-set","text":"De base, rien n'emp\u00eache d'acc\u00e9der et de modifier les propri\u00e9t\u00e9s de nos objets : class Person{ constructor(name){ this.name = name } } let louis = new Person(\"Louis\") console.log(louis.name) // affiche : Louis louis.name = \"Loulou\" // modifie le nom de l'objet louis console.log(louis.name) // affiche : Loulou Pour \u00e9viter cela, on peut utiliser get et set pour contr\u00f4ler l'acc\u00e8s aux propri\u00e9t\u00e9s de nos objets, choisir ce qu'on renvoit et dans quelle condition la propri\u00e9t\u00e9 peut \u00eatre modifi\u00e9e : class Person{ constructor(name){ this._name = name // par convention, on met un _ devant les propri\u00e9t\u00e9s que l'on veut rendre \"semi priv\u00e9\" } get name(){ return `b\u00e9b\u00e9 ${this._name}` } set name(value){ if(value.length > 2){ this._name = value } } } let louis = new Person(\"Louis\") console.log(louis.name) // affiche : b\u00e9b\u00e9 Louis louis.name = \"Lo\" console.log(louis.name) // affiche : b\u00e9b\u00e9 Louis, la modification n'a pas eu lieu car la taille du nom soumis n'est pas sup\u00e9rieur \u00e0 2 louis.name = \"Loulou\" console.log(louis.name) // affiche : b\u00e9b\u00e9 Loulou // On peut toujours acc\u00e9der \u00e0 la propri\u00e9t\u00e9 _name et la modifier directement console.log(louis._name) // affiche : Loulou louis._name = \"az\" console.log(louis._name) // affiche : az console.log(louis.name) // affiche : b\u00e9b\u00e9 az","title":"Get et Set"},{"location":"javascript/developpementModerneJavascript/#-_2","text":"","title":"----"},{"location":"javascript/developpementModerneJavascript/#les-modules-es6","text":"## Modules Sur des gros projets, il faut organiser le code JavaScript en plusieurs fichiers. Pour charger les diff\u00e9rents fichiers JavaScript, on peut les charger chacun un tag <script src=\"script.js\"></script> dans la page html. ``js // script1.js const myLog = message => console.log( My Log : ${message}`) // script2.js myLog(\"Hello !\") // index.html <!DOCTYPE html> Modules JavaScript // affiche dans la console : My Log : Hello ! Cette solution n'est pas id\u00e9ale pour plusieurs raisons : - \u00e0 chaque tag `script`, une nouvelle requ\u00eate est faite au serveur pour r\u00e9cup\u00e9rer le fichier - il faut faire attention \u00e0 l'ordre des fichiers en mettant d'abord les fichiers avec du code qui sert dans les fichiers suivant, sinon \u00e7a ne fonctionnera pas - tous les fichiers partagent le m\u00eame scope global, on s'expose donc aux accidents de variables si par exemple des variables ont le m\u00eame nom dans diff\u00e9rents fichiers ce qui fait que des variables vont s'\u00e9craser Pour r\u00e9pondre \u00e0 ces probl\u00e8mes, ES6 a amen\u00e9 **les modules**. Chaque module peut exporter certaines de ces fonctionnalit\u00e9s et importer des fonctionnalit\u00e9s d'autres modules. La probl\u00e8me est que la plupart des navigateurs ne supportent pas encore les modules ES6. Avec Chrome, il faut au moins la version 60 et aller dans l'url `chrome://flags/` et activer `Experimental Web Platform features`. Avec Firefox en version 61 (et peut-\u00eatre les versions plus anciennes ?), les modules sont pris en charge nativement. Dans le script 1, il faut exporter la fonction avec le mot cl\u00e9 `export` et dans le script 2, il faut l'importer. Dans le fichier html, on laisse qu'un seul script JavaScript, notre fichier point d'entr\u00e9e script2.js et on ajoute le type module dans la balise script. Le r\u00e9sultat sera le m\u00eame. ```js // script1.js export const myLog = message => console.log(`** My Log ** : ${message}`) // script2.js import {myLog} from \"./script1.js\" myLog(\"Hello !\") // index.html <!DOCTYPE html> <html> <head> <title>Modules JavaScript</title> <meta charset=\"UTF-8\"> </head> <body> <script type=\"module\" src=\"script2.js\"></script> </body> </html> ## Import et Export Avec les modules, l'import et l'export se fait par r\u00e9f\u00e9rence, c'est-\u00e0-dire qu'on ne cr\u00e9e pas une nouvelle variable mais on importe la variable de l'autre module. Pour exporter plusieurs choses d'un m\u00eame module, on fait deux exports et on fait les deux imports sur une seule ligne ``js // script1.js export const myLog = message => console.log( My Log : ${message}`) export let myVariable = \"Coucou !\" // script2.js import {myLog, myVariable} from \"./script1.js\" myLog(myVariable) On peut aussi faire l'export \u00e0 la fin du fichier au lieu de le faire au moment de la d\u00e9claration. ```js // script1.js const myLog = message => console.log(`** My Log ** : ${message}`) let myVariable = \"Coucou !\" export {myLog, myVariable} Une variante de l'export et l' export default . Il ne peut y en avoir qu'un par fichier. Lorsqu'on l'importe, on ne met pas les accolades et on lui donne le nom qu'on veut car lorsqu'on ne met pas les accolades, c'est forc\u00e9ment lque \u00e7a correspond \u00e0 l'export default. // script1.js const myLog = message => console.log(`** My Log ** : ${message}`) let myVariable = \"Coucou !\" let myVariable2 = \"Important\" export {myLog, myVariable} export default myVariable2 // script2.js import {myLog, myVariable} from \"./script1.js\" import myVariable2 from \"./script1.js\" myLog(myVariable) myLog(myVariable2) Exemple en renommant la variable de l'export default dans l'import : // script2.js import toto, {myLog, myVariable} from \"./script1.js\" myLog(myVariable) myLog(toto) // correspond \u00e0 l'export default de myVariable2 On peut aussi utiliser des alias pour renommer les export classiques : // script2.js import toto, {myLog as myLogImported, myVariable} from \"./script1.js\" myLogImported(myVariable) myLogImported(toto) Lorsqu'il y a plusieurs \u00e9l\u00e9ments \u00e0 importer, on peut utiliser l'\u00e9toile pour tout importer. // script2.js import * as external from \"./script1.js\" external.myLog(external.myVariable) # Les nouveaut\u00e9s ES7 ## Array.prototype.includes Lorsqu'on veut v\u00e9rifier la pr\u00e9sence d'un \u00e9l\u00e9ment dans un tableau, il faut utiliser la m\u00e9thode indexOf() qui renvoie la position de l'\u00e9l\u00e9ment dans le tableau, ou -1 si l'\u00e9l\u00e9ment est absent. const fruits = [\"pomme\", \"banane\", \"orange\"] console.log(fruits.indexOf(\"banane\")) // affiche 1 console.log(fruits.indexOf(\"melon\")) // affiche -1 const monFruit = \"banane\" if(fruits.indexOf(monFruit)>-1){ console.log(`${monFruit} est dans le tableau`) } else { console.log(`${monFruit} n'est pas dans le tableau`) } En ES7, on peut utiliser la m\u00e9thode includes() qui renvoie true ou false si l'\u00e9l\u00e9ment est pr\u00e9sent ou non dans le tableau. const fruits = [\"pomme\", \"banane\", \"orange\"] console.log(fruits.includes(\"banane\")) // affiche true console.log(fruits.includes(\"melon\")) // affiche false const monFruit = \"banane\" if(fruits.includes(monFruit)){ console.log(`${monFruit} est dans le tableau`) } else { console.log(`${monFruit} n'est pas dans le tableau`) }","title":"Les modules (ES6)"},{"location":"javascript/developpementModerneJavascript/#loperateur-dexponentiation-operateur-de-puissance","text":"l'ES7 am\u00e8ne un nouvel op\u00e9rateur qui est la puissance qui se note avec deux \u00e9toiles sous la forme x ** y pour x puissance y. Avant l'ES7, il fallait utiliser l'objet Math. const calcul = Math.pow(2,3) // 2*2*2 console.log(calcul) // affiche : 8 const newCalcul = 2 ** 3 console.log(newCalcul) // affiche : 8 On peut aussi utiliser ce nouvel op\u00e9rateur comme les op\u00e9rateurs classiques. let myVar = 2 myVar **= 3 // \u00e9quivaut \u00e0 myVar = myVar ** 3 console.log(myVar) // affiche 8","title":"L'op\u00e9rateur d'exponentiation (op\u00e9rateur de puissance)"},{"location":"javascript/developpementModerneJavascript/#-_3","text":"","title":"----"},{"location":"javascript/developpementModerneJavascript/#developpement-moderne-javascript_1","text":"Tous les navigateurs ne supportent pas encore ces nouveaut\u00e9s. Il existe des outils qui permettent de coder en ES6 et ES7 et que le code soit support\u00e9 par tous les navigateurs.","title":"D\u00e9veloppement moderne JavaScript"},{"location":"javascript/developpementModerneJavascript/#-_4","text":"","title":"----"},{"location":"javascript/developpementModerneJavascript/#npm","text":"","title":"Npm"},{"location":"javascript/developpementModerneJavascript/#les-bases-de-npm","text":"Npm pour Node Package Manager va nous permettre de g\u00e9rer nos paquets JavaScript. Pour l'utiliser, il faut t\u00e9l\u00e9charger Node.js Pour v\u00e9rifier qu'il est bien install\u00e9 et v\u00e9rifier la version, tpaer la commande node -v puis npm -v . Jusqu'\u00e0 pr\u00e9sent, pour utiliser une biblioth\u00e8que externe comme JQuery, il faut t\u00e9l\u00e9charger la biblioth\u00e8que et l'ajouter dans le fichier HTML. Avec Npm, il est possible de t\u00e9l\u00e9charger la biblioh\u00e8que tr\u00e8s facilement, en faisant npm install jquery . Un dossier node_modules est cr\u00e9\u00e9 avec un sous-dossier jquery . Il faut ensuite l'ajouter au fichier HTML en pointant dans le sous-dossier dist (pour distribution) et on peut utiliser jquery dans le projet. <!DOCTYPE html> <html> <head> <title>NPM</title> <meta charset=\"UTF-8\"> </head> <body> <script src=\"./node_modules/jquery/dist/jquery.js\"></script> <script type=\"module\" src=\"script.js\"></script> </body> </html> // script.js import {myLog} from \"./external.js\" myLog(\"Hello !\") jQuery(document).ready(function(){ console.log(\"jQuery est pr\u00eat !\"); }); // external.js export const myLog = message => console.log(`** My Log ** : ${message}`) On peut d\u00e9sinstaller la biblioth\u00e8que avec la commande npm uninstall jquery , ce qui supprime le dossier jquery du dossier node_modules . On peut mettre \u00e0 jour la version de jquery avec la commande npm update jquery .","title":"Les bases de Npm"},{"location":"javascript/developpementModerneJavascript/#le-fichier-packagejson","text":"G\u00e9n\u00e9ralement on a beaucoup de d\u00e9pendances, ce qui deviendrait lourd \u00e0 g\u00e9rer avec les commandes vues ici. Avec le fichier package.json , on va pouvoir noter toutes les d\u00e9pendances ainsi que leur version. Cela permettra aussi de reproduire le projet sur un autre poste sans y inclure toutes les d\u00e9pendances mais uniquement ce fichier. En lan\u00e7ant la commande npm install , toutes les d\u00e9pendances inscrites dans le fichier package.json seront install\u00e9es dans la version sp\u00e9cifi\u00e9. Ce fichier est un fichier de configuration, il sert \u00e9galement \u00e0 d'autres choses. Pour le cr\u00e9er, il faut ex\u00e9cuter la commande npm init . Lorsqu'on installe ou d\u00e9sinstalle une d\u00e9pendance, elle n'est pas renseign\u00e9e dans le fichier package.json . Pour que ce soit le cas il faut ajouter --save , par exemple npm install jquery --save et jquery sera inscrit dans les d\u00e9pendances avec son num\u00e9ro de version. Il y a deux types de d\u00e9pendances : - les d\u00e9pendances classiques dont notre code a besoin, comme par exemple jquery . Elles sont rensiegn\u00e9es donc dependencies - les d\u00e9pendances de d\u00e9veloppement qui correspond aux outils de d\u00e9veloppement, par exemple webpack que l'on verra au prochain chapitre. Elles sont rensiegn\u00e9es donc devDependencies . Pour cela, il faut utiliser la commande --save-dev , par exemple npm install --save-dev webpack webpack-cli En installant webpack , il y a maintenant plein de d\u00e9pendances dans node_modules car webpack a besoin d'autres d\u00e9pendances qui ont \u00e9t\u00e9 install\u00e9 \u00e9galement.","title":"Le fichier package.json"},{"location":"javascript/developpementModerneJavascript/#-_5","text":"","title":"----"},{"location":"javascript/developpementModerneJavascript/#webpack","text":"","title":"Webpack"},{"location":"javascript/developpementModerneJavascript/#quest-ce-que-webpack","text":"Il est principalement utilis\u00e9 comme module bundler , c'est-\u00e0-dire qu'il va prendre tous nos fichiers pour faire un seul gros fichier. Ce fichier pourra \u00eatre inclus dans le fichier HTML, ce qui permet d'utiliser les modules ES6 directement avec webpack tout en \u00e9tant compatible avec les navigateurs anciens. Il faut cr\u00e9er un fichier de configuration webpack.config.js module.exports = { entry: \"./script.js\", // dit \u00e0 webpack le point d'entr\u00e9e de notre projet output: { filename: \"bundle.js\" // dit \u00e0 webpack le nom du fichier produit } } Il faut ensuite indiquer dans le fichier HTML que le fichier de script \u00e0 utiliser est celui cr\u00e9\u00e9 par webpack. On peut aussi enlever la d\u00e9pendance jquery du fichier HTML et l'importer dans le script o\u00f9 on l'utilise, webpack l'embarquera dans le fichier bundle.js qu'il va g\u00e9n\u00e9rer dans un dossier dist (pour distribution). <!DOCTYPE html> <html> <head> <title>NPM</title> <meta charset=\"UTF-8\"> </head> <body> <script src=\"./dist/bundle.js\"></script> </body> </html> // script.js import {myLog} from \"./external.js\" import jQuery from \"jquery\" myLog(\"Hello !\") jQuery(document).ready(function(){ console.log(\"jQuery est pr\u00eat !\"); }); // external.js export const myLog = message => console.log(`** My Log ** : ${message}`)","title":"Qu'est-ce que Webpack"},{"location":"javascript/developpementModerneJavascript/#executer-webpack","text":"On va lancer l'ex\u00e9cutable de webpack. Dans le dossier .bin de node_modules, il y a tous les ex\u00e9cutables. Pour lancer webpack, on va ex\u00e9cuter la commande node_modules/.bin/webpack . Le fichier *bundle.js a \u00e9t\u00e9 cr\u00e9\u00e9 en enpaquetant nos fichiers javscript. On peut lancer notre page HTML et \u00e7a fonctionne comme avant san utiliser les modules. Pour \u00e9viter de lancer la commande node_modules/.bin/webpack \u00e0 chaque fois, on va cr\u00e9er une t\u00e2che dans le fichier package.json que l'on pourra ex\u00e9cuter \u00e0 la place de cette commande. Pour exc\u00e9cuter la t\u00e2che, on lancera la commande npm run build // package.json \"scripts\": { \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\", \"build\": \"webpack\" // ajout de la t\u00e2che build qui cr\u00e9e notre fichier bundle.js } ``` On peut faire mieux en disant \u00e0 webpack d'observer notre code et de recompiler le code pour recr\u00e9er *bundle.js* quand il observe des modifications sans relancer la commande de build. Pour cela, on va ajouter une propri\u00e9t\u00e9 dans le fichier de configuration de webpack. Lorsqu'on fait une modification et que l'on sauvegarde, il n'y a plus qu'\u00e0 rafra\u00eechir la page HTML pour voir le changement. ```js // webpack.config.js module.exports = { watch: true, // ajout de cette prori\u00e9t\u00e9 pour que webpack observe notre code et recompile lorsqu'il y a des changements entry: \"./script.js\", output: { filename: \"bundle.js\" } }","title":"Ex\u00e9cuter Webpack"},{"location":"javascript/developpementModerneJavascript/#serveur-local-webpack","text":"Pour \u00e9viter d'avoir \u00e0 recharger la page HTML \u00e0 chaque modification du code JavaScript, on va mettre en place un serveur de d\u00e9veloppement local. On va installer un nouveau paquet avec la commande npm install --save-dev webpack-dev-server . On va ex\u00e9cuter la commande node_modules/.bin/webpack-dev-server qui compile notre code et le met \u00e0 disposition \u00e0 l'adresse localhost:8080 . En faisant des modifications dans le code et que l'on enregistre, la page est relanc\u00e9 automatiquement. On peut cr\u00e9er une t\u00e2che dans les scripts dans le fichier package.json : \"start\": \"webpack-dev-server --open\" . --open permet de lancer la page HTML dans le navigateur avec la commannde npm run start .","title":"Serveur local Webpack"},{"location":"javascript/developpementModerneJavascript/#architecture-des-fichiers","text":"Pour le moment, tous les fichiers sont mis \u00e0 la racine du projet. On va r\u00e9organiser tout \u00e7a - un dossier src qui contient le code de d\u00e9veloppement, les fichiers sources JavaScript - un dossier dist qui contient le code de distribution que voit le public, le fichier index.html et le fichier bundle.js Il faut mettre \u00e0 jour le fichier de configuration de webpack pour que \u00e7a fonctionne bien // webpack.config.js const path = require(\"path\") // permet de cr\u00e9er des chemins absolus \u00e0 partir des chemins relatifs car webpack attend \u00e0 certains endroits des chemins absolus module.exports = { watch: true, entry: \"./src/script.js\", // dit \u00e0 webpack le point d'entr\u00e9e de notre projet output: { path: path.resolve(__dirname, \"dist\"), filename: \"bundle.js\" // dit \u00e0 webpack le nom du fichier produit }, devServer: { contentBase: path.resolve(__dirname, \"dist\"), // dit au serveur de nous servir ce qu'il y a dans le dossier dist au lieu de la racine du projet open: true // lance le navigateur automatiquement au lancement du serveur, ce qui \u00e9vite de mettre --open dans la t\u00e2che } } // index.html <!DOCTYPE html> <html> <head> <title>NPM</title> <meta charset=\"UTF-8\"> </head> <body> <script src=\"bundle.js\"></script> </body> </html>","title":"Architecture des fichiers"},{"location":"javascript/developpementModerneJavascript/#-_6","text":"","title":"----"},{"location":"javascript/developpementModerneJavascript/#babel","text":"","title":"Babel"},{"location":"javascript/developpementModerneJavascript/#quest-ce-que-babel","text":"Babel est un transpileur qui va traduire notre code ES6-ES7 en ES5 \u00e9quivalent, ce qui nous permettra d'\u00eatre compatible avec les anciennes versions des navigateurs.","title":"Qu'est-ce que Babel"},{"location":"javascript/developpementModerneJavascript/#babel-loader","text":"C'est une fonctionnalit\u00e9 de webpack qui va permettre de transpiler le code en ES5 au moment de la cr\u00e9ation du fichier bundle.js . Il faut commencer par installer les d\u00e9pendances n\u00e9cessaires npm install --save-dev babel-loader babel-core babel-preset-env . Il faut ensuite mettre \u00e0 jour le fichier de configuration de webpack en ajoutant une partie. // webpack.config.js module: { rules: [ { // on teste si c'est un fichier JS test: /\\.js$/, // on ne traite pas les fichiers dans node_modules exclude: /node_modules/, use: { loader: \"babel-loader\", options: { presets: [\"env\"] } } } ] }","title":"Babel loader"},{"location":"javascript/developpementModerneJavascript/#babel-polyfill","text":"ES6-ES7 n'apportent pas que de la nouvelle syntaxe mais aussi de nouveaux \u00e9l\u00e9ments. Quand on utilise un nouvel \u00e9l\u00e9ment ES6, on ne peut pas le traduire en ES5, ce qui peut poser des probl\u00e8mes de compatibilit\u00e9 avec les anciens navigateurs. Dans ce cas, on peut utiliser un polyfill , qui est un bout de code qui contient ces nouveaux \u00e9l\u00e9ments, ce qui permet d'ajouter les \u00e9l\u00e9ments manquants au navigateur. On va utiliser Babel polyfill. Il faut commencer par l'installer avec la commande npm install --save babel-polyfill . Il faut ensuite mettre \u00e0 jour le fichier de configuration de webpack en ajoutant babel-polyfill dans les fichiers en entr\u00e9e. Il faut aussi importer babel-polyfill dans le fichier d'entr\u00e9e JavaScript. // webpack.config.js module.exports = { watch: true, entry: [\"babel-polyfill\", \"./src/script.js\"], // dit \u00e0 webpack le point d'entr\u00e9e de notre projet output: { path: path.resolve(__dirname, \"dist\"), filename: \"bundle.js\" // dit \u00e0 webpack le nom du fichier produit } // script.js import \"babel-polyfill\" import {myLog} from \"./external.js\" myLog(\"Hello !\")","title":"Babel polyfill"},{"location":"javascript/frameworksJavascript/","text":"Les biblioth\u00e8ques et frameworks JavaScript Qu'est-ce qu'un framework et quelle est la diff\u00e9rence entre une biblioth\u00e8que et un framework ? Un framework est une structure pour d\u00e9velopper, c'est un cadre de travail qui va structurer le travail du d\u00e9veloppeur. Les frameworks font gagner du temps en prenant en charge les besoins r\u00e9curents comme l'architecture du projet, ce qui permet de se focaliser sur le m\u00e9tier du projet. Une biblioth\u00e8que et un framework ont tous les deux pour but de faciliter le d\u00e9veloppement. Pour les diff\u00e9rencier, on peut r\u00e9sumer en disant que notre code utilise une biblioth\u00e8que pour fonctionner alors qu'un framework utilise notre code pour fonctionner et cr\u00e9er l'ensemble de notre code. En g\u00e9n\u00e9ral, une biblioth\u00e8que est un ensemble de fonctions et d'objets que notre code va utiliser en important la biblioth\u00e8que, par exemple jQuery. D\u00e9couverte de React D\u00e9couverte d'Angular D\u00e9couverte de Vue.js Angular, React ou Vue.js D\u00e9couverte de Node.js D\u00e9couverte d'Express D\u00e9couverte de MongoDB D\u00e9couverte de MEAN et de Meteor (?)","title":"Les biblioth\u00e8ques et frameworks JavaScript (TODO)"},{"location":"javascript/frameworksJavascript/#les-bibliotheques-et-frameworks-javascript","text":"","title":"Les biblioth\u00e8ques et frameworks JavaScript"},{"location":"javascript/frameworksJavascript/#quest-ce-quun-framework-et-quelle-est-la-difference-entre-une-bibliotheque-et-un-framework","text":"Un framework est une structure pour d\u00e9velopper, c'est un cadre de travail qui va structurer le travail du d\u00e9veloppeur. Les frameworks font gagner du temps en prenant en charge les besoins r\u00e9curents comme l'architecture du projet, ce qui permet de se focaliser sur le m\u00e9tier du projet. Une biblioth\u00e8que et un framework ont tous les deux pour but de faciliter le d\u00e9veloppement. Pour les diff\u00e9rencier, on peut r\u00e9sumer en disant que notre code utilise une biblioth\u00e8que pour fonctionner alors qu'un framework utilise notre code pour fonctionner et cr\u00e9er l'ensemble de notre code. En g\u00e9n\u00e9ral, une biblioth\u00e8que est un ensemble de fonctions et d'objets que notre code va utiliser en important la biblioth\u00e8que, par exemple jQuery.","title":"Qu'est-ce qu'un framework et quelle est la diff\u00e9rence entre une biblioth\u00e8que et un framework ?"},{"location":"javascript/frameworksJavascript/#decouverte-de-react","text":"","title":"D\u00e9couverte de React"},{"location":"javascript/frameworksJavascript/#decouverte-dangular","text":"","title":"D\u00e9couverte d'Angular"},{"location":"javascript/frameworksJavascript/#decouverte-de-vuejs","text":"","title":"D\u00e9couverte de Vue.js"},{"location":"javascript/frameworksJavascript/#angular-react-ou-vuejs","text":"","title":"Angular, React ou Vue.js"},{"location":"javascript/frameworksJavascript/#decouverte-de-nodejs","text":"","title":"D\u00e9couverte de Node.js"},{"location":"javascript/frameworksJavascript/#decouverte-dexpress","text":"","title":"D\u00e9couverte d'Express"},{"location":"javascript/frameworksJavascript/#decouverte-de-mongodb","text":"","title":"D\u00e9couverte de MongoDB"},{"location":"javascript/frameworksJavascript/#decouverte-de-mean-et-de-meteor","text":"","title":"D\u00e9couverte de MEAN et de Meteor (?)"},{"location":"javascript/javascriptDebarqueDansLeNavigateur/","text":"JavaScript d\u00e9barque dans le navigateur ---- JavaScript dans le navigateur L'objet Window Lorsque JavaScript est ex\u00e9cut\u00e9 dans le navigateur, l'objet global est Window. Il repr\u00e9sente la fen\u00eatre du navigateur. Il poss\u00e8de des propri\u00e9t\u00e9s et des m\u00e9thodes. On peut y acc\u00e9der directement sans mettre le mot window car c'est l'objet global (il est dit implicite). // affiche la largeur du navigateur console.log(window.innerWidth) console.log(innerWidth) alert() n'est pas une fonction mais une m\u00e9thode de l'objet window. window.alert('Hello World') est \u00e9quivalent \u00e0 alert('Hello World') en revanche isNan() ou parseInt ne d\u00e9pendent pas d'un objet, ce sont des fonctions globales. Il n'y en a pas beaucoup lorsqu'on d\u00e9clare une variable dans le contexte global du script, cette variable devient une propri\u00e9t\u00e9 de l'objet window toute variable non d\u00e9clar\u00e9e (utilis\u00e9e sans \u00e9crire le mot-cl\u00e9 var) devient une propri\u00e9t\u00e9 de window, quelque soit l'endroit o\u00f9 on se situe. Ecrire text = 'toto' revient donc \u00e0 \u00e9crire window.text = 'toto'. Il est conseill\u00e9 de toujours d\u00e9clarer une variable avec var. Pour d\u00e9clarer une variable globale dans une fonction, on pourra sp\u00e9cifier explicitement l'objet window L'objet Location C'est une propri\u00e9t\u00e9 de l'objet global Window. Il a lui-m\u00eame des propri\u00e9t\u00e9s et des m\u00e9thodes. Il contient des informations sur o\u00f9 se trouve notre navigateur (URL, etc...). location.reload() // relancer la page location.replace(\"URL\") // permet de change d'URL L'objet Document : le DOM C'est une propri\u00e9t\u00e9 de l'objet Window. C'est la repr\u00e9sentation de notre page HTML, plus pr\u00e9cisemment la la balise <html> . Avec JavaScript, on va manipuler le DOM. On peut voir les propri\u00e9t\u00e9s de l'objet document avec la commande console.log(window) et le contenu de l'objet document avec la commande console.log(window.document) . Le document a des propri\u00e9t\u00e9s que l'on peut modifier, ajouter, d\u00e9placer, supprimer. Par exemple le titre de la page : console.log(document.title) // affiche : JavaScript (titre pr\u00e9sent dans la page HTML) document.title = \"Mon nouveau titre\" console.log(document.title) // affiche : Mon nouveau titre console.log(document.body) // affiche le body Petit historique Le DOM est une interface de programmation pour les documents XML et HTML, qui permet via le JavaScript d'acc\u00e9der au code XML et/ou HTML d'un document. On peut modifier, ajouter, d\u00e9placer, supprimer des \u00e9l\u00e9ments HTML (une paire de balises HTML) Au d\u00e9but du JavaScript, le DOM n'\u00e9tait pas unifi\u00e9, c'est-\u00e0-dire que deux navigateurs poss\u00e9daient un DOM diff\u00e9rent, donc la mani\u00e8re d'acc\u00e9der \u00e0 un \u00e9l\u00e9ment HTML diff\u00e9rait d'un navigateur \u00e0 l'autre. Il fallait donc coder diff\u00e9remment en fonction du navigateur. Le W3C a publi\u00e9 une nouvelle sp\u00e9cification DOM-1, pour DOM Level 1 qui d\u00e9finit le DOM et comment sont sch\u00e9matis\u00e9s les documents HTML et XML, sous forme d'un arbre, ou d'une hi\u00e9rarchie. L'\u00e9l\u00e9ment contient 2 \u00e9l\u00e9ments enfants : et , etc... Ensuite, la sp\u00e9cification DOM-2 a \u00e9t\u00e9 publi\u00e9 avec l'introduction de la m\u00e9thode getElementById() qui permet de r\u00e9cup\u00e9rer un \u00e9l\u00e9ment en connaissant son ID. La structure DOM Le DOM pose comme concept que la page Web est une hi\u00e9rarchie d'\u00e9l\u00e9ments. On peut sch\u00e9matiser une page web comme ceci : Voici le code source correspondant : <!doctype html> <html> <head> <meta charset=\"utf-8\" /> <title>Le titre de la page</title> </head> <body> <div> <p>Du texte <a>et un lien</a></p> </div> </body> </html> L'\u00e9l\u00e9ment <html> contient deux \u00e9l\u00e9ments, appel\u00e9s enfants : <head> et <body> . Pour ces deux enfants, <html> est l'\u00e9l\u00e9ment parent . Chaque \u00e9l\u00e9ment est appel\u00e9 noeud ( node en anglais). <title> contient un \u00e9l\u00e9ment enfant #text qui contient du texte. Le texte pr\u00e9sent dans une page Web est vu par le DOM comme on noeud de type #text . ---- JavaScript et le DOM L'h\u00e9ritage des propri\u00e9t\u00e9s et des m\u00e9thodes Les \u00e9l\u00e9ments HTML sont vus par JavaScript comme des objets poss\u00e9dant des propri\u00e9t\u00e9s et des m\u00e9thodes. Tous ne poss\u00e8dent pas les m\u00eames propri\u00e9t\u00e9s et m\u00e9thodes. Certaines sont communes car tous les \u00e9l\u00e9ments HTML sont d'un m\u00eame type : Node. Une est un objet HTTMLDivElement, sous-objet HTMLElement, lui-m\u00eame sous-objet d'Element, lui-m\u00eame sous-objet de Node. Les m\u00e9thodes et propri\u00e9t\u00e9s de Node peuvent \u00eatre utilis\u00e9es depuis ses sous-objets gr\u00e2ce \u00e0 l'h\u00e9ritage. Hi\u00e9rarchie des \u00e9l\u00e9ments children renvoie une HTML Collection (un peu comme un tableau) des enfants de l'\u00e9l\u00e9ment firstElementChild et lastElementChild renvoient le premier et le dernier enfant de l'\u00e9l\u00e9ment nextElementSibling renvoie le prochain \u00e9l\u00e9ment de m\u00eame niveau parentElement renvoie l'\u00e9l\u00e9ment parent <body> <div> <p>Mon paragraphe 1</p> <p>Mon paragraphe 2</p> </div> <script src=\"script.js\"></script> </body> console.log(document.body.children) // [div, script] console.log(document.body.children[0].children) // [p, p] console.log(document.body.firstElementChild) // \u00e9quivalent \u00e0 children[0], retourne la div console.log(document.body.children[0].nextElementSibling) // affiche le script console.log(document.body.children[0].parentElement) // affiche le body R\u00e9cup\u00e9rer et modifier les \u00e9l\u00e9ments Un console.log() d'un \u00e9l\u00e9ment du DOM affiche la repr\u00e9sentation HTML de l'\u00e9l\u00e9ment, mais on ne voit pas ses propri\u00e9t\u00e9s. Pour voir les propri\u00e9t\u00e9s et m\u00e9thodes d'un \u00e9l\u00e9ment, il faut afficher tous les enfants de l'\u00e9l\u00e9ment parent et cliquer sur l'\u00e9l\u00e9ment enfant qui nous int\u00e9resse dans la console. console.log(document.body.children[0].children[1]) // affiche <p>Mon paragraphe 2</p> console.log(document.body.children[0].children) // affiche l'HTML Collection avec ses 2 enfants. On peut cliquer sur chaque enfant pour voir ses attributs et m\u00e9thodes Le contenu : innerHTML innerHTML permet de r\u00e9cup\u00e9rer le code HTML enfant d'un \u00e9l\u00e9ment sous forme de texte. Si les balises sont pr\u00e9sentes, innerHTML les retournera sous forme de texte. Exemple : <body> <div id=\"myDiv\"> <p>Un peu de texte <a>et un lien</a></p> </div> <script> const div = document.getElementById('myDiv') console.log(div.innerHTML) // affiche : <p>Un peu de texte <a>et un lien</a></p> </script> </body> Autre exemple o\u00f9 l'on va modifier le contenu du paragraphe : console.log(document.body.children[0].children[0].innerHTML) // affiche Un peu de texte <a>et un lien</a> document.body.children[0].children[0].innerHTML = \"<strong>Nouveau Texte</strong>\" console.log(document.body.children[0].children[0].innerHTML) // affiche Nouveau Texte (en gras car les les balises strong sont interpr\u00e9t\u00e9es par le navigateur pour mettre le texte en gras) Il est aussi possible d'ajouter ou d'\u00e9diter du HTML document.getElementById('myDiv').innerHTML = '<blockquote>Je mets une citation \u00e0 la place du paragraphe</blockquote>' document.getElementById('myDiv').innerHTML += ' et <strong>une portion mise en emphase</strong>.' Il ne faut pas l'utiliser dans une boucle car innerHTML ralentit l'ex\u00e9cution du code. Il vaut mieux la concat\u00e9ner dans une variable et ensuite ajouter le tout via innerHTML . innerText et textContent innerText pour IE et textContent pour les autres navigateurs sont des propri\u00e9t\u00e9s analogues \u00e0 innerHTML , qui permettent de r\u00e9cup\u00e9rer le contenu d'un \u00e9l\u00e9ment sous forme de texte mais sans les balises , et permet aussi de modifier le contenu de l'\u00e9l\u00e9ment. - innerText a \u00e9t\u00e9 introduite dans IE, mais jamais standardis\u00e9e et n'est pas suport\u00e9e par tous les navigateurs - textContent est la version standardis\u00e9e d' innerText . Elle est reconnue par tous les navigateurs \u00e0 l'exception des versions ant\u00e9rieures \u00e0 IE9. console.log(document.body.children[0].children[0].textContent) // affiche Un peu de texte et un lien document.body.children[0].children[0].textContent = \"<strong>Nouveau Texte</strong>\" // les balises ne sont pas interpr\u00e9t\u00e9s par le navigateur mais \u00e9crites comme du texte affich\u00e9 dans le navigateur console.log(document.body.children[0].children[0].textContent) // affiche <strong>Nouveau Texte</strong> Modifier le style La propri\u00e9t\u00e9 style permet de modifier le style CSS des \u00e9l\u00e9ments. Les types correspondent au CSS sauf qu'il faut les \u00e9crire en kamel case. Par exemple \u00e9crire backgroundColor en JavaScript au lieu de background-color en CSS. document.body.children[0].style.backgroundColor = \"red\" // mais le fond de la div en rouge Modifier les classes CSS <body> <div class=\"super\"> <p>Mon paragraphe 1</p> <p>Mon paragraphe 2</p> </div> <script src=\"script.js\"></script> </body> classList permet d'avoir la liste des classes CSS que poss\u00e8de un \u00e9l\u00e9ment. Les m\u00e9thodes add() et remove() permettent d'ajouter et d'enlever des classes CSS. toggle() permet d'enlever la classe si elle pr\u00e9sente et de l'ajouter si elle n'y est pas. console.log(document.body.children[0].classList) // affiche [\"super\"] document.body.children[0].classList.add(\"toto\") // ajoute la classe toto \u00e0 la div et applique son style console.log(document.body.children[0].classList) // affiche [\"super\", \"toto\"] document.body.children[0].classList.remove(\"toto\") // enl\u00e8ve la classe toto de la div et enl\u00e8ve son style console.log(document.body.children[0].classList) // affiche [\"super\"] document.body.children[0].classList.toggle(\"toto\") console.log(document.body.children[0].classList) // affiche [\"super\", \"toto\"] document.body.children[0].classList.toggle(\"toto\") console.log(document.body.children[0].classList) // affiche [\"super\"] On peut aussi utiliser className pour appliquer une classe CSS \u00e0 un \u00e9l\u00e9ment : document.getElementById('p1').className = 'bleu' Modifier les attributs Un attribut correspond aux informations pr\u00e9sentes dans une balise, par exemple src dans la balise script : <script src=\"index.js\"></script> . Les m\u00e9thodes getAttribute() et setAttribute() permettent de r\u00e9cup\u00e9rer et modifier un attribut d'un \u00e9l\u00e9ment HTML. console.log(document.body.children[1].getAttribute(\"src\")) // affiche index.js document.body.children[1].setAttribute(\"src\", \"toto.js\") // modifie la valeur de l'attribut renseign\u00e9e console.log(document.body.children[1].getAttribute(\"src\")) // affiche toto.js S\u00e9lectionner les \u00e9l\u00e9ments Pour s\u00e9lectionner un \u00e9l\u00e9ment, on peut le faire plus simplement qu'en partant de body et en descendant avec children . La m\u00e9thode getElementById() de l'objet document permet de s\u00e9lectionner un \u00e9l\u00e9ment par son id, getElementsByTagName() s\u00e9lectionne les \u00e9l\u00e9ments qui correspondent \u00e0 un tag HTML, par exemple h1 ou p , et getElementsByClassName() s\u00e9lectionne les \u00e9l\u00e9ments qui correspondent \u00e0 une classe CSS. On peut aussi stocker les \u00e9l\u00e9ments dans une variable. <body> <div class=\"super\"> <h1 id=\"titre\">Mon Titre</h1> <p class=\"maClasse\">Mon paragraphe 1</p> <p>Mon paragraphe 2</p> </div> <script src=\"script.js\"></script> </body> console.log(document.getElementById(\"titre\")) // affiche <h1 id=\"titre\">Mon Titre</h1> console.log(document.getElementsByTagName(\"p\")) // affiche une HTML Collection avec les 2 paragraphes console.log(document.getElementsByClassName(\"maClasse\")) // affiche une HTML Collection avec l'\u00e9l\u00e9ment qui a cette classe const monTitre = document.getElementById(\"titre\") console.log(monTitre) // affiche <h1 id=\"titre\">Mon Titre</h1> S\u00e9lectionner avec Query Selector La m\u00e9thode querySelector() permet d'utiliser les s\u00e9lecteurs CSS pour s\u00e9lectionner un \u00e9l\u00e9ment. Si plusieurs \u00e9l\u00e9ments correspondent, seul le premier \u00e9l\u00e9ment sera s\u00e9lectionn\u00e9. La m\u00e9thode querySelectorAll() renvoie une liste, et permet donc de s\u00e9lectionner plusieurs \u00e9l\u00e9ments. console.log(document.querySelector(\".maClasse\")) // affiche <p class=\"maClasse\">Mon paragraphe 1</p> console.log(document.querySelectorAll(\".maClasse\")) // affiche une NodeList d'un \u00e9l\u00e9ment avec le paragraphe 1 console.log(document.querySelector(\"p\")) // affiche <p class=\"maClasse\">Mon paragraphe 1</p> (le 1er paragraphe rencontr\u00e9) console.log(document.querySelectorAll(\"p\")) // affiche une NodeList de deux \u00e9l\u00e9ments avec les paragraphes Modifier l'ordre des \u00e9l\u00e9ments La m\u00e9thode insertBefore() permet d'ins\u00e9rer un \u00e9l\u00e9ment HTML avant un autre \u00e9l\u00e9ment. Si l'\u00e9l\u00e9ment existe d\u00e9j\u00e0, il est d'abord supprim\u00e9 avant d'\u00eatre replac\u00e9. La m\u00e9thode appendChild() permet d'ajouter un \u00e9l\u00e9ment \u00e0 un autre \u00e9l\u00e9ment en tant qu'enfant. La m\u00e9thode replaceChild() permet de remplacer un \u00e9l\u00e9ment enfant par un autre. La m\u00e9thode removeChild() permet de supprimer un \u00e9l\u00e9ment, remove() le permet aussi de mani\u00e8re plus simple mais n'est pas support\u00e9 par les anciennes versions des navigateurs. <link rel=\"stylesheet\" href=\"style.css\"> <body> <div class=\"rouge\">Rouge</div> <div class=\"vert\">Vert</div> <div class=\"bleu\">Bleu</div> <script src=\"script.js\"></script> </body> .rouge, .vert, .bleu { width: 300px; height: 100px; color: white; font-size: 40px; text-align: center; } .rouge { background-color: red; } .vert { background-color: green; } .bleu { background-color: blue; } const rouge = document.querySelector(\".rouge\") const vert = document.querySelector(\".vert\") const bleu = document.querySelector(\".bleu\") document.body.insertBefore(bleu,vert) // ins\u00e8re l'\u00e9l\u00e9ment bleu avant l'\u00e9l\u00e9ment vert rouge.appendChild(bleu) // ajoute l'\u00e9l\u00e9ment bleu en tant qu'enfant de rouge document.body.replaceChild(bleu, rouge) // remplace l'\u00e9l\u00e9ment rouge par l'\u00e9l\u00e9ment bleu bleu.parentElement.removeChild(bleu) // permet de supprimer l'\u00e9l\u00e9ment bleu bleu.remove() // permet aussi de supprimer l'\u00e9l\u00e9ment bleu mais n'est pas support\u00e9 par les anciens navigateurs Cr\u00e9er des \u00e9l\u00e9ments Pour cr\u00e9er un \u00e9l\u00e9ment, on va utiliser la m\u00e9thode createElement() que l'on va ensuite ins\u00e9rer dans le DOM avec la m\u00e9thode appendChild() /* creation d'une classe CSS jaune que l'on va appliquer sur un \u00e9l\u00e9ment que l'on va cr\u00e9er en JS */ .jaune { width: 300px; height: 100px; color: white; font-size: 40px; text-align: center; background-color: yellow } const jaune = document.createElement(\"div\") //cr\u00e9ation d'un \u00e9l\u00e9ment div jaune.classList.add(\"jaune\") // application de la classe jaune sur la div jaune.textContent = \"Jaune\" // ajout du texte Jaune dans la div document.body.appendChild(jaune) // insertion de l'\u00e9l\u00e9ment jaune en tant qu'enfant du body Exemple de cr\u00e9ation d'une fonction qui cr\u00e9e des \u00e9l\u00e9ments que l'on va appeler plusieurs fois pour remplir une liste <body> <ul></ul> <script src=\"script.js\"></script> </body> function planifierTache(heure, tache){ const nouvelleTache = document.createElement(\"li\") nouvelleTache.innerHTML = `<h3>${heure}</h3><p>${tache}</p>` // innerHTML permet de dire le code HTML que l'on veut mettre \u00e0 l'int\u00e9rieur d'un \u00e9l\u00e9ment HTML document.querySelector(\"ul\").appendChild(nouvelleTache) } planifierTache('7h30', 'R\u00e9veil') planifierTache('7h40', 'Petit-d\u00e9jeuner') planifierTache('8h00', 'Douche') ---- Les \u00e9v\u00e9nements Javascript Qu'est-ce qu'un \u00e9v\u00e9nement ? Les \u00e9v\u00e9nements permettent de d\u00e9clencher une fonction selon qu'une action s'est produite ou non, par exemple faire appara\u00eetre une fen\u00eatre alert() au survol d'une zone d'un \u00e9l\u00e9ment. Ils sont de diff\u00e9rentes natures, par exemple : - cliquer sur un \u00e9l\u00e9ment - appuyer sur une touche du clavier - lorsque le navigateur a fini de charger la page Web Un \u00e9v\u00e9nement est bas\u00e9 sur l'interface Event , avec par exemple les classes MouseEvent et KeyboardEvent pour les \u00e9v\u00e9nements li\u00e9s \u00e0 la souris et au clavier. On-Event Handler <body> <div class=\"rouge\">Rouge</div> <div class=\"vert\">Vert</div> <div class=\"bleu\">Bleu</div> <script src=\"index.js\"></script> </body> console.log(rouge) // affiche <div class=\"rouge\">Rouge</div> console.log(rouge.parentElement.children) // affiche la collection HTML des \u00e9l\u00e9m\u00e9nts enfants du parent, dont rouge, pour lesquels on peut voir les propri\u00e9t\u00e9s et m\u00e9thodes Les propri\u00e9t\u00e9s qui commencent par on sont li\u00e9s aux \u00e9v\u00e9nements. Elles sont appel\u00e9es On-Event Handler , que l'on peut traduire par gestionnaire d'\u00e9v\u00e9nements . Par exemple, la propri\u00e9t\u00e9 onload g\u00e8re l'\u00e9v\u00e9nement load . L'\u00e9v\u00e9nement load se produit quand la page a fini de se charger : window.onload = function(){ console.log(\"la page est charg\u00e9e\") } console.log(\"apr\u00e8s le onload\") // s'affiche AVANT \"la page est charg\u00e9e\" On peut aussi d\u00e9clarer une fonction et l'appeler sur la propri\u00e9t\u00e9 onload : function windowReady(){ console.log(\"la page est charg\u00e9e\") } window.onload = windowReady() On peut encapsuler tout le code JS dans un windows.onload pour s'assurer que tous les \u00e9l\u00e9ments que l'on manipule sont charg\u00e9s : window.onload = function(){ const rouge = document.querySelector(\".rouge\") const vert = document.querySelector(\".vert\") const bleu = document.querySelector(\".bleu\") } Exemple de l'\u00e9v\u00e9nement clic, d\u00e9clench\u00e9 \u00e0 chaque clic sur l'\u00e9l\u00e9ment rouge : rouge.onclick = function(event){ console.log(\"clic sur la div rouge !\") console.log(event) } On peut r\u00e9cup\u00e9rer l'\u00e9v\u00e9nement en le passant en argument de la fonction en lui donnant le nom que l'on veut car le fait de mettre un argument \u00e0 la fonction nous donne forc\u00e9ment l'\u00e9v\u00e9nement. On peut \u00e9crire les Event Handler directement dans le code HTML, ce qui n'est pas conseill\u00e9 : <div class=\"vert\" onclick=\"console.log('toto')\">Vert</div> On ne peut pas d\u00e9finir plusieurs fois le m\u00eame event handler sur le m\u00eame \u00e9l\u00e9ment. Auquel cas, seul le dernier event handler va fonctionner car c'est une propri\u00e9t\u00e9 \u00e0 laquelle on attache une fonction, donc la derni\u00e8re a \u00e9cras\u00e9e les pr\u00e9c\u00e9dentes. rouge.onclick = function(event){ console.log(\"clic sur la div rouge !\") console.log(event) } rouge.onclick = function(){ console.log(\"deuxi\u00e8me message\") // seul ce message va s'afficher } Event Listener Un Event Listener , ou \u00e9couteur d'\u00e9v\u00e9nement en fran\u00e7ais, est une autre fa\u00e7on d'interagir avec les \u00e9v\u00e9nements. Il faut utiliser la m\u00e9thode addEventListener() qui prend en argument le nom de l'\u00e9v\u00e9nementet la fonction a ex\u00e9cuter : rouge.addEventListener(\"click\", function(event){ console.log(\"clic sur la div rouge !\") console.log(event) }) function afficherMessage(){ console.log(\"deuxi\u00e8me message\") } rouge.addEventListener(\"click\", afficherMessage) On peut ajouter plusieurs event listener sur le m\u00eame \u00e9v\u00e9nement et sur le m\u00eame \u00e9l\u00e9ment, ils seront tous ex\u00e9cut\u00e9s. On peut aussi d\u00e9clarer une fonction en externe et l'appeler dans le listener sans l'ex\u00e9cuter , juste en marquant son nom. La fonction anonyme en argument n'\u00e9tait pas \u00e9ex\u00e9cut\u00e9e non plus, le listeneur le fait quand l'\u00e9v\u00e9nement a lieu. On peut aussi supprimer un event listener avec removeEventListener() . Dans l'exemple suivant, quand on clique sur vert, on enl\u00e8ve le deuxi\u00e8me event listener de rouge, et quand on clique ensuite sur rouge, il n'y a plus que le premier qui s'ex\u00e9cute : vert.addEventListener(\"click\", function(){ rouge.removeEventListener(\"click\", afficherMessage) }) Propagation des \u00e9v\u00e9nements <div id=\"parent\"> <div id=\"enfant\"></div> </div> <script src=\"index.js\"></script> #parent { width: 300px; height: 300px; background-color: red; } #enfant { width: 100px; height: 100px; background-color: blue; } const parent = document.querySelector(\"#parent\") const enfant = document.querySelector(\"#enfant\") parent.addEventListener(\"click\", parentFonction) enfant.addEventListener(\"click\", enfantFonction) function enfantFonction(){ console.log(\"clic sur l'enfant\") } function parentFonction(){ console.log(\"clic sur le parent\") } Dans cet exemple, il y a une div bleu enfant contenu dans une div rouge rouge. Lorsqu'on clique sur la div parent, clic sur le parent s'\u00e9crit dans la log, et lorsqu'on clique sur la div enfant, clic sur l'enfant puis clic sur le parent s'affichent car l'enfant est contenu dans le parent. Les \u00e9v\u00e9nements sont faits de deix phases : - phase de capture : part des parents et va vers les enfants - phase de bouillonnement ( event bubbling ) : part de l'enfant et va vers les parents Par d\u00e9faut, addEventListener s'ex\u00e9cute pendant la phase de bouillenement (les \u00e9v\u00e9nements d\u00e9butent par les enfants et remontent vers les parents). Pour qu'elle s'ex\u00e9cute pendant la phase de capture, il faut ajouter un troi\u00e8me argument true \u00e0 la m\u00e9thode addEventListener . Dans l\"exemple suivant, lorsqu'on clique sur la div enfant, clic sur parent s'affiche donc avant clic sur enfant : parent.addEventListener(\"click\", parentFonction, true) enfant.addEventListener(\"click\", enfantFonction, true) Propri\u00e9t\u00e9s de l'objet Event Certaines propri\u00e9t\u00e9s sont communes \u00e0 tous les \u00e9v\u00e9nements, d'autres sont sp\u00e9cifiques \u00e0 certains \u00e9v\u00e9nement comme les \u00e9v\u00e9nements souris, ou les \u00e9v\u00e9nements claviers : function parentFonction(event){ console.log(\"clic sur le parent\") console.log(event) console.log(event.type) // affiche : click, correspond au type de l'\u00e9v\u00e9nement console.log(event.target) // affiche la div parent, correspond \u00e0 l'\u00e9l\u00e9ment qui a d\u00e9but\u00e9 l'\u00e9v\u00e9nement console.log(event.currentTarget) console.log(event.clientX) // affiche o\u00f9 l'on se place sur l'axe horizontale, propri\u00e9t\u00e9 sp\u00e9cifique au MouseEvent } M\u00e9thodes de l'objet Event La m\u00e9thode stopPropagation() permet de stopper la propagation d'un \u00e9v\u00e9nement. Dans l'exemple suivant, en cliquant sur l'enfant, on ne verra que le clic sur l'enfant mais pas le clic sur le parent. L'\u00e9v\u00e9nement a \u00e9t\u00e9 stopp\u00e9 et n'a donc pas atteint la div parent. function enfantFonction(event){ console.log(\"clic sur l'enfant\") event.stopPropagation() } La m\u00e9thode preventDefault() permet de ne pas traiter l'\u00e9v\u00e9nement avec son action par d\u00e9faut. Dans l'exemple suivant, lors de la soumission du formulaire, on \u00e9crit un message dans la log. Par d\u00e9faut, la soumission d'un formulaire rafra\u00eechit la page, le message dans la log dispara\u00eet donc aussit\u00f4t qu'il est apparu. Pour ne pas rafra\u00eechir la page, on peut utiliser la m\u00e9thode preventDefault() , le message restera alors affich\u00e9 dans la log. <body> <form> <input type=\"text\" placeholder=\"Votre nom\"> <button type=\"submit\">Envoyer</button> </form> <script src=\"index.js\"></script> </body> const form = document.querySelector(\"form\") form.addEventListener(\"submit\", envoyerFormulaire) function envoyerFormulaire(event){ event.preventDefault() console.log(\"Formulaire envoy\u00e9\") } ---- Requ\u00eates HTTP - Ajax Qu'est-ce qu'une requ\u00eate HTTP ? Ajax est un raccourci pour Asynchronous JavaScript and XML (XML et JavaScript asynchrones). Ajax permet d'\u00e9changer avec le serveur via des requ\u00eates HTTP sans rafra\u00eechir toute la page mais uniquement certains \u00e9l\u00e9ment de la page. Ces requ\u00eates fonctionnent de mani\u00e8re asynchrones, c'est-\u00e0-dire que l'on traitera la r\u00e9ponse quand elle arrive sans attendre qu'elle arrive, ce qui permet de continuer \u00e0 ex\u00e9cuter la suite du code. Requ\u00eates HTTP avec XMLHttpRequest XMLHttpRequest est l'objet qui permet de faire des requ\u00eates Ajax. C'est l'objet de base qui sert \u00e0 faire des requ\u00eates HTTP. D'autres objets se basent dessus. Lors d'une requ\u00eate HTTP, son \u00e9tat va varier, et nous pouvons r\u00e9cup\u00e9rer chaque changement de cet \u00e9tat, avec l'\u00e9v\u00e9nement onreadystatechange . L'\u00e9tat varie de 0 \u00e0 4. La requ\u00eate est termin\u00e9e \u00e0 l'\u00e9tat 4. Exemple avec l'API Jsonplaceholder sur l'URL /posts en GET : const req = new XMLHttpRequest() const method = 'GET' const url = 'https://jsonplaceholder.typicode.com/posts' req.onreadystatechange = function(event){ if(this.readyState === XMLHttpRequest.DONE){// on aurait pu \u00e9crire 4 \u00e0 la place, c'est pareil if(this.status === 200){ console.log( JSON.parse(this.responseText) ) } else { console.log(\"Statut Erreur : \"+this.status) } } } req.open(method, url) req.send() Exemple d'une requ\u00eate en POST : const req = new XMLHttpRequest() const method = 'POST' const url = 'https://jsonplaceholder.typicode.com/posts' const data = { body: \"la la la\", title: \"mon titre\", userId: 1 } req.onreadystatechange = function(event){ if(this.readyState === XMLHttpRequest.DONE){// on aurait pu \u00e9crire 4 \u00e0 la place, c'est pareil if(this.status === 201){ console.log( JSON.parse(this.responseText) ) } else { console.log(\"Statut Erreur : \"+this.status) } } } req.open(method, url) req.send(data) La m\u00e9thode open() prend en argument la m\u00e9thode HTTP puis l'url \u00e0 appeler. Il y a ensuite des arguments optionels : XMLHttpRequest.open(method, url, async, user, password) - async : \u00e0 true par d\u00e9faut. On peut le mettre \u00e0 false pour faire des requ\u00eates synchrones, ce qui est d\u00e9conseill\u00e9 - user et password sont null par d\u00e9faut et servent \u00e0 l'authentification","title":"Javascript d\u00e9barque dans le navigateur"},{"location":"javascript/javascriptDebarqueDansLeNavigateur/#javascript-debarque-dans-le-navigateur","text":"","title":"JavaScript d\u00e9barque dans le navigateur"},{"location":"javascript/javascriptDebarqueDansLeNavigateur/#-","text":"","title":"----"},{"location":"javascript/javascriptDebarqueDansLeNavigateur/#javascript-dans-le-navigateur","text":"","title":"JavaScript dans le navigateur"},{"location":"javascript/javascriptDebarqueDansLeNavigateur/#lobjet-window","text":"Lorsque JavaScript est ex\u00e9cut\u00e9 dans le navigateur, l'objet global est Window. Il repr\u00e9sente la fen\u00eatre du navigateur. Il poss\u00e8de des propri\u00e9t\u00e9s et des m\u00e9thodes. On peut y acc\u00e9der directement sans mettre le mot window car c'est l'objet global (il est dit implicite). // affiche la largeur du navigateur console.log(window.innerWidth) console.log(innerWidth) alert() n'est pas une fonction mais une m\u00e9thode de l'objet window. window.alert('Hello World') est \u00e9quivalent \u00e0 alert('Hello World') en revanche isNan() ou parseInt ne d\u00e9pendent pas d'un objet, ce sont des fonctions globales. Il n'y en a pas beaucoup lorsqu'on d\u00e9clare une variable dans le contexte global du script, cette variable devient une propri\u00e9t\u00e9 de l'objet window toute variable non d\u00e9clar\u00e9e (utilis\u00e9e sans \u00e9crire le mot-cl\u00e9 var) devient une propri\u00e9t\u00e9 de window, quelque soit l'endroit o\u00f9 on se situe. Ecrire text = 'toto' revient donc \u00e0 \u00e9crire window.text = 'toto'. Il est conseill\u00e9 de toujours d\u00e9clarer une variable avec var. Pour d\u00e9clarer une variable globale dans une fonction, on pourra sp\u00e9cifier explicitement l'objet window","title":"L'objet Window"},{"location":"javascript/javascriptDebarqueDansLeNavigateur/#lobjet-location","text":"C'est une propri\u00e9t\u00e9 de l'objet global Window. Il a lui-m\u00eame des propri\u00e9t\u00e9s et des m\u00e9thodes. Il contient des informations sur o\u00f9 se trouve notre navigateur (URL, etc...). location.reload() // relancer la page location.replace(\"URL\") // permet de change d'URL","title":"L'objet Location"},{"location":"javascript/javascriptDebarqueDansLeNavigateur/#lobjet-document-le-dom","text":"C'est une propri\u00e9t\u00e9 de l'objet Window. C'est la repr\u00e9sentation de notre page HTML, plus pr\u00e9cisemment la la balise <html> . Avec JavaScript, on va manipuler le DOM. On peut voir les propri\u00e9t\u00e9s de l'objet document avec la commande console.log(window) et le contenu de l'objet document avec la commande console.log(window.document) . Le document a des propri\u00e9t\u00e9s que l'on peut modifier, ajouter, d\u00e9placer, supprimer. Par exemple le titre de la page : console.log(document.title) // affiche : JavaScript (titre pr\u00e9sent dans la page HTML) document.title = \"Mon nouveau titre\" console.log(document.title) // affiche : Mon nouveau titre console.log(document.body) // affiche le body","title":"L'objet Document : le DOM"},{"location":"javascript/javascriptDebarqueDansLeNavigateur/#petit-historique","text":"Le DOM est une interface de programmation pour les documents XML et HTML, qui permet via le JavaScript d'acc\u00e9der au code XML et/ou HTML d'un document. On peut modifier, ajouter, d\u00e9placer, supprimer des \u00e9l\u00e9ments HTML (une paire de balises HTML) Au d\u00e9but du JavaScript, le DOM n'\u00e9tait pas unifi\u00e9, c'est-\u00e0-dire que deux navigateurs poss\u00e9daient un DOM diff\u00e9rent, donc la mani\u00e8re d'acc\u00e9der \u00e0 un \u00e9l\u00e9ment HTML diff\u00e9rait d'un navigateur \u00e0 l'autre. Il fallait donc coder diff\u00e9remment en fonction du navigateur. Le W3C a publi\u00e9 une nouvelle sp\u00e9cification DOM-1, pour DOM Level 1 qui d\u00e9finit le DOM et comment sont sch\u00e9matis\u00e9s les documents HTML et XML, sous forme d'un arbre, ou d'une hi\u00e9rarchie. L'\u00e9l\u00e9ment contient 2 \u00e9l\u00e9ments enfants : et , etc... Ensuite, la sp\u00e9cification DOM-2 a \u00e9t\u00e9 publi\u00e9 avec l'introduction de la m\u00e9thode getElementById() qui permet de r\u00e9cup\u00e9rer un \u00e9l\u00e9ment en connaissant son ID.","title":"Petit historique"},{"location":"javascript/javascriptDebarqueDansLeNavigateur/#la-structure-dom","text":"Le DOM pose comme concept que la page Web est une hi\u00e9rarchie d'\u00e9l\u00e9ments. On peut sch\u00e9matiser une page web comme ceci : Voici le code source correspondant : <!doctype html> <html> <head> <meta charset=\"utf-8\" /> <title>Le titre de la page</title> </head> <body> <div> <p>Du texte <a>et un lien</a></p> </div> </body> </html> L'\u00e9l\u00e9ment <html> contient deux \u00e9l\u00e9ments, appel\u00e9s enfants : <head> et <body> . Pour ces deux enfants, <html> est l'\u00e9l\u00e9ment parent . Chaque \u00e9l\u00e9ment est appel\u00e9 noeud ( node en anglais). <title> contient un \u00e9l\u00e9ment enfant #text qui contient du texte. Le texte pr\u00e9sent dans une page Web est vu par le DOM comme on noeud de type #text .","title":"La structure DOM"},{"location":"javascript/javascriptDebarqueDansLeNavigateur/#-_1","text":"","title":"----"},{"location":"javascript/javascriptDebarqueDansLeNavigateur/#javascript-et-le-dom","text":"","title":"JavaScript et le DOM"},{"location":"javascript/javascriptDebarqueDansLeNavigateur/#lheritage-des-proprietes-et-des-methodes","text":"Les \u00e9l\u00e9ments HTML sont vus par JavaScript comme des objets poss\u00e9dant des propri\u00e9t\u00e9s et des m\u00e9thodes. Tous ne poss\u00e8dent pas les m\u00eames propri\u00e9t\u00e9s et m\u00e9thodes. Certaines sont communes car tous les \u00e9l\u00e9ments HTML sont d'un m\u00eame type : Node. Une est un objet HTTMLDivElement, sous-objet HTMLElement, lui-m\u00eame sous-objet d'Element, lui-m\u00eame sous-objet de Node. Les m\u00e9thodes et propri\u00e9t\u00e9s de Node peuvent \u00eatre utilis\u00e9es depuis ses sous-objets gr\u00e2ce \u00e0 l'h\u00e9ritage.","title":"L'h\u00e9ritage des propri\u00e9t\u00e9s et des m\u00e9thodes"},{"location":"javascript/javascriptDebarqueDansLeNavigateur/#hierarchie-des-elements","text":"children renvoie une HTML Collection (un peu comme un tableau) des enfants de l'\u00e9l\u00e9ment firstElementChild et lastElementChild renvoient le premier et le dernier enfant de l'\u00e9l\u00e9ment nextElementSibling renvoie le prochain \u00e9l\u00e9ment de m\u00eame niveau parentElement renvoie l'\u00e9l\u00e9ment parent <body> <div> <p>Mon paragraphe 1</p> <p>Mon paragraphe 2</p> </div> <script src=\"script.js\"></script> </body> console.log(document.body.children) // [div, script] console.log(document.body.children[0].children) // [p, p] console.log(document.body.firstElementChild) // \u00e9quivalent \u00e0 children[0], retourne la div console.log(document.body.children[0].nextElementSibling) // affiche le script console.log(document.body.children[0].parentElement) // affiche le body","title":"Hi\u00e9rarchie des \u00e9l\u00e9ments"},{"location":"javascript/javascriptDebarqueDansLeNavigateur/#recuperer-et-modifier-les-elements","text":"Un console.log() d'un \u00e9l\u00e9ment du DOM affiche la repr\u00e9sentation HTML de l'\u00e9l\u00e9ment, mais on ne voit pas ses propri\u00e9t\u00e9s. Pour voir les propri\u00e9t\u00e9s et m\u00e9thodes d'un \u00e9l\u00e9ment, il faut afficher tous les enfants de l'\u00e9l\u00e9ment parent et cliquer sur l'\u00e9l\u00e9ment enfant qui nous int\u00e9resse dans la console. console.log(document.body.children[0].children[1]) // affiche <p>Mon paragraphe 2</p> console.log(document.body.children[0].children) // affiche l'HTML Collection avec ses 2 enfants. On peut cliquer sur chaque enfant pour voir ses attributs et m\u00e9thodes","title":"R\u00e9cup\u00e9rer et modifier les \u00e9l\u00e9ments"},{"location":"javascript/javascriptDebarqueDansLeNavigateur/#le-contenu-innerhtml","text":"innerHTML permet de r\u00e9cup\u00e9rer le code HTML enfant d'un \u00e9l\u00e9ment sous forme de texte. Si les balises sont pr\u00e9sentes, innerHTML les retournera sous forme de texte. Exemple : <body> <div id=\"myDiv\"> <p>Un peu de texte <a>et un lien</a></p> </div> <script> const div = document.getElementById('myDiv') console.log(div.innerHTML) // affiche : <p>Un peu de texte <a>et un lien</a></p> </script> </body> Autre exemple o\u00f9 l'on va modifier le contenu du paragraphe : console.log(document.body.children[0].children[0].innerHTML) // affiche Un peu de texte <a>et un lien</a> document.body.children[0].children[0].innerHTML = \"<strong>Nouveau Texte</strong>\" console.log(document.body.children[0].children[0].innerHTML) // affiche Nouveau Texte (en gras car les les balises strong sont interpr\u00e9t\u00e9es par le navigateur pour mettre le texte en gras) Il est aussi possible d'ajouter ou d'\u00e9diter du HTML document.getElementById('myDiv').innerHTML = '<blockquote>Je mets une citation \u00e0 la place du paragraphe</blockquote>' document.getElementById('myDiv').innerHTML += ' et <strong>une portion mise en emphase</strong>.' Il ne faut pas l'utiliser dans une boucle car innerHTML ralentit l'ex\u00e9cution du code. Il vaut mieux la concat\u00e9ner dans une variable et ensuite ajouter le tout via innerHTML .","title":"Le contenu : innerHTML"},{"location":"javascript/javascriptDebarqueDansLeNavigateur/#innertext-et-textcontent","text":"innerText pour IE et textContent pour les autres navigateurs sont des propri\u00e9t\u00e9s analogues \u00e0 innerHTML , qui permettent de r\u00e9cup\u00e9rer le contenu d'un \u00e9l\u00e9ment sous forme de texte mais sans les balises , et permet aussi de modifier le contenu de l'\u00e9l\u00e9ment. - innerText a \u00e9t\u00e9 introduite dans IE, mais jamais standardis\u00e9e et n'est pas suport\u00e9e par tous les navigateurs - textContent est la version standardis\u00e9e d' innerText . Elle est reconnue par tous les navigateurs \u00e0 l'exception des versions ant\u00e9rieures \u00e0 IE9. console.log(document.body.children[0].children[0].textContent) // affiche Un peu de texte et un lien document.body.children[0].children[0].textContent = \"<strong>Nouveau Texte</strong>\" // les balises ne sont pas interpr\u00e9t\u00e9s par le navigateur mais \u00e9crites comme du texte affich\u00e9 dans le navigateur console.log(document.body.children[0].children[0].textContent) // affiche <strong>Nouveau Texte</strong>","title":"innerText et textContent"},{"location":"javascript/javascriptDebarqueDansLeNavigateur/#modifier-le-style","text":"La propri\u00e9t\u00e9 style permet de modifier le style CSS des \u00e9l\u00e9ments. Les types correspondent au CSS sauf qu'il faut les \u00e9crire en kamel case. Par exemple \u00e9crire backgroundColor en JavaScript au lieu de background-color en CSS. document.body.children[0].style.backgroundColor = \"red\" // mais le fond de la div en rouge","title":"Modifier le style"},{"location":"javascript/javascriptDebarqueDansLeNavigateur/#modifier-les-classes-css","text":"<body> <div class=\"super\"> <p>Mon paragraphe 1</p> <p>Mon paragraphe 2</p> </div> <script src=\"script.js\"></script> </body> classList permet d'avoir la liste des classes CSS que poss\u00e8de un \u00e9l\u00e9ment. Les m\u00e9thodes add() et remove() permettent d'ajouter et d'enlever des classes CSS. toggle() permet d'enlever la classe si elle pr\u00e9sente et de l'ajouter si elle n'y est pas. console.log(document.body.children[0].classList) // affiche [\"super\"] document.body.children[0].classList.add(\"toto\") // ajoute la classe toto \u00e0 la div et applique son style console.log(document.body.children[0].classList) // affiche [\"super\", \"toto\"] document.body.children[0].classList.remove(\"toto\") // enl\u00e8ve la classe toto de la div et enl\u00e8ve son style console.log(document.body.children[0].classList) // affiche [\"super\"] document.body.children[0].classList.toggle(\"toto\") console.log(document.body.children[0].classList) // affiche [\"super\", \"toto\"] document.body.children[0].classList.toggle(\"toto\") console.log(document.body.children[0].classList) // affiche [\"super\"] On peut aussi utiliser className pour appliquer une classe CSS \u00e0 un \u00e9l\u00e9ment : document.getElementById('p1').className = 'bleu'","title":"Modifier les classes CSS"},{"location":"javascript/javascriptDebarqueDansLeNavigateur/#modifier-les-attributs","text":"Un attribut correspond aux informations pr\u00e9sentes dans une balise, par exemple src dans la balise script : <script src=\"index.js\"></script> . Les m\u00e9thodes getAttribute() et setAttribute() permettent de r\u00e9cup\u00e9rer et modifier un attribut d'un \u00e9l\u00e9ment HTML. console.log(document.body.children[1].getAttribute(\"src\")) // affiche index.js document.body.children[1].setAttribute(\"src\", \"toto.js\") // modifie la valeur de l'attribut renseign\u00e9e console.log(document.body.children[1].getAttribute(\"src\")) // affiche toto.js","title":"Modifier les attributs"},{"location":"javascript/javascriptDebarqueDansLeNavigateur/#selectionner-les-elements","text":"Pour s\u00e9lectionner un \u00e9l\u00e9ment, on peut le faire plus simplement qu'en partant de body et en descendant avec children . La m\u00e9thode getElementById() de l'objet document permet de s\u00e9lectionner un \u00e9l\u00e9ment par son id, getElementsByTagName() s\u00e9lectionne les \u00e9l\u00e9ments qui correspondent \u00e0 un tag HTML, par exemple h1 ou p , et getElementsByClassName() s\u00e9lectionne les \u00e9l\u00e9ments qui correspondent \u00e0 une classe CSS. On peut aussi stocker les \u00e9l\u00e9ments dans une variable. <body> <div class=\"super\"> <h1 id=\"titre\">Mon Titre</h1> <p class=\"maClasse\">Mon paragraphe 1</p> <p>Mon paragraphe 2</p> </div> <script src=\"script.js\"></script> </body> console.log(document.getElementById(\"titre\")) // affiche <h1 id=\"titre\">Mon Titre</h1> console.log(document.getElementsByTagName(\"p\")) // affiche une HTML Collection avec les 2 paragraphes console.log(document.getElementsByClassName(\"maClasse\")) // affiche une HTML Collection avec l'\u00e9l\u00e9ment qui a cette classe const monTitre = document.getElementById(\"titre\") console.log(monTitre) // affiche <h1 id=\"titre\">Mon Titre</h1>","title":"S\u00e9lectionner les \u00e9l\u00e9ments"},{"location":"javascript/javascriptDebarqueDansLeNavigateur/#selectionner-avec-query-selector","text":"La m\u00e9thode querySelector() permet d'utiliser les s\u00e9lecteurs CSS pour s\u00e9lectionner un \u00e9l\u00e9ment. Si plusieurs \u00e9l\u00e9ments correspondent, seul le premier \u00e9l\u00e9ment sera s\u00e9lectionn\u00e9. La m\u00e9thode querySelectorAll() renvoie une liste, et permet donc de s\u00e9lectionner plusieurs \u00e9l\u00e9ments. console.log(document.querySelector(\".maClasse\")) // affiche <p class=\"maClasse\">Mon paragraphe 1</p> console.log(document.querySelectorAll(\".maClasse\")) // affiche une NodeList d'un \u00e9l\u00e9ment avec le paragraphe 1 console.log(document.querySelector(\"p\")) // affiche <p class=\"maClasse\">Mon paragraphe 1</p> (le 1er paragraphe rencontr\u00e9) console.log(document.querySelectorAll(\"p\")) // affiche une NodeList de deux \u00e9l\u00e9ments avec les paragraphes","title":"S\u00e9lectionner avec Query Selector"},{"location":"javascript/javascriptDebarqueDansLeNavigateur/#modifier-lordre-des-elements","text":"La m\u00e9thode insertBefore() permet d'ins\u00e9rer un \u00e9l\u00e9ment HTML avant un autre \u00e9l\u00e9ment. Si l'\u00e9l\u00e9ment existe d\u00e9j\u00e0, il est d'abord supprim\u00e9 avant d'\u00eatre replac\u00e9. La m\u00e9thode appendChild() permet d'ajouter un \u00e9l\u00e9ment \u00e0 un autre \u00e9l\u00e9ment en tant qu'enfant. La m\u00e9thode replaceChild() permet de remplacer un \u00e9l\u00e9ment enfant par un autre. La m\u00e9thode removeChild() permet de supprimer un \u00e9l\u00e9ment, remove() le permet aussi de mani\u00e8re plus simple mais n'est pas support\u00e9 par les anciennes versions des navigateurs. <link rel=\"stylesheet\" href=\"style.css\"> <body> <div class=\"rouge\">Rouge</div> <div class=\"vert\">Vert</div> <div class=\"bleu\">Bleu</div> <script src=\"script.js\"></script> </body> .rouge, .vert, .bleu { width: 300px; height: 100px; color: white; font-size: 40px; text-align: center; } .rouge { background-color: red; } .vert { background-color: green; } .bleu { background-color: blue; } const rouge = document.querySelector(\".rouge\") const vert = document.querySelector(\".vert\") const bleu = document.querySelector(\".bleu\") document.body.insertBefore(bleu,vert) // ins\u00e8re l'\u00e9l\u00e9ment bleu avant l'\u00e9l\u00e9ment vert rouge.appendChild(bleu) // ajoute l'\u00e9l\u00e9ment bleu en tant qu'enfant de rouge document.body.replaceChild(bleu, rouge) // remplace l'\u00e9l\u00e9ment rouge par l'\u00e9l\u00e9ment bleu bleu.parentElement.removeChild(bleu) // permet de supprimer l'\u00e9l\u00e9ment bleu bleu.remove() // permet aussi de supprimer l'\u00e9l\u00e9ment bleu mais n'est pas support\u00e9 par les anciens navigateurs","title":"Modifier l'ordre des \u00e9l\u00e9ments"},{"location":"javascript/javascriptDebarqueDansLeNavigateur/#creer-des-elements","text":"Pour cr\u00e9er un \u00e9l\u00e9ment, on va utiliser la m\u00e9thode createElement() que l'on va ensuite ins\u00e9rer dans le DOM avec la m\u00e9thode appendChild() /* creation d'une classe CSS jaune que l'on va appliquer sur un \u00e9l\u00e9ment que l'on va cr\u00e9er en JS */ .jaune { width: 300px; height: 100px; color: white; font-size: 40px; text-align: center; background-color: yellow } const jaune = document.createElement(\"div\") //cr\u00e9ation d'un \u00e9l\u00e9ment div jaune.classList.add(\"jaune\") // application de la classe jaune sur la div jaune.textContent = \"Jaune\" // ajout du texte Jaune dans la div document.body.appendChild(jaune) // insertion de l'\u00e9l\u00e9ment jaune en tant qu'enfant du body Exemple de cr\u00e9ation d'une fonction qui cr\u00e9e des \u00e9l\u00e9ments que l'on va appeler plusieurs fois pour remplir une liste <body> <ul></ul> <script src=\"script.js\"></script> </body> function planifierTache(heure, tache){ const nouvelleTache = document.createElement(\"li\") nouvelleTache.innerHTML = `<h3>${heure}</h3><p>${tache}</p>` // innerHTML permet de dire le code HTML que l'on veut mettre \u00e0 l'int\u00e9rieur d'un \u00e9l\u00e9ment HTML document.querySelector(\"ul\").appendChild(nouvelleTache) } planifierTache('7h30', 'R\u00e9veil') planifierTache('7h40', 'Petit-d\u00e9jeuner') planifierTache('8h00', 'Douche')","title":"Cr\u00e9er des \u00e9l\u00e9ments"},{"location":"javascript/javascriptDebarqueDansLeNavigateur/#-_2","text":"","title":"----"},{"location":"javascript/javascriptDebarqueDansLeNavigateur/#les-evenements-javascript","text":"","title":"Les \u00e9v\u00e9nements Javascript"},{"location":"javascript/javascriptDebarqueDansLeNavigateur/#quest-ce-quun-evenement","text":"Les \u00e9v\u00e9nements permettent de d\u00e9clencher une fonction selon qu'une action s'est produite ou non, par exemple faire appara\u00eetre une fen\u00eatre alert() au survol d'une zone d'un \u00e9l\u00e9ment. Ils sont de diff\u00e9rentes natures, par exemple : - cliquer sur un \u00e9l\u00e9ment - appuyer sur une touche du clavier - lorsque le navigateur a fini de charger la page Web Un \u00e9v\u00e9nement est bas\u00e9 sur l'interface Event , avec par exemple les classes MouseEvent et KeyboardEvent pour les \u00e9v\u00e9nements li\u00e9s \u00e0 la souris et au clavier.","title":"Qu'est-ce qu'un \u00e9v\u00e9nement ?"},{"location":"javascript/javascriptDebarqueDansLeNavigateur/#on-event-handler","text":"<body> <div class=\"rouge\">Rouge</div> <div class=\"vert\">Vert</div> <div class=\"bleu\">Bleu</div> <script src=\"index.js\"></script> </body> console.log(rouge) // affiche <div class=\"rouge\">Rouge</div> console.log(rouge.parentElement.children) // affiche la collection HTML des \u00e9l\u00e9m\u00e9nts enfants du parent, dont rouge, pour lesquels on peut voir les propri\u00e9t\u00e9s et m\u00e9thodes Les propri\u00e9t\u00e9s qui commencent par on sont li\u00e9s aux \u00e9v\u00e9nements. Elles sont appel\u00e9es On-Event Handler , que l'on peut traduire par gestionnaire d'\u00e9v\u00e9nements . Par exemple, la propri\u00e9t\u00e9 onload g\u00e8re l'\u00e9v\u00e9nement load . L'\u00e9v\u00e9nement load se produit quand la page a fini de se charger : window.onload = function(){ console.log(\"la page est charg\u00e9e\") } console.log(\"apr\u00e8s le onload\") // s'affiche AVANT \"la page est charg\u00e9e\" On peut aussi d\u00e9clarer une fonction et l'appeler sur la propri\u00e9t\u00e9 onload : function windowReady(){ console.log(\"la page est charg\u00e9e\") } window.onload = windowReady() On peut encapsuler tout le code JS dans un windows.onload pour s'assurer que tous les \u00e9l\u00e9ments que l'on manipule sont charg\u00e9s : window.onload = function(){ const rouge = document.querySelector(\".rouge\") const vert = document.querySelector(\".vert\") const bleu = document.querySelector(\".bleu\") } Exemple de l'\u00e9v\u00e9nement clic, d\u00e9clench\u00e9 \u00e0 chaque clic sur l'\u00e9l\u00e9ment rouge : rouge.onclick = function(event){ console.log(\"clic sur la div rouge !\") console.log(event) } On peut r\u00e9cup\u00e9rer l'\u00e9v\u00e9nement en le passant en argument de la fonction en lui donnant le nom que l'on veut car le fait de mettre un argument \u00e0 la fonction nous donne forc\u00e9ment l'\u00e9v\u00e9nement. On peut \u00e9crire les Event Handler directement dans le code HTML, ce qui n'est pas conseill\u00e9 : <div class=\"vert\" onclick=\"console.log('toto')\">Vert</div> On ne peut pas d\u00e9finir plusieurs fois le m\u00eame event handler sur le m\u00eame \u00e9l\u00e9ment. Auquel cas, seul le dernier event handler va fonctionner car c'est une propri\u00e9t\u00e9 \u00e0 laquelle on attache une fonction, donc la derni\u00e8re a \u00e9cras\u00e9e les pr\u00e9c\u00e9dentes. rouge.onclick = function(event){ console.log(\"clic sur la div rouge !\") console.log(event) } rouge.onclick = function(){ console.log(\"deuxi\u00e8me message\") // seul ce message va s'afficher }","title":"On-Event Handler"},{"location":"javascript/javascriptDebarqueDansLeNavigateur/#event-listener","text":"Un Event Listener , ou \u00e9couteur d'\u00e9v\u00e9nement en fran\u00e7ais, est une autre fa\u00e7on d'interagir avec les \u00e9v\u00e9nements. Il faut utiliser la m\u00e9thode addEventListener() qui prend en argument le nom de l'\u00e9v\u00e9nementet la fonction a ex\u00e9cuter : rouge.addEventListener(\"click\", function(event){ console.log(\"clic sur la div rouge !\") console.log(event) }) function afficherMessage(){ console.log(\"deuxi\u00e8me message\") } rouge.addEventListener(\"click\", afficherMessage) On peut ajouter plusieurs event listener sur le m\u00eame \u00e9v\u00e9nement et sur le m\u00eame \u00e9l\u00e9ment, ils seront tous ex\u00e9cut\u00e9s. On peut aussi d\u00e9clarer une fonction en externe et l'appeler dans le listener sans l'ex\u00e9cuter , juste en marquant son nom. La fonction anonyme en argument n'\u00e9tait pas \u00e9ex\u00e9cut\u00e9e non plus, le listeneur le fait quand l'\u00e9v\u00e9nement a lieu. On peut aussi supprimer un event listener avec removeEventListener() . Dans l'exemple suivant, quand on clique sur vert, on enl\u00e8ve le deuxi\u00e8me event listener de rouge, et quand on clique ensuite sur rouge, il n'y a plus que le premier qui s'ex\u00e9cute : vert.addEventListener(\"click\", function(){ rouge.removeEventListener(\"click\", afficherMessage) })","title":"Event Listener"},{"location":"javascript/javascriptDebarqueDansLeNavigateur/#propagation-des-evenements","text":"<div id=\"parent\"> <div id=\"enfant\"></div> </div> <script src=\"index.js\"></script> #parent { width: 300px; height: 300px; background-color: red; } #enfant { width: 100px; height: 100px; background-color: blue; } const parent = document.querySelector(\"#parent\") const enfant = document.querySelector(\"#enfant\") parent.addEventListener(\"click\", parentFonction) enfant.addEventListener(\"click\", enfantFonction) function enfantFonction(){ console.log(\"clic sur l'enfant\") } function parentFonction(){ console.log(\"clic sur le parent\") } Dans cet exemple, il y a une div bleu enfant contenu dans une div rouge rouge. Lorsqu'on clique sur la div parent, clic sur le parent s'\u00e9crit dans la log, et lorsqu'on clique sur la div enfant, clic sur l'enfant puis clic sur le parent s'affichent car l'enfant est contenu dans le parent. Les \u00e9v\u00e9nements sont faits de deix phases : - phase de capture : part des parents et va vers les enfants - phase de bouillonnement ( event bubbling ) : part de l'enfant et va vers les parents Par d\u00e9faut, addEventListener s'ex\u00e9cute pendant la phase de bouillenement (les \u00e9v\u00e9nements d\u00e9butent par les enfants et remontent vers les parents). Pour qu'elle s'ex\u00e9cute pendant la phase de capture, il faut ajouter un troi\u00e8me argument true \u00e0 la m\u00e9thode addEventListener . Dans l\"exemple suivant, lorsqu'on clique sur la div enfant, clic sur parent s'affiche donc avant clic sur enfant : parent.addEventListener(\"click\", parentFonction, true) enfant.addEventListener(\"click\", enfantFonction, true)","title":"Propagation des \u00e9v\u00e9nements"},{"location":"javascript/javascriptDebarqueDansLeNavigateur/#proprietes-de-lobjet-event","text":"Certaines propri\u00e9t\u00e9s sont communes \u00e0 tous les \u00e9v\u00e9nements, d'autres sont sp\u00e9cifiques \u00e0 certains \u00e9v\u00e9nement comme les \u00e9v\u00e9nements souris, ou les \u00e9v\u00e9nements claviers : function parentFonction(event){ console.log(\"clic sur le parent\") console.log(event) console.log(event.type) // affiche : click, correspond au type de l'\u00e9v\u00e9nement console.log(event.target) // affiche la div parent, correspond \u00e0 l'\u00e9l\u00e9ment qui a d\u00e9but\u00e9 l'\u00e9v\u00e9nement console.log(event.currentTarget) console.log(event.clientX) // affiche o\u00f9 l'on se place sur l'axe horizontale, propri\u00e9t\u00e9 sp\u00e9cifique au MouseEvent }","title":"Propri\u00e9t\u00e9s de l'objet Event"},{"location":"javascript/javascriptDebarqueDansLeNavigateur/#methodes-de-lobjet-event","text":"La m\u00e9thode stopPropagation() permet de stopper la propagation d'un \u00e9v\u00e9nement. Dans l'exemple suivant, en cliquant sur l'enfant, on ne verra que le clic sur l'enfant mais pas le clic sur le parent. L'\u00e9v\u00e9nement a \u00e9t\u00e9 stopp\u00e9 et n'a donc pas atteint la div parent. function enfantFonction(event){ console.log(\"clic sur l'enfant\") event.stopPropagation() } La m\u00e9thode preventDefault() permet de ne pas traiter l'\u00e9v\u00e9nement avec son action par d\u00e9faut. Dans l'exemple suivant, lors de la soumission du formulaire, on \u00e9crit un message dans la log. Par d\u00e9faut, la soumission d'un formulaire rafra\u00eechit la page, le message dans la log dispara\u00eet donc aussit\u00f4t qu'il est apparu. Pour ne pas rafra\u00eechir la page, on peut utiliser la m\u00e9thode preventDefault() , le message restera alors affich\u00e9 dans la log. <body> <form> <input type=\"text\" placeholder=\"Votre nom\"> <button type=\"submit\">Envoyer</button> </form> <script src=\"index.js\"></script> </body> const form = document.querySelector(\"form\") form.addEventListener(\"submit\", envoyerFormulaire) function envoyerFormulaire(event){ event.preventDefault() console.log(\"Formulaire envoy\u00e9\") }","title":"M\u00e9thodes de l'objet Event"},{"location":"javascript/javascriptDebarqueDansLeNavigateur/#-_3","text":"","title":"----"},{"location":"javascript/javascriptDebarqueDansLeNavigateur/#requetes-http-ajax","text":"","title":"Requ\u00eates HTTP - Ajax"},{"location":"javascript/javascriptDebarqueDansLeNavigateur/#quest-ce-quune-requete-http","text":"Ajax est un raccourci pour Asynchronous JavaScript and XML (XML et JavaScript asynchrones). Ajax permet d'\u00e9changer avec le serveur via des requ\u00eates HTTP sans rafra\u00eechir toute la page mais uniquement certains \u00e9l\u00e9ment de la page. Ces requ\u00eates fonctionnent de mani\u00e8re asynchrones, c'est-\u00e0-dire que l'on traitera la r\u00e9ponse quand elle arrive sans attendre qu'elle arrive, ce qui permet de continuer \u00e0 ex\u00e9cuter la suite du code.","title":"Qu'est-ce qu'une requ\u00eate HTTP ?"},{"location":"javascript/javascriptDebarqueDansLeNavigateur/#requetes-http-avec-xmlhttprequest","text":"XMLHttpRequest est l'objet qui permet de faire des requ\u00eates Ajax. C'est l'objet de base qui sert \u00e0 faire des requ\u00eates HTTP. D'autres objets se basent dessus. Lors d'une requ\u00eate HTTP, son \u00e9tat va varier, et nous pouvons r\u00e9cup\u00e9rer chaque changement de cet \u00e9tat, avec l'\u00e9v\u00e9nement onreadystatechange . L'\u00e9tat varie de 0 \u00e0 4. La requ\u00eate est termin\u00e9e \u00e0 l'\u00e9tat 4. Exemple avec l'API Jsonplaceholder sur l'URL /posts en GET : const req = new XMLHttpRequest() const method = 'GET' const url = 'https://jsonplaceholder.typicode.com/posts' req.onreadystatechange = function(event){ if(this.readyState === XMLHttpRequest.DONE){// on aurait pu \u00e9crire 4 \u00e0 la place, c'est pareil if(this.status === 200){ console.log( JSON.parse(this.responseText) ) } else { console.log(\"Statut Erreur : \"+this.status) } } } req.open(method, url) req.send() Exemple d'une requ\u00eate en POST : const req = new XMLHttpRequest() const method = 'POST' const url = 'https://jsonplaceholder.typicode.com/posts' const data = { body: \"la la la\", title: \"mon titre\", userId: 1 } req.onreadystatechange = function(event){ if(this.readyState === XMLHttpRequest.DONE){// on aurait pu \u00e9crire 4 \u00e0 la place, c'est pareil if(this.status === 201){ console.log( JSON.parse(this.responseText) ) } else { console.log(\"Statut Erreur : \"+this.status) } } } req.open(method, url) req.send(data) La m\u00e9thode open() prend en argument la m\u00e9thode HTTP puis l'url \u00e0 appeler. Il y a ensuite des arguments optionels : XMLHttpRequest.open(method, url, async, user, password) - async : \u00e0 true par d\u00e9faut. On peut le mettre \u00e0 false pour faire des requ\u00eates synchrones, ce qui est d\u00e9conseill\u00e9 - user et password sont null par d\u00e9faut et servent \u00e0 l'authentification","title":"Requ\u00eates HTTP avec XMLHttpRequest"},{"location":"javascript/lesBasesDeJavaScript/","text":"Les bases de JavaScript ---- Introduction Qu\u2019est que le JavaScript ? Le JavaScript est un langage de programmation de scripts orient\u00e9 objet Un langage de programmation permet d\u2019\u00e9crire du code source qui sera analys\u00e9 par l\u2019ordinateur. Il existe trois mani\u00e8res d\u2019utiliser du code source : - langage compil\u00e9 : le code source est donn\u00e9 \u00e0 un programme appel\u00e9 compilateur qui va lire le code source et le convertir dans un langage que l\u2019ordinateur sera capable d\u2019interpr\u00e9ter : le langage binaire. Les langages comme le C ou le C++ sont des langages dits compil\u00e9s - langage pr\u00e9compil\u00e9 : le code source est partiellement compil\u00e9, dans un langage plus simple \u00e0 lire par l\u2019ordinateur mais ce n\u2019est pas encore du binaire. Ce code interm\u00e9diaire devra \u00eatre lu par une machine virtuelle qui ex\u00e9cutera ce code. Les langages comme Java ou C# sont dits pr\u00e9compil\u00e9s - langage interpr\u00e9t\u00e9 : pas de compilation, le code source reste tel quel. Pour ex\u00e9cuter le code, on doit le fournir \u00e0 un interpr\u00e9teur qui lira le code et r\u00e9alisera les actions. Pour obtenir des gains de performances, on peut le le compiler \u00e0 la vol\u00e9e pendant son ex\u00e9cution, ce que font aujourd\u2019hui la plupart des interpr\u00e9teurs JavaScript Les scripts sont majoritairement interpr\u00e9t\u00e9s, ce qui est le cas de JavaScript qui est un langage interpr\u00e9t\u00e9. Il y a un interpr\u00e9teur JavaScript dans le navigateur Web, qui est diff\u00e9rent selon le navigateur : Chakra dans Internet Explorer, SpiderMonkey dans Firefox, V8 dans Chrome. Le JavaScript est majoritairement utilis\u00e9 sur les pages Web pour dynamiser les pages HTML, en ajoutant des interactions avec l\u2019utilisateur, des animations, de l\u2019aide \u00e0 la navigation, par exemple : afficher ou masquer du texte, faire d\u00e9filer des images, cr\u00e9er des infobulles\u2026 Les scripts JavaScript sont ex\u00e9cut\u00e9s par le navigateur chez l\u2019internaute (le client), contrairement aux langages serveur (comme le PHP) ex\u00e9cut\u00e9 par le serveur web. Un script serveur va s\u2019occuper de cr\u00e9er la page Web qui sera envoy\u00e9 au navigateur. Ce dernier va alors afficher la page puis ex\u00e9cuter les scripts client tel que le JavaScript. Le JavaScript ne sert pas que dans les pages Web. Il sert aussi \u00e0 r\u00e9aliser des extensions pour des programmes. Chrome et Firefox en poss\u00e8dent tous deux un panel gigantesque en partie cod\u00e9es en JavaSript. Il est aussi possible d\u2019ex\u00e9cuter du JavaScript en dehors du navigateur. Le JavaScript peut aussi \u00eatre utilis\u00e9 pour r\u00e9aliser des applications. Petit historique du langage En 1995, Brendan Eich d\u00e9veloppe le LiveScript qui sera renomm\u00e9 en JavaScript en hommage au langage Java. Netscape d\u00e9cide d\u2019envoyer sa version de JavaScript \u00e0 l\u2019ECMA international pour que le langage soit standardis\u00e9. L\u2019ECMA standardise le langage soit le nom d\u2019ECMAScript. L\u2019ECMAScript est la r\u00e9f\u00e9rence de base, de l\u00e0 en d\u00e9coule des impl\u00e9mentations comme le JavaScript. Les versions du JavaScript sont bas\u00e9es sur celles de l\u2019ECMAScript. Ainsi il existe : - ES1 et ES2 qui sont les pr\u00e9mices du langage JavaScript - ES3 sorti en d\u00e9cembre 1999 - ES4 qui a \u00e9t\u00e9 abandonn\u00e9 en raison de modifications trop importantes qui ne furent pas appr\u00e9ci\u00e9es - ES5 sortie en d\u00e9cembre 2009, la version la plus r\u00e9pandue et la plus utilis\u00e9e \u00e0 ce jour - ES6, finalis\u00e9 en d\u00e9cembre 2014 ---- D\u00e9boguer votre code gr\u00e2ce \u00e0 la console Nous allons commencer \u00e0 \u00e9tudier les diff\u00e9rents bugs que l\u2019on va g\u00e9n\u00e9ralement rencontrer en JavaScript et surtout comment les r\u00e9soudre, en utilisant les kits de d\u00e9veloppement fournis avec n\u2019importe quel navigateur digne de ce nom. En quoi consiste le d\u00e9bogage ? Les bugs Ce sont des erreurs humaines laiss\u00e9es dans le code. Il existe deux types principaux de bugs : - ceux que l\u2019interpr\u00e9teur JavaScript saura signaler : fautes de syntaxe va myVar = 'test; // Le mot-cl\u00e9 \u00ab var \u00bb est mal orthographi\u00e9 et il manque une apostrophe ceux que l\u2019interpr\u00e9teur ne verra pas : erreurs dans l\u2019algorithme // On veut afficher la valeur 6 avec les nombres 3 et 2 var myVar = 3 + 2; // Mais on obtient 5 au lieu de 6 car on a fait une addition au lieu d'une multiplication Une erreur syntaxique emp\u00eache le code de s\u2019ex\u00e9cuter tandis que les erreurs d\u2019algorithme ne pose aucun probl\u00e8me d\u2019ex\u00e9cution. Le d\u00e9bogage Cette technique consiste \u00e0 supprimer les bugs qui existent dans le code. Les bugs syntaxiques sont les plus simples \u00e0 r\u00e9soudre car l\u2019interpr\u00e9teur JavaScript signale g\u00e9n\u00e9ralement l\u2019endroit o\u00f9 l\u2019erreur est apparue. En ce qui concerne les bugs algorithmiques, il va falloir chercher nous-m\u00eame. Le plus simple est souvent de remonter les couches de code pour trouver o\u00f9 l\u2019erreur s\u2019est produite. Les kits de d\u00e9veloppement et leur console Tous les navigateurs r\u00e9cent poss\u00e8de un kit de d\u00e9veloppement : Chrome, Firefox, IE, Safari, Op\u00e9ra\u2026 Ces kits permettent de d\u00e9boguer efficacement nos codes : d\u00e9tection des erreurs syntaxiques, afficher des valeurs dans la console, consulter le code HTML g\u00e9n\u00e9r\u00e9 par le code, analyser les requ\u00eates HTTP effectu\u00e9es par le navigateur, mesurer les performances du code, etc\u2026 Les fonctionnalit\u00e9s des diff\u00e9rents kits sont souvent identiques, mais il y a parfois quelques diff\u00e9rences. Nous verrons surtout celui de Chrome. Pour ouvrir le kit de d\u00e9veloppement, il faut appuyer sur F12 . Dans le cadre du d\u00e9bogage d\u2019erreurs, il est tr\u00e8s important de bien externaliser le code JavaScript car l\u2019affichage des erreurs peut \u00eatre erron\u00e9 avec Chrome lorsque le code JS est directement int\u00e9gr\u00e9 au sein du code HTML. Consulter la console pour voir les erreurs. On peut par exemple voir SyntaxError qui mentionne une erreur syntaxique. A droite du texte, on voit le nom du fichier concern\u00e9 ainsi que la ligne de code, qu\u2019il est possible de consulter en cliquant dessus. L\u2019interpr\u00e9teur JavaScript s\u2019arr\u00eate sur la premi\u00e8re erreur rencontr\u00e9e, m\u00eame s\u2019il y a plusieurs erreurs. En corrigeant la premi\u00e8re erreur, le navigateur affichera alors l\u2019erreur suivante. La console permet aussi de rep\u00e9rer des erreurs qui ne sont pas forc\u00e9ment li\u00e9es au JavaScript, telles que des images manquantes par exemple. En cas de page web non conforme \u00e0 ce qu\u2019on attend, il faut toujours consulter la console ce qui permet g\u00e9n\u00e9ralement de trouver la source du probl\u00e8me. Aller plus loin avec la console La console est un outil qui permet de faire plus que simplement lister les erreurs sur la page. La m\u00e9thode console.log() permet d\u2019afficher la valeur d\u2019une variable sans bloquer l\u2019ex\u00e9cution du code contrairement \u00e0 la fonction alert() . // on affiche un tableau. var helloArray = ['Hello', 'Bonjour', 'Hola']; console.log(helloArray); La m\u00e9thode console.log() permet d\u2019afficher le contenu de l\u2019objet. Elle est utilisable sur tous les types de variables et pourra rendre service de nombreuses fois. En plus de la m\u00e9thode log(), l\u2019objet console en propose d\u2019autres qui permettent de modifier la mani\u00e8re d\u2019afficher les valeurs : \u00e9mettre des alertes ou des erreurs avec les m\u00e9thodes warn() et error() , grouper des lignes de r\u00e9sultats avec group() et groupEnd() . Ces m\u00e9thodes sont faites pour d\u00e9boguer le code et n\u2019ont rien \u00e0 faire dans le code une fois le site mis en ligne. Dans la console, il y a une ligne en bas avec un chevron bleu o\u00f9 il est possible d\u2019\u00e9crire directement du code qui agit pendant son ex\u00e9cution ! Cependant, cela fonctionne uniquement sur les variables globales. Utiliser les points d\u2019arr\u00eat Pour identifier un bug qui se produit pendant une fraction de seconde, il est possible d\u2019utiliser un point d\u2019arr\u00eat, aussi appel\u00e9 breakpoint en anglais. Gr\u00e2ce aux points d\u2019arr\u00eat, nous allons pouvoir \u00e9tudier la pile d\u2019ex\u00e9cution de notre code, dans l\u2019onglet \u201cSources\u201d dans le kit de d\u00e9veloppement et choisir un fichier parmi ceux de la page web. Dans le fichier JS, il suffit de cliquer sur un num\u00e9ro de ligne pour mettre un point d\u2019arr\u00eat. Celui-ci indique au navigateur qu\u2019on souhaite mettre en pause le code avant l\u2019ex\u00e9cution de la ligne concern\u00e9e . Ils ne peuvent \u00eatre plac\u00e9 que sur des lignes comportant des instructions , c\u2019est impossible sur une ligne de d\u00e9claration de fonction par exemple. Il faut recharger la page pour prendre en compte le point d\u2019arr\u00eat. Le code sera surlign\u00e9 \u00e0 l\u2019endroit o\u00f9 il s\u2019est arr\u00eat\u00e9. On peut consulter les variables actuellement utilis\u00e9es au sein du scope actuel (dans le menu \u201cLocal\u201d) ainsi que les variables globales (menu \u201cGlobal\u201d). La pile d\u2019ex\u00e9cution Pour chaque point d\u2019arr\u00eat, on peut consulter la pile d\u2019ex\u00e9cution ( call stack ) qui d\u00e9finit par quelles fonctions le code est pass\u00e9 afin d\u2019atteindre la ligne actuellement mise en pause par le point d\u2019arr\u00eat. On peut cliquer sur chaque \u00e9tape de la pile et consulter les variables du scope. La pile permet aussi de savoir par quoi a \u00e9t\u00e9 d\u00e9clench\u00e9 une partie du code. Enfin il est possible de donner un nom \u00e0 une fonction anonyme dans la pile d\u2019ex\u00e9cution afin de mieux la rep\u00e9rer. ---- Premiers pas L\u2019objectif ici est d\u2019apprendre \u00e0 int\u00e9grer le JavaScript aux pages Web. Afficher une bo\u00eete de dialogue Dans les balises <body> du HTML, \u00e9crire <script> alert('Hello world!') </script> Une bo\u00eete de dialogue s'affiche avec le message Hello world! Dans cet exemple, il n\u2019y a qu\u2019une instruction : l\u2019appel de la fonction alert() . C\u2019est une instruction simple, appel\u00e9e fonction, qui permet d\u2019afficher une bo\u00eete de dialogue contenant un message. Une bo\u00eete de dialogue s'affiche avec le message Hello world! La syntaxe du JavaScript Les instructions Les instructions doivent \u00eatre s\u00e9par\u00e9es par un point-virgule, non obligatoire si l\u2019instruction qui suit se trouve sur la ligne suivante. instruction_1 instruction_2; instruction_3; instruction_4 Les espaces Le JavaScript n\u2019est pas sensible aux espaces, on peut donc indenter comme on le souhaite les instructions. Les commentaires Il existe des commentaires de fin de ligne et des commentaires multilignes. instruction_1 // Ceci est ma premi\u00e8re instruction instruction_2 // La troisi\u00e8me instruction ci-dessous : instruction_3 /* Ce script comporte 3 instructions : - Instruction 1 qui fait telle chose - Instruction 2 qui fait autre chose - Instruction 3 qui termine le script */ instruction_1 instruction_2 instruction_3 // Fin du script Quelques aides Un site de documentation : https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference Un site pour tester le code JavaScript en ligne : https://jsfiddle.net/ O\u00f9 placer le code dans la page ? Les codes JavaScript sont ins\u00e9r\u00e9s au moyen de l\u2019\u00e9l\u00e9ment <script> . Cet \u00e9l\u00e9ment poss\u00e8de un attribut type qui sert \u00e0 indiquer le type de langage que l\u2019on va utiliser. dans notre cas, il s\u2019agit du JavaScript, mais \u00e7a pourrait \u00eatre autre chose, comme du VBScript. En HTML4 et XHTML 1.x, l\u2019attribut type est obligatoire. En revanche, en HTML5, il ne l\u2019est pas. L\u2019attribut type prend comme valeur text/javascript, qui est en fait le type MIME d\u2019un code JavaScript. Le JavaScript dans la page Rien de plus simple, on place le code au sein de l\u2019\u00e9l\u00e9ment <script> dans le <body> du HTML. <!DOCTYPE html> <html> <head> <title>Hello World!</title> </head> <body> <script> alert('Hello world!'); </script> </body> </html> En HTML4 ou en XHTML 1.x, il faut utiliser des commentaires d\u2019encadrement pour que la page soit conforme \u00e0 ces normes. C\u2019est inutile en HTML5. Ces commentaires servent \u00e0 isoler le code JavaScript pour ne pas qu\u2019il soit interpr\u00e9t\u00e9 par le validateur du W3C. Cela \u00e9vite d\u2019avoir des erreurs dans la page en emp\u00eachant par exemple l\u2019interpr\u00e9tation des chevrons < et > comme des balises HTML. <body> <script> <!-- valeur_1 > valeur_2; //--> </script> </body> Le JavaScript en externe Il est conseill\u00e9 d\u2019\u00e9crire le code JavaScript dans un fichier externe portant l\u2019extension .js . Ce fichier est ensuite appel\u00e9 depuis la page Web au moyen de l\u2019\u00e9l\u00e9ment script et de son attribut src qui contient l\u2019URL du fichier. Voici un exemple avec un fichier hello.js qui se situe dans le m\u00eame r\u00e9pertoire de la page Web. <!DOCTYPE html> <html> <head> <title>Test JavaScript</title> <meta charset=\"utf-8\" /> </head> <body> <script src=\"index.js\"></script> </body> </html> Il vaut mieux privil\u00e9gier un fichier externe plut\u00f4t que d\u2019inclure le code directement dans la page, car le fichier externe est mis en cache par le navigateur et n\u2019est donc pas recharg\u00e9 \u00e0 chaque chargement de la page, ce qui acc\u00e9l\u00e8re l\u2019affichage de la page. Une page Web est lue par le navigateur de fa\u00e7on lin\u00e9aire, c\u2019est \u00e0 dire d\u2019abord l\u2019\u00e9l\u00e9ment <head> puis les \u00e9l\u00e9ments <body> les uns \u00e0 la suite des autres. Si on appelle un fichier JavaScript d\u00e8s le d\u00e9but du chargement de la page, le navigateur va donc charger ce fichier et si ce dernier est volumineux, le chargement de la page s\u2019en trouvera ralenti car le navigateur va charger le fichier avant de commencer \u00e0 afficher le contenu de la page. Pour pallier ce probl\u00e8me, il est conseill\u00e9 de placer les \u00e9l\u00e9ments <script> juste avant la fermeture de l\u2019\u00e9l\u00e9ment <body> . ---- Les variables Qu\u2019est ce qu\u2019une variable Une variable est un espace de stockage. Il faut commencer par la d\u00e9clarer, c\u2019est \u00e0 dire lui r\u00e9server un espace de stockage. Le mot cl\u00e9 var est pr\u00e9sent pour indiquer qu\u2019on d\u00e9clare une variable. var myVariable; JavaScript est sensible \u00e0 la casse , il faut faire attention aux majuscules et minuscules. JavaScript est un langage typ\u00e9 dynamiquement , cela veut dire que la d\u00e9claration de variable se fait avec le mot cl\u00e9 var sans distinction du contenu. Les trois types principaux en JavaScript - le type num\u00e9rique ( number ) pour les nombres entiers ou d\u00e9cimaux - les cha\u00eenes de caract\u00e8res ( string ) : on peut l\u2019assigner avec des guillemets (\") ou des apostrophes ('). Pour \u00e9chapper les apostrophes, il faut utiliser \\ - les bool\u00e9ens ( boolean ) : prennent soit la valeur true ou false L\u2019instruction typeof permet de tester l\u2019existence d\u2019une variable ou d\u2019en v\u00e9rifier son type. var myNumber = 2 var maString = \"toto\" var monBool = true console.log(typeof myNumber) // Affiche : \u00ab number \u00bb console.log(typeof maString) // Affiche : \u00ab string \u00bb console.log(typeof monBool) // Affiche : \u00ab boolean \u00bb console.log(typeof nothing) // Affiche : \u00ab undefined \u00bb Si l\u2019instruction typeof renvoie undefined, c\u2019est que soit votre variable est inexistante, soit qu\u2019elle est d\u00e9clar\u00e9e mais ne contient rien. Les op\u00e9rateurs arithm\u00e9tiques L\u2019addition + , la soustraction - , la multiplication * , la division / et le modulo % qui est le reste d\u2019une division. L'incr\u00e9mentation permet d\u2019ajouter une unit\u00e9 \u00e0 un nombre au moyen d\u2019une syntaxe court. A l\u2019inverse, la d\u00e9cr\u00e9mentation permet de soustraire une unit\u00e9. var a = 5 // la valeur est affich\u00e9e puis incr\u00e9ment\u00e9e console.log(a++) // 5 console.log(a) // 6 var b = 5 // la valeur est incr\u00e9ment\u00e9e puis affich\u00e9e console.log(++b) // 6 console.log(b) // 6 var c = 1 c += 2 console.log(c) // 3 c *= 4 console.log(c) // 12 c /= 2 console.log(c) // 6 Initiation \u00e0 la concat\u00e9nation et \u00e0 la conversion des types La concat\u00e9nation L\u2019op\u00e9rateur + permet de faire des concat\u00e9nations. var hi = 'Bonjour ', name = 'toi', result result = hi + name console.log(result) // Affiche : \u00ab Bonjour toi \u00bb Interagir avec l\u2019utilisateur La fonction prompt() renvoi ce que l\u2019utilisateur a \u00e9crit dans une bo\u00eete de dialogue sous forme d\u2019une cha\u00eene de caract\u00e8res, que l\u2019on peut donc r\u00e9cup\u00e9rer dans une variable. var text = prompt('Tapez quelque chose :') Convertir une cha\u00eene de caract\u00e8res en nombre Si on essaie de faire l\u2019addition de deux chiffres saisis par l\u2019utilisateur, ils vont \u00eatre concat\u00e9n\u00e9 (par exemple 3 + 6 va donner 36 et non pas 9) car ils sont consid\u00e9r\u00e9s comme une cha\u00eene de caract\u00e8res. Il faut donc convertir les variables en nombre avec la fonction parseInt() pour les nombres entiers et parseFloat() pour les nombres d\u00e9cimaux. Si on utilise parseInt() sur un nombre d\u00e9cimal, il sera tronqu\u00e9. var text = '1337', number number = parseInt(text) var text = '1337.54', number number = parseFloat(text) Convertir un nombre en cha\u00eene de caract\u00e8res L\u2019ajout d\u2019une cha\u00eene de caract\u00e8re vide entre les deux nombres les convertis en caract\u00e8res. var text, number1 = 4, number2 = 2 text = number1 + '' + number2 console.log(text) // Affiche : \u00ab 42 \u00bb Une fa\u00e7on de faire plus propre est d'utiliser la m\u00e9thode toString() var number=1337.65 var text = number.toString() console.log(number) // 1337.65 console.log(typeof number) // number console.log(text) // 1337.65 console.log(typeof text) // string ---- Les conditions La base de toute condition : les bool\u00e9ens Les op\u00e9rateurs de comparaison : - == \u00e9gal \u00e0 - != diff\u00e9rent de - === contenu et type \u00e9gal \u00e0 - !== contenu ou type diff\u00e9rent de - > sup\u00e9rieur \u00e0 - >= sup\u00e9rieur ou \u00e9gal \u00e0 - < inf\u00e9rieur \u00e0 - <= inf\u00e9rieur ou \u00e9gal \u00e0 var number1 = 2, number2 = \"2\" console.log(number1 == number2) // true console.log(number1 === number2) // false Les op\u00e9rateurs logiques - && ET valeur1&&valeur2 - || OU valeur1||valeur2 - ! NON !valeur L\u2019op\u00e9rateur ET v\u00e9rifie que toutes les valeurs qui lui sont pass\u00e9es valent true. Si une seule renvoie false, alors la condition ne sera pas respect\u00e9e. L\u2019op\u00e9rateur OU renvoie true si une des valeurs qui lui est soumise contient true. L\u2019op\u00e9rateur NON inverse la valeur qui lui est pass\u00e9e, ainsi true devient false. var result = true && true console.log(result) // Affiche : \u00ab true \u00bb result = true && false console.log(result) // Affiche : \u00ab false \u00bb var result = false result = !result // On stocke dans \u00ab result \u00bb l'inverse de \u00ab result \u00bb console.log(result) // Affiche \u00ab true \u00bb car on voulait l'inverse de \u00ab false \u00bb La condition if if (2 < 8 && 8 >= 4) { // Cette condition renvoie \u00ab true \u00bb, le code est donc ex\u00e9cut\u00e9 console.log('La condition est bien v\u00e9rifi\u00e9e.') } if (2 > 8 || 8 <= 4) { // Cette condition renvoie \u00ab false \u00bb, le code n'est donc pas ex\u00e9cut\u00e9 console.log(\"La condition n'est pas v\u00e9rifi\u00e9e mais vous ne le saurez pas vu que ce code ne s'ex\u00e9cute pas.\") } La fonction confirm() On lui passe en param\u00e8tre une cha\u00eene de caract\u00e8res qui sera affich\u00e9e \u00e0 l\u2019\u00e9cran et elle retourne un bool\u00e9en en fonction de l\u2019action de l\u2019utilisateur sur la bo\u00eete de dialogue (OK ou Annuler). if (confirm('Voulez-vous ex\u00e9cuter le code JavaScript de cette page ?')) { console.log('Le code a bien \u00e9t\u00e9 ex\u00e9cut\u00e9 !') } Le code s\u2019ex\u00e9cute si on clique sur OK et ne s\u2019ex\u00e9cute pas si on clique sur Annuler. La structure if, else if, else pour dire sinon si, sinon Une premi\u00e8re condition est test\u00e9e, une deuxi\u00e8me sera test\u00e9e si la premi\u00e8re \u00e9choue, et si aucune condition ne se v\u00e9rifie, la structure else fait alors son travail. if(/* condition */){ // Du code... }else if(/* condition */){ // Du code... }else{ // Du code... } La condition \u201cswitch\u201d Tr\u00e8s pratique pour faire du cas par cas, il n\u2019est pas n\u00e9cessaire de r\u00e9\u00e9crire la condition \u00e0 chaque fois. var drawer = parseInt(prompt('Choisissez le tiroir \u00e0 ouvrir (1 \u00e0 3) :')); switch (drawer) { case 1: console.log('Contient divers outils pour dessiner : du papier, des crayons, etc.') break case 2: console.log('Contient du mat\u00e9riel informatique : des c\u00e2bles, des composants, etc.') break default: console.log(\"Info du jour : le meuble ne contient que 4 tiroirs et, jusqu'\u00e0 preuve du contraire, les tiroirs n\u00e9gatifs n'existent pas.\") } On \u00e9crit break \u00e0 la fin de chaque case pour casser le switch et \u00e9viter d\u2019ex\u00e9cuter le reste du code. L\u2019oubli du break fait ex\u00e9cuter tout le code \u00e0 partir du case choisi. Default sera ex\u00e9cut\u00e9 si aucun des cas pr\u00e9c\u00e9dents n\u2019a \u00e9t\u00e9 ex\u00e9cut\u00e9, partie optionnelle. L'op\u00e9rateur Ternaire C'est une syntaxe simplifi\u00e9e pour faire un if else mais un peu moins lisible : condition ? valeurSiTrue : valeurSiFalse Exemple : var gaetan = \"Ga\u00ebtan\" var louis = \"Louis\" var nomLePlusLong if(gaetan.length > louis.length){ nomLePlusLong = gaetan } else { nomLePlusLong = louis } console.log(nomLePlusLong) // affiche Ga\u00ebtan var nomLePlusLong2 = gaetan.length > louis.length ? gaetan : louis console.log(nomLePlusLong2) // affiche Ga\u00ebtan Les conditions sur les variables Tester l\u2019existence du contenu d\u2019une variable var conditionTest = 'Fonctionnera ? Fonctionnera pas ?' if (conditionTest) { console.log('Fonctionne !') } else { console.log('Ne fonctionne pas !') } Le code affiche le texte \u201cFonctionne\u201d car la variable conditionTest a \u00e9t\u00e9 convertie en bool\u00e9en et son contenu a \u00e9t\u00e9 \u00e9valu\u00e9 comme true. Pour qu\u2019il soit \u00e9valu\u00e9 comme false, il faut que que ce soit un nombre \u00e9gal \u00e0 0 ou une cha\u00eene de caract\u00e8res vide. La valeur undefined renvoie aussi false. Le cas de l\u2019op\u00e9rateur OU var conditionTest1 = '', conditionTest2 = 'Une cha\u00eene de caract\u00e8res' console.log(conditionTest1 || conditionTest2) L\u2019op\u00e9rateur OU en plus de sa fonction principale, permet de renvoyer la premi\u00e8re valeur \u00e9valu\u00e9e \u00e0 true. Dans cet exemple, elle renvoie donc Une cha\u00eene de caract\u00e8res . ---- Les boucles La boucle while C\u2019est un r\u00e9p\u00e9tition d\u2019instruction jusqu\u2019\u00e0 ce qu\u2019on dise \u00e0 la boucle de s\u2019arr\u00eater. A chaque r\u00e9p\u00e9tition, on parle d\u2019it\u00e9ration. Tant que la condition est vraie, la boucle se r\u00e9p\u00e8te. while (condition) { instruction_1 instruction_2 } Il est possible d\u2019arr\u00eater la boucle avec le mot cl\u00e9 break . Il est possible de mettre fin \u00e0 une it\u00e9ration et faire continuer la boucle avec continue . La boucle do while Elle ressemble \u00e0 la boucle while sauf qu\u2019elle est toujours ex\u00e9cut\u00e9e au moins une fois. Dans le cas d\u2019une boucle while, si la condition n\u2019est pas valide, la boucle n\u2019est pas ex\u00e9cut\u00e9e. Avec do while, la boucle est ex\u00e9cut\u00e9e une premi\u00e8re fois, puis la condition est test\u00e9e pour savoir si la boucle doit continuer. do { instruction_1 instruction_2 } while (condition) Utilisation tr\u00e8s peu fr\u00e9quente car il est possible d\u2019utiliser une boucle while normale avec une condition qui fait que celle-ci est toujours ex\u00e9cut\u00e9e une fois. La boucle for Ressemble dans son fonctionnement \u00e0 la boucle while for (initialisation; condition; incr\u00e9mentation) { instruction_1 instruction_2 } L\u2019incr\u00e9mentation a lieu \u00e0 la fin de chaque it\u00e9ration. Le premier tour de boucle dans l\u2019exemple ci-dessous est donc fait avec iter=0. for (var iter = 0; iter < 5; iter++) { console.log('It\u00e9ration n\u00b0' + iter) // affiche 0 puis 1, 2, 3 et 4 } console.log(iter) // affiche 5 Port\u00e9e des variables de boucle En JavaScript, il est d\u00e9conseill\u00e9 de d\u00e9clarer des variables au sein d\u2019une boucle car il n\u2019est pas n\u00e9cessaire de d\u00e9clarer une variable \u00e0 chaque passage dans la boucle. Il est conseill\u00e9 de les d\u00e9clarer dans le bloc d\u2019initialisation, mais attention une fois la boucle ex\u00e9cut\u00e9e, la variable existe toujours. Ce comportement est diff\u00e9rent de celui de nombreux autres langages dans lesquels une variable d\u00e9clar\u00e9e dans une boucle est d\u00e9truite une fois la boucle ex\u00e9cut\u00e9e. Priorit\u00e9 d\u2019ex\u00e9cution Les trois blocs de la boucle for ne sont pas ex\u00e9cut\u00e9s en m\u00eame temps : - initialisation : juste avant que la boucle ne d\u00e9marre - condition : avant chaque passage de boucle - incr\u00e9mentation : apr\u00e8s chaque passage de boucle. Cela veut dire que si on fait un break dans une boucle for, le passage dans la boucle lors du break ne sera pas comptabilis\u00e9. La boucle for est tr\u00e8s utilis\u00e9e en JavaScript, bien plus que la boucle while . Le fonctionnement de JavaScript fait que la boucle for est n\u00e9cessaire dans la majorit\u00e9 des cas comme la manipulation des tableaux ainsi que des objets. Nous verrons aussi une variante de la boucle for , appel\u00e9e for in . ---- Les fonctions Concevoir des fonctions // d\u00e9claration d'une fonction function myFunction(arguments) { // Le code que la fonction va devoir ex\u00e9cuter } myFunction() // ex\u00e9cution de la fonction L\u2019utilit\u00e9 basique des fonctions est d\u2019\u00e9viter la r\u00e9p\u00e9tition de code. Le code \u00e9crit dans une fonction ne s'ex\u00e9cute pas imm\u00e9diatement, sinon l'int\u00e9r\u00eat serait nul. Pour cela il faut appeler la fonction afin de l'ex\u00e9cuter. La port\u00e9e des variables Toute variable d\u00e9clar\u00e9e dans une fonction n\u2019est utilisable que dans cette m\u00eame fonction, appel\u00e9e variable locale . Lorsqu\u2019une variable n\u2019est accessible que dans une partie du code, on dit qu\u2019elle se trouve au sein d\u2019un \u201cscope\u201d. Les variables d\u00e9clar\u00e9es en-dehors des fonctions sont appel\u00e9es variables globales , car elles sont accessibles partout dans le code, y compris dans les fonctions. Si on cr\u00e9e une variable locale avec le m\u00eame nom qu\u2019une variable globale, la variable locale prend le dessus le temps de l\u2019ex\u00e9cution de la fonction. Par principe, il faut d\u00e9clarer les variables qui ne servent que dans une fonction \u00e0 l\u2019int\u00e9rieur de celle-ci et non pas de mani\u00e8re globale. Les arguments et les valeurs de retour function myFunction(arg) { console.log('Votre argument : ' + arg) } function moar(first, second) { // On peut maintenant utiliser les variables \u00ab first \u00bb et \u00ab second \u00bb comme on le souhaite : console.log('Votre premier argument : ' + first) console.log('Votre deuxi\u00e8me argument : ' + second) } Les arguments sont propres \u00e0 leur fonction, ils ne seront accessibles que dans cette fonction et nulle part ailleurs. Les valeurs de retour Chaque fonction ne peut retourner qu\u2019une seule et unique valeur. Il est possible de contourner le probl\u00e8me en renvoyant un tableau ou un objet. L\u2019instruction return met fin \u00e0 la fonction puis retourne la valeur. function sayHello() { return 'Bonjour !' } console.log(sayHello()) // on affiche la valeur retourn\u00e9e par la fonction sayHello() Les fonctions anonymes Elles sont extr\u00eamement importantes en JavaScript. Elles servent pour les objets, les \u00e9v\u00e9nements, les variables statiques, les closures\u2026 Elles n\u2019ont pas de nom ! C\u2019est la seule diff\u00e9rence avec une fonction traditionnelle. function (arguments) { // Le code de votre fonction anonyme } Pour l\u2019appeler, il existe de tr\u00e8s nombreuses fa\u00e7ons de faire. Pour le moment, il faut se limiter \u00e0 une seule solution : assigner la fonction \u00e0 une variable. var sayHello = function(){ console.log('Bonjour !') } sayHello() // Affiche : \u00ab Bonjour ! \u00bb La variable sayHello est devenue une fonction. ---- Les objets et les tableaux Introduction aux objets JavaScript est un langage orient\u00e9 objet, cela veut dire que le langage dispose d\u2019objets, qui disposent d\u2019une structure. JavaScript met \u00e0 notre disposition des objets natifs : un nombre, une cha\u00eene de caract\u00e8res, un bool\u00e9en. On dit que JavaScript n\u2019est pas un langage typ\u00e9 car les variables contiennent toujours la m\u00eame chose : un objet. Cet objet peut \u00eatre de nature diff\u00e9rente (nombre, bool\u00e9en\u2026). Il est \u00e9galement possible de cr\u00e9er nos propres objets, ce qui sera apr\u00e8s. Les objets contiennent trois choses distinctes : - un constructeur - code utilis\u00e9 quand on utilise un nouvel objet - permet d\u2019effectuer des actions comme d\u00e9finir diverses variables - r\u00e9alis\u00e9 automatiquement pour les objets natifs - des propri\u00e9t\u00e9s - une propri\u00e9t\u00e9 est une variable contenue dans l\u2019objet - des m\u00e9thodes - il est possible de modifier l\u2019objet gr\u00e2ce aux m\u00e9thodes qui sont des fonctions contenues dans l\u2019objet, qui permettent de r\u00e9aliser des op\u00e9rations sur le contenu de l\u2019objet var myString = 'Ceci est une cha\u00eene de caract\u00e8res' // On cr\u00e9e un objet String console.log(myString.length) // On affiche le nombre de caract\u00e8res, au moyen de la propri\u00e9t\u00e9 \u00ab length \u00bb console.log(myString.toUpperCase()) // On r\u00e9cup\u00e8re la cha\u00eene en majuscules, avec la m\u00e9thode toUpperCase() Le point apr\u00e8s un objet permet d\u2019acc\u00e9der aux propri\u00e9t\u00e9s et aux m\u00e9thodes d\u2019un objet. Nous avons d\u00e9j\u00e0 d\u00e9couvert trois objets natif : Number, Boolean, String. On allons maintenant d\u00e9couvrir l\u2019objet Array qui g\u00e8re les tableaux. Les tableaux Un tableau, array en anglais, contient plusieurs valeurs appel\u00e9es item . Chaque item est accessible au moyen d\u2019un indice dont la num\u00e9rotation commence \u00e0 0. var myArray = [1, 2, 3, 4, 5] console.log(myArray.length) // affiche 5 console.log(myArray[0]) // affiche 1, le premier \u00e9l\u00e9ment du tableau myArray[0]=8 // modifie la valeur du premier \u00e9l\u00e9ment du tableau console.log(myArray[0]) // affiche 8, le premier \u00e9l\u00e9ment du tableau console.log(myArray[myArray.length-1]) // affiche 5, le dernier \u00e9l\u00e9ment du tableau Pour plus de d\u00e9tails sur les tableaux, voir la partie Objets et fonctions utiles en JavaScript . Les objets litt\u00e9raux La syntaxe d\u2019un objet Il est possible d\u2019acc\u00e9der aux propri\u00e9t\u00e9s d'un objet via un identifiant. Un objet est similaire \u00e0 un tableau sauf que l\u2019on met des accolades \u00e0 la place des crochets. var myObject = { propertyName1: propertyValue1, propertyName2: propertyValue2, methode1: function(){ } } Pour d\u00e9finir d\u00e8s l\u2019initialisation les items \u00e0 ajouter, il suffit d\u2019\u00e9crire l\u2019identifiant suivi de deux points et de la valeur \u00e0 lui attribuer. La s\u00e9paration des items se fait comme pour un tableau, avec une virgule. var louis = { prenom: 'Louis', nom: 'Varlet', direPapa: function(){ console.log(\"Papa !\") } } // Acc\u00e8s aux propri\u00e9t\u00e9s console.log(louis) // permet d'acc\u00e9der \u00e0 l'objet louis console.log(typeof louis) // affiche object console.log(louis.prenom) // affiche Louis console.log(louis[\"prenom\"]) // affiche Louis (m\u00e9thode est utile si l\u2019identifiant est contenu dans une variable) // Ajouter une propri\u00e9t\u00e9 en sp\u00e9cifiant un identifiant qui n\u2019est pas encore pr\u00e9sent. console.log(louis.age) // affiche undefined louis.age = 1 console.log(louis.age) // affiche 1 louis[\"prenomPere\"] = \"Ga\u00ebtan\" // on peut aussi le faire avec les crochets console.log(louis.prenomPere) // affiche Ga\u00ebtan // Ex\u00e9cution d'une m\u00e9thode louis.direPapa() // affiche Papa ! Autre fa\u00e7on de cr\u00e9er un objet : var gaetan = new Object() gaetan.prenom = 'Ga\u00ebtan' gaetan.nom = 'Varlet' Parcourir un objet avec for in Il n\u2019est pas possible d\u2019utiliser une boucle for car elle incr\u00e9mente une variable num\u00e9rique ce qui est inutile sur un objet litt\u00e9ral puisque nous devons poss\u00e9der un identifiant. La boucle for in ne sert qu\u2019\u00e0 une chose : parcourir un objet. Le fonctionnement est quasiment le m\u00eame que pour un tableau, except\u00e9 qu\u2019il suffit de fournir une \u201cvariable cl\u00e9\u201d qui re\u00e7oit un identifiant (au lieu d\u2019un index) et de sp\u00e9cifier l\u2019objet \u00e0 parcourir : const louis = { prenom: \"Louis\", nom: \"Varlet\" } for(let property in louis){ console.log(louis[property]) } // affiche Louis // affiche Varlet Utilisation des objets litt\u00e9raux Ils peuvent \u00eatre utile pour ordonner un code. On les utilise aussi dans les fonctions, car return ne sait retourner qu\u2019une seule variable. Avec un objet, il est possible de retourner plusieurs variables en stockant les r\u00e9sultats dans l\u2019objet, plus commode qu\u2019un tableau. Exemple d\u2019une fonction qui calcule des coordonn\u00e9es d\u2019un \u00e9l\u00e9ment HTML sur une page Web et retourne les coordonn\u00e9es x et y : function getCoords() { /* Script incomplet, juste pour l'exemple */ return { x: 12, y: 21 } } var coords = getCoords() console.log(coords.x) // 12 console.log(coords.y) // 21 Les constructeurs Ils permettent de cr\u00e9er un moule pour cr\u00e9er plusieurs objets \u00e0 partir de ce moule function Dog(name, color, age){ this.name = name this.color = color this.age = age this.aboie = function(){ console.log(\"wouf wouf \"+this.name) } } var monChien = new Dog(\"Rex\", \"noir\", 6) console.log(monChien); // affiche le chien monChien.aboie(); // affiche : wouf wouf Rex","title":"Les bases de JavaScript"},{"location":"javascript/lesBasesDeJavaScript/#les-bases-de-javascript","text":"","title":"Les bases de JavaScript"},{"location":"javascript/lesBasesDeJavaScript/#-","text":"","title":"----"},{"location":"javascript/lesBasesDeJavaScript/#introduction","text":"","title":"Introduction"},{"location":"javascript/lesBasesDeJavaScript/#quest-que-le-javascript","text":"Le JavaScript est un langage de programmation de scripts orient\u00e9 objet Un langage de programmation permet d\u2019\u00e9crire du code source qui sera analys\u00e9 par l\u2019ordinateur. Il existe trois mani\u00e8res d\u2019utiliser du code source : - langage compil\u00e9 : le code source est donn\u00e9 \u00e0 un programme appel\u00e9 compilateur qui va lire le code source et le convertir dans un langage que l\u2019ordinateur sera capable d\u2019interpr\u00e9ter : le langage binaire. Les langages comme le C ou le C++ sont des langages dits compil\u00e9s - langage pr\u00e9compil\u00e9 : le code source est partiellement compil\u00e9, dans un langage plus simple \u00e0 lire par l\u2019ordinateur mais ce n\u2019est pas encore du binaire. Ce code interm\u00e9diaire devra \u00eatre lu par une machine virtuelle qui ex\u00e9cutera ce code. Les langages comme Java ou C# sont dits pr\u00e9compil\u00e9s - langage interpr\u00e9t\u00e9 : pas de compilation, le code source reste tel quel. Pour ex\u00e9cuter le code, on doit le fournir \u00e0 un interpr\u00e9teur qui lira le code et r\u00e9alisera les actions. Pour obtenir des gains de performances, on peut le le compiler \u00e0 la vol\u00e9e pendant son ex\u00e9cution, ce que font aujourd\u2019hui la plupart des interpr\u00e9teurs JavaScript Les scripts sont majoritairement interpr\u00e9t\u00e9s, ce qui est le cas de JavaScript qui est un langage interpr\u00e9t\u00e9. Il y a un interpr\u00e9teur JavaScript dans le navigateur Web, qui est diff\u00e9rent selon le navigateur : Chakra dans Internet Explorer, SpiderMonkey dans Firefox, V8 dans Chrome. Le JavaScript est majoritairement utilis\u00e9 sur les pages Web pour dynamiser les pages HTML, en ajoutant des interactions avec l\u2019utilisateur, des animations, de l\u2019aide \u00e0 la navigation, par exemple : afficher ou masquer du texte, faire d\u00e9filer des images, cr\u00e9er des infobulles\u2026 Les scripts JavaScript sont ex\u00e9cut\u00e9s par le navigateur chez l\u2019internaute (le client), contrairement aux langages serveur (comme le PHP) ex\u00e9cut\u00e9 par le serveur web. Un script serveur va s\u2019occuper de cr\u00e9er la page Web qui sera envoy\u00e9 au navigateur. Ce dernier va alors afficher la page puis ex\u00e9cuter les scripts client tel que le JavaScript. Le JavaScript ne sert pas que dans les pages Web. Il sert aussi \u00e0 r\u00e9aliser des extensions pour des programmes. Chrome et Firefox en poss\u00e8dent tous deux un panel gigantesque en partie cod\u00e9es en JavaSript. Il est aussi possible d\u2019ex\u00e9cuter du JavaScript en dehors du navigateur. Le JavaScript peut aussi \u00eatre utilis\u00e9 pour r\u00e9aliser des applications.","title":"Qu\u2019est que le JavaScript ?"},{"location":"javascript/lesBasesDeJavaScript/#petit-historique-du-langage","text":"En 1995, Brendan Eich d\u00e9veloppe le LiveScript qui sera renomm\u00e9 en JavaScript en hommage au langage Java. Netscape d\u00e9cide d\u2019envoyer sa version de JavaScript \u00e0 l\u2019ECMA international pour que le langage soit standardis\u00e9. L\u2019ECMA standardise le langage soit le nom d\u2019ECMAScript. L\u2019ECMAScript est la r\u00e9f\u00e9rence de base, de l\u00e0 en d\u00e9coule des impl\u00e9mentations comme le JavaScript. Les versions du JavaScript sont bas\u00e9es sur celles de l\u2019ECMAScript. Ainsi il existe : - ES1 et ES2 qui sont les pr\u00e9mices du langage JavaScript - ES3 sorti en d\u00e9cembre 1999 - ES4 qui a \u00e9t\u00e9 abandonn\u00e9 en raison de modifications trop importantes qui ne furent pas appr\u00e9ci\u00e9es - ES5 sortie en d\u00e9cembre 2009, la version la plus r\u00e9pandue et la plus utilis\u00e9e \u00e0 ce jour - ES6, finalis\u00e9 en d\u00e9cembre 2014","title":"Petit historique du langage"},{"location":"javascript/lesBasesDeJavaScript/#-_1","text":"","title":"----"},{"location":"javascript/lesBasesDeJavaScript/#deboguer-votre-code-grace-a-la-console","text":"Nous allons commencer \u00e0 \u00e9tudier les diff\u00e9rents bugs que l\u2019on va g\u00e9n\u00e9ralement rencontrer en JavaScript et surtout comment les r\u00e9soudre, en utilisant les kits de d\u00e9veloppement fournis avec n\u2019importe quel navigateur digne de ce nom.","title":"D\u00e9boguer votre code gr\u00e2ce \u00e0 la console"},{"location":"javascript/lesBasesDeJavaScript/#en-quoi-consiste-le-debogage","text":"","title":"En quoi consiste le d\u00e9bogage ?"},{"location":"javascript/lesBasesDeJavaScript/#les-bugs","text":"Ce sont des erreurs humaines laiss\u00e9es dans le code. Il existe deux types principaux de bugs : - ceux que l\u2019interpr\u00e9teur JavaScript saura signaler : fautes de syntaxe va myVar = 'test; // Le mot-cl\u00e9 \u00ab var \u00bb est mal orthographi\u00e9 et il manque une apostrophe ceux que l\u2019interpr\u00e9teur ne verra pas : erreurs dans l\u2019algorithme // On veut afficher la valeur 6 avec les nombres 3 et 2 var myVar = 3 + 2; // Mais on obtient 5 au lieu de 6 car on a fait une addition au lieu d'une multiplication Une erreur syntaxique emp\u00eache le code de s\u2019ex\u00e9cuter tandis que les erreurs d\u2019algorithme ne pose aucun probl\u00e8me d\u2019ex\u00e9cution.","title":"Les bugs"},{"location":"javascript/lesBasesDeJavaScript/#le-debogage","text":"Cette technique consiste \u00e0 supprimer les bugs qui existent dans le code. Les bugs syntaxiques sont les plus simples \u00e0 r\u00e9soudre car l\u2019interpr\u00e9teur JavaScript signale g\u00e9n\u00e9ralement l\u2019endroit o\u00f9 l\u2019erreur est apparue. En ce qui concerne les bugs algorithmiques, il va falloir chercher nous-m\u00eame. Le plus simple est souvent de remonter les couches de code pour trouver o\u00f9 l\u2019erreur s\u2019est produite.","title":"Le d\u00e9bogage"},{"location":"javascript/lesBasesDeJavaScript/#les-kits-de-developpement-et-leur-console","text":"Tous les navigateurs r\u00e9cent poss\u00e8de un kit de d\u00e9veloppement : Chrome, Firefox, IE, Safari, Op\u00e9ra\u2026 Ces kits permettent de d\u00e9boguer efficacement nos codes : d\u00e9tection des erreurs syntaxiques, afficher des valeurs dans la console, consulter le code HTML g\u00e9n\u00e9r\u00e9 par le code, analyser les requ\u00eates HTTP effectu\u00e9es par le navigateur, mesurer les performances du code, etc\u2026 Les fonctionnalit\u00e9s des diff\u00e9rents kits sont souvent identiques, mais il y a parfois quelques diff\u00e9rences. Nous verrons surtout celui de Chrome. Pour ouvrir le kit de d\u00e9veloppement, il faut appuyer sur F12 . Dans le cadre du d\u00e9bogage d\u2019erreurs, il est tr\u00e8s important de bien externaliser le code JavaScript car l\u2019affichage des erreurs peut \u00eatre erron\u00e9 avec Chrome lorsque le code JS est directement int\u00e9gr\u00e9 au sein du code HTML. Consulter la console pour voir les erreurs. On peut par exemple voir SyntaxError qui mentionne une erreur syntaxique. A droite du texte, on voit le nom du fichier concern\u00e9 ainsi que la ligne de code, qu\u2019il est possible de consulter en cliquant dessus. L\u2019interpr\u00e9teur JavaScript s\u2019arr\u00eate sur la premi\u00e8re erreur rencontr\u00e9e, m\u00eame s\u2019il y a plusieurs erreurs. En corrigeant la premi\u00e8re erreur, le navigateur affichera alors l\u2019erreur suivante. La console permet aussi de rep\u00e9rer des erreurs qui ne sont pas forc\u00e9ment li\u00e9es au JavaScript, telles que des images manquantes par exemple. En cas de page web non conforme \u00e0 ce qu\u2019on attend, il faut toujours consulter la console ce qui permet g\u00e9n\u00e9ralement de trouver la source du probl\u00e8me.","title":"Les kits de d\u00e9veloppement et leur console"},{"location":"javascript/lesBasesDeJavaScript/#aller-plus-loin-avec-la-console","text":"La console est un outil qui permet de faire plus que simplement lister les erreurs sur la page. La m\u00e9thode console.log() permet d\u2019afficher la valeur d\u2019une variable sans bloquer l\u2019ex\u00e9cution du code contrairement \u00e0 la fonction alert() . // on affiche un tableau. var helloArray = ['Hello', 'Bonjour', 'Hola']; console.log(helloArray); La m\u00e9thode console.log() permet d\u2019afficher le contenu de l\u2019objet. Elle est utilisable sur tous les types de variables et pourra rendre service de nombreuses fois. En plus de la m\u00e9thode log(), l\u2019objet console en propose d\u2019autres qui permettent de modifier la mani\u00e8re d\u2019afficher les valeurs : \u00e9mettre des alertes ou des erreurs avec les m\u00e9thodes warn() et error() , grouper des lignes de r\u00e9sultats avec group() et groupEnd() . Ces m\u00e9thodes sont faites pour d\u00e9boguer le code et n\u2019ont rien \u00e0 faire dans le code une fois le site mis en ligne. Dans la console, il y a une ligne en bas avec un chevron bleu o\u00f9 il est possible d\u2019\u00e9crire directement du code qui agit pendant son ex\u00e9cution ! Cependant, cela fonctionne uniquement sur les variables globales.","title":"Aller plus loin avec la console"},{"location":"javascript/lesBasesDeJavaScript/#utiliser-les-points-darret","text":"Pour identifier un bug qui se produit pendant une fraction de seconde, il est possible d\u2019utiliser un point d\u2019arr\u00eat, aussi appel\u00e9 breakpoint en anglais. Gr\u00e2ce aux points d\u2019arr\u00eat, nous allons pouvoir \u00e9tudier la pile d\u2019ex\u00e9cution de notre code, dans l\u2019onglet \u201cSources\u201d dans le kit de d\u00e9veloppement et choisir un fichier parmi ceux de la page web. Dans le fichier JS, il suffit de cliquer sur un num\u00e9ro de ligne pour mettre un point d\u2019arr\u00eat. Celui-ci indique au navigateur qu\u2019on souhaite mettre en pause le code avant l\u2019ex\u00e9cution de la ligne concern\u00e9e . Ils ne peuvent \u00eatre plac\u00e9 que sur des lignes comportant des instructions , c\u2019est impossible sur une ligne de d\u00e9claration de fonction par exemple. Il faut recharger la page pour prendre en compte le point d\u2019arr\u00eat. Le code sera surlign\u00e9 \u00e0 l\u2019endroit o\u00f9 il s\u2019est arr\u00eat\u00e9. On peut consulter les variables actuellement utilis\u00e9es au sein du scope actuel (dans le menu \u201cLocal\u201d) ainsi que les variables globales (menu \u201cGlobal\u201d). La pile d\u2019ex\u00e9cution Pour chaque point d\u2019arr\u00eat, on peut consulter la pile d\u2019ex\u00e9cution ( call stack ) qui d\u00e9finit par quelles fonctions le code est pass\u00e9 afin d\u2019atteindre la ligne actuellement mise en pause par le point d\u2019arr\u00eat. On peut cliquer sur chaque \u00e9tape de la pile et consulter les variables du scope. La pile permet aussi de savoir par quoi a \u00e9t\u00e9 d\u00e9clench\u00e9 une partie du code. Enfin il est possible de donner un nom \u00e0 une fonction anonyme dans la pile d\u2019ex\u00e9cution afin de mieux la rep\u00e9rer.","title":"Utiliser les points d\u2019arr\u00eat"},{"location":"javascript/lesBasesDeJavaScript/#-_2","text":"","title":"----"},{"location":"javascript/lesBasesDeJavaScript/#premiers-pas","text":"L\u2019objectif ici est d\u2019apprendre \u00e0 int\u00e9grer le JavaScript aux pages Web.","title":"Premiers pas"},{"location":"javascript/lesBasesDeJavaScript/#afficher-une-boite-de-dialogue","text":"Dans les balises <body> du HTML, \u00e9crire <script> alert('Hello world!') </script> Une bo\u00eete de dialogue s'affiche avec le message Hello world! Dans cet exemple, il n\u2019y a qu\u2019une instruction : l\u2019appel de la fonction alert() . C\u2019est une instruction simple, appel\u00e9e fonction, qui permet d\u2019afficher une bo\u00eete de dialogue contenant un message. Une bo\u00eete de dialogue s'affiche avec le message Hello world!","title":"Afficher une bo\u00eete de dialogue"},{"location":"javascript/lesBasesDeJavaScript/#la-syntaxe-du-javascript","text":"","title":"La syntaxe du JavaScript"},{"location":"javascript/lesBasesDeJavaScript/#les-instructions","text":"Les instructions doivent \u00eatre s\u00e9par\u00e9es par un point-virgule, non obligatoire si l\u2019instruction qui suit se trouve sur la ligne suivante. instruction_1 instruction_2; instruction_3; instruction_4","title":"Les instructions"},{"location":"javascript/lesBasesDeJavaScript/#les-espaces","text":"Le JavaScript n\u2019est pas sensible aux espaces, on peut donc indenter comme on le souhaite les instructions.","title":"Les espaces"},{"location":"javascript/lesBasesDeJavaScript/#les-commentaires","text":"Il existe des commentaires de fin de ligne et des commentaires multilignes. instruction_1 // Ceci est ma premi\u00e8re instruction instruction_2 // La troisi\u00e8me instruction ci-dessous : instruction_3 /* Ce script comporte 3 instructions : - Instruction 1 qui fait telle chose - Instruction 2 qui fait autre chose - Instruction 3 qui termine le script */ instruction_1 instruction_2 instruction_3 // Fin du script","title":"Les commentaires"},{"location":"javascript/lesBasesDeJavaScript/#quelques-aides","text":"Un site de documentation : https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference Un site pour tester le code JavaScript en ligne : https://jsfiddle.net/","title":"Quelques aides"},{"location":"javascript/lesBasesDeJavaScript/#ou-placer-le-code-dans-la-page","text":"Les codes JavaScript sont ins\u00e9r\u00e9s au moyen de l\u2019\u00e9l\u00e9ment <script> . Cet \u00e9l\u00e9ment poss\u00e8de un attribut type qui sert \u00e0 indiquer le type de langage que l\u2019on va utiliser. dans notre cas, il s\u2019agit du JavaScript, mais \u00e7a pourrait \u00eatre autre chose, comme du VBScript. En HTML4 et XHTML 1.x, l\u2019attribut type est obligatoire. En revanche, en HTML5, il ne l\u2019est pas. L\u2019attribut type prend comme valeur text/javascript, qui est en fait le type MIME d\u2019un code JavaScript.","title":"O\u00f9 placer le code dans la page ?"},{"location":"javascript/lesBasesDeJavaScript/#le-javascript-dans-la-page","text":"Rien de plus simple, on place le code au sein de l\u2019\u00e9l\u00e9ment <script> dans le <body> du HTML. <!DOCTYPE html> <html> <head> <title>Hello World!</title> </head> <body> <script> alert('Hello world!'); </script> </body> </html> En HTML4 ou en XHTML 1.x, il faut utiliser des commentaires d\u2019encadrement pour que la page soit conforme \u00e0 ces normes. C\u2019est inutile en HTML5. Ces commentaires servent \u00e0 isoler le code JavaScript pour ne pas qu\u2019il soit interpr\u00e9t\u00e9 par le validateur du W3C. Cela \u00e9vite d\u2019avoir des erreurs dans la page en emp\u00eachant par exemple l\u2019interpr\u00e9tation des chevrons < et > comme des balises HTML. <body> <script> <!-- valeur_1 > valeur_2; //--> </script> </body>","title":"Le JavaScript dans la page"},{"location":"javascript/lesBasesDeJavaScript/#le-javascript-en-externe","text":"Il est conseill\u00e9 d\u2019\u00e9crire le code JavaScript dans un fichier externe portant l\u2019extension .js . Ce fichier est ensuite appel\u00e9 depuis la page Web au moyen de l\u2019\u00e9l\u00e9ment script et de son attribut src qui contient l\u2019URL du fichier. Voici un exemple avec un fichier hello.js qui se situe dans le m\u00eame r\u00e9pertoire de la page Web. <!DOCTYPE html> <html> <head> <title>Test JavaScript</title> <meta charset=\"utf-8\" /> </head> <body> <script src=\"index.js\"></script> </body> </html> Il vaut mieux privil\u00e9gier un fichier externe plut\u00f4t que d\u2019inclure le code directement dans la page, car le fichier externe est mis en cache par le navigateur et n\u2019est donc pas recharg\u00e9 \u00e0 chaque chargement de la page, ce qui acc\u00e9l\u00e8re l\u2019affichage de la page. Une page Web est lue par le navigateur de fa\u00e7on lin\u00e9aire, c\u2019est \u00e0 dire d\u2019abord l\u2019\u00e9l\u00e9ment <head> puis les \u00e9l\u00e9ments <body> les uns \u00e0 la suite des autres. Si on appelle un fichier JavaScript d\u00e8s le d\u00e9but du chargement de la page, le navigateur va donc charger ce fichier et si ce dernier est volumineux, le chargement de la page s\u2019en trouvera ralenti car le navigateur va charger le fichier avant de commencer \u00e0 afficher le contenu de la page. Pour pallier ce probl\u00e8me, il est conseill\u00e9 de placer les \u00e9l\u00e9ments <script> juste avant la fermeture de l\u2019\u00e9l\u00e9ment <body> .","title":"Le JavaScript en externe"},{"location":"javascript/lesBasesDeJavaScript/#-_3","text":"","title":"----"},{"location":"javascript/lesBasesDeJavaScript/#les-variables","text":"","title":"Les variables"},{"location":"javascript/lesBasesDeJavaScript/#quest-ce-quune-variable","text":"Une variable est un espace de stockage. Il faut commencer par la d\u00e9clarer, c\u2019est \u00e0 dire lui r\u00e9server un espace de stockage. Le mot cl\u00e9 var est pr\u00e9sent pour indiquer qu\u2019on d\u00e9clare une variable. var myVariable; JavaScript est sensible \u00e0 la casse , il faut faire attention aux majuscules et minuscules. JavaScript est un langage typ\u00e9 dynamiquement , cela veut dire que la d\u00e9claration de variable se fait avec le mot cl\u00e9 var sans distinction du contenu. Les trois types principaux en JavaScript - le type num\u00e9rique ( number ) pour les nombres entiers ou d\u00e9cimaux - les cha\u00eenes de caract\u00e8res ( string ) : on peut l\u2019assigner avec des guillemets (\") ou des apostrophes ('). Pour \u00e9chapper les apostrophes, il faut utiliser \\ - les bool\u00e9ens ( boolean ) : prennent soit la valeur true ou false L\u2019instruction typeof permet de tester l\u2019existence d\u2019une variable ou d\u2019en v\u00e9rifier son type. var myNumber = 2 var maString = \"toto\" var monBool = true console.log(typeof myNumber) // Affiche : \u00ab number \u00bb console.log(typeof maString) // Affiche : \u00ab string \u00bb console.log(typeof monBool) // Affiche : \u00ab boolean \u00bb console.log(typeof nothing) // Affiche : \u00ab undefined \u00bb Si l\u2019instruction typeof renvoie undefined, c\u2019est que soit votre variable est inexistante, soit qu\u2019elle est d\u00e9clar\u00e9e mais ne contient rien.","title":"Qu\u2019est ce qu\u2019une variable"},{"location":"javascript/lesBasesDeJavaScript/#les-operateurs-arithmetiques","text":"L\u2019addition + , la soustraction - , la multiplication * , la division / et le modulo % qui est le reste d\u2019une division. L'incr\u00e9mentation permet d\u2019ajouter une unit\u00e9 \u00e0 un nombre au moyen d\u2019une syntaxe court. A l\u2019inverse, la d\u00e9cr\u00e9mentation permet de soustraire une unit\u00e9. var a = 5 // la valeur est affich\u00e9e puis incr\u00e9ment\u00e9e console.log(a++) // 5 console.log(a) // 6 var b = 5 // la valeur est incr\u00e9ment\u00e9e puis affich\u00e9e console.log(++b) // 6 console.log(b) // 6 var c = 1 c += 2 console.log(c) // 3 c *= 4 console.log(c) // 12 c /= 2 console.log(c) // 6","title":"Les op\u00e9rateurs arithm\u00e9tiques"},{"location":"javascript/lesBasesDeJavaScript/#initiation-a-la-concatenation-et-a-la-conversion-des-types","text":"","title":"Initiation \u00e0 la concat\u00e9nation et \u00e0 la conversion des types"},{"location":"javascript/lesBasesDeJavaScript/#la-concatenation","text":"L\u2019op\u00e9rateur + permet de faire des concat\u00e9nations. var hi = 'Bonjour ', name = 'toi', result result = hi + name console.log(result) // Affiche : \u00ab Bonjour toi \u00bb","title":"La concat\u00e9nation"},{"location":"javascript/lesBasesDeJavaScript/#interagir-avec-lutilisateur","text":"La fonction prompt() renvoi ce que l\u2019utilisateur a \u00e9crit dans une bo\u00eete de dialogue sous forme d\u2019une cha\u00eene de caract\u00e8res, que l\u2019on peut donc r\u00e9cup\u00e9rer dans une variable. var text = prompt('Tapez quelque chose :')","title":"Interagir avec l\u2019utilisateur"},{"location":"javascript/lesBasesDeJavaScript/#convertir-une-chaine-de-caracteres-en-nombre","text":"Si on essaie de faire l\u2019addition de deux chiffres saisis par l\u2019utilisateur, ils vont \u00eatre concat\u00e9n\u00e9 (par exemple 3 + 6 va donner 36 et non pas 9) car ils sont consid\u00e9r\u00e9s comme une cha\u00eene de caract\u00e8res. Il faut donc convertir les variables en nombre avec la fonction parseInt() pour les nombres entiers et parseFloat() pour les nombres d\u00e9cimaux. Si on utilise parseInt() sur un nombre d\u00e9cimal, il sera tronqu\u00e9. var text = '1337', number number = parseInt(text) var text = '1337.54', number number = parseFloat(text)","title":"Convertir une cha\u00eene de caract\u00e8res en nombre"},{"location":"javascript/lesBasesDeJavaScript/#convertir-un-nombre-en-chaine-de-caracteres","text":"L\u2019ajout d\u2019une cha\u00eene de caract\u00e8re vide entre les deux nombres les convertis en caract\u00e8res. var text, number1 = 4, number2 = 2 text = number1 + '' + number2 console.log(text) // Affiche : \u00ab 42 \u00bb Une fa\u00e7on de faire plus propre est d'utiliser la m\u00e9thode toString() var number=1337.65 var text = number.toString() console.log(number) // 1337.65 console.log(typeof number) // number console.log(text) // 1337.65 console.log(typeof text) // string","title":"Convertir un nombre en cha\u00eene de caract\u00e8res"},{"location":"javascript/lesBasesDeJavaScript/#-_4","text":"","title":"----"},{"location":"javascript/lesBasesDeJavaScript/#les-conditions","text":"","title":"Les conditions"},{"location":"javascript/lesBasesDeJavaScript/#la-base-de-toute-condition-les-booleens","text":"Les op\u00e9rateurs de comparaison : - == \u00e9gal \u00e0 - != diff\u00e9rent de - === contenu et type \u00e9gal \u00e0 - !== contenu ou type diff\u00e9rent de - > sup\u00e9rieur \u00e0 - >= sup\u00e9rieur ou \u00e9gal \u00e0 - < inf\u00e9rieur \u00e0 - <= inf\u00e9rieur ou \u00e9gal \u00e0 var number1 = 2, number2 = \"2\" console.log(number1 == number2) // true console.log(number1 === number2) // false Les op\u00e9rateurs logiques - && ET valeur1&&valeur2 - || OU valeur1||valeur2 - ! NON !valeur L\u2019op\u00e9rateur ET v\u00e9rifie que toutes les valeurs qui lui sont pass\u00e9es valent true. Si une seule renvoie false, alors la condition ne sera pas respect\u00e9e. L\u2019op\u00e9rateur OU renvoie true si une des valeurs qui lui est soumise contient true. L\u2019op\u00e9rateur NON inverse la valeur qui lui est pass\u00e9e, ainsi true devient false. var result = true && true console.log(result) // Affiche : \u00ab true \u00bb result = true && false console.log(result) // Affiche : \u00ab false \u00bb var result = false result = !result // On stocke dans \u00ab result \u00bb l'inverse de \u00ab result \u00bb console.log(result) // Affiche \u00ab true \u00bb car on voulait l'inverse de \u00ab false \u00bb","title":"La base de toute condition : les bool\u00e9ens"},{"location":"javascript/lesBasesDeJavaScript/#la-condition-if","text":"if (2 < 8 && 8 >= 4) { // Cette condition renvoie \u00ab true \u00bb, le code est donc ex\u00e9cut\u00e9 console.log('La condition est bien v\u00e9rifi\u00e9e.') } if (2 > 8 || 8 <= 4) { // Cette condition renvoie \u00ab false \u00bb, le code n'est donc pas ex\u00e9cut\u00e9 console.log(\"La condition n'est pas v\u00e9rifi\u00e9e mais vous ne le saurez pas vu que ce code ne s'ex\u00e9cute pas.\") }","title":"La condition if"},{"location":"javascript/lesBasesDeJavaScript/#la-fonction-confirm","text":"On lui passe en param\u00e8tre une cha\u00eene de caract\u00e8res qui sera affich\u00e9e \u00e0 l\u2019\u00e9cran et elle retourne un bool\u00e9en en fonction de l\u2019action de l\u2019utilisateur sur la bo\u00eete de dialogue (OK ou Annuler). if (confirm('Voulez-vous ex\u00e9cuter le code JavaScript de cette page ?')) { console.log('Le code a bien \u00e9t\u00e9 ex\u00e9cut\u00e9 !') } Le code s\u2019ex\u00e9cute si on clique sur OK et ne s\u2019ex\u00e9cute pas si on clique sur Annuler.","title":"La fonction confirm()"},{"location":"javascript/lesBasesDeJavaScript/#la-structure-if-else-if-else-pour-dire-sinon-si-sinon","text":"Une premi\u00e8re condition est test\u00e9e, une deuxi\u00e8me sera test\u00e9e si la premi\u00e8re \u00e9choue, et si aucune condition ne se v\u00e9rifie, la structure else fait alors son travail. if(/* condition */){ // Du code... }else if(/* condition */){ // Du code... }else{ // Du code... }","title":"La structure if, else if, else pour dire sinon si, sinon"},{"location":"javascript/lesBasesDeJavaScript/#la-condition-switch","text":"Tr\u00e8s pratique pour faire du cas par cas, il n\u2019est pas n\u00e9cessaire de r\u00e9\u00e9crire la condition \u00e0 chaque fois. var drawer = parseInt(prompt('Choisissez le tiroir \u00e0 ouvrir (1 \u00e0 3) :')); switch (drawer) { case 1: console.log('Contient divers outils pour dessiner : du papier, des crayons, etc.') break case 2: console.log('Contient du mat\u00e9riel informatique : des c\u00e2bles, des composants, etc.') break default: console.log(\"Info du jour : le meuble ne contient que 4 tiroirs et, jusqu'\u00e0 preuve du contraire, les tiroirs n\u00e9gatifs n'existent pas.\") } On \u00e9crit break \u00e0 la fin de chaque case pour casser le switch et \u00e9viter d\u2019ex\u00e9cuter le reste du code. L\u2019oubli du break fait ex\u00e9cuter tout le code \u00e0 partir du case choisi. Default sera ex\u00e9cut\u00e9 si aucun des cas pr\u00e9c\u00e9dents n\u2019a \u00e9t\u00e9 ex\u00e9cut\u00e9, partie optionnelle.","title":"La condition \u201cswitch\u201d"},{"location":"javascript/lesBasesDeJavaScript/#loperateur-ternaire","text":"C'est une syntaxe simplifi\u00e9e pour faire un if else mais un peu moins lisible : condition ? valeurSiTrue : valeurSiFalse Exemple : var gaetan = \"Ga\u00ebtan\" var louis = \"Louis\" var nomLePlusLong if(gaetan.length > louis.length){ nomLePlusLong = gaetan } else { nomLePlusLong = louis } console.log(nomLePlusLong) // affiche Ga\u00ebtan var nomLePlusLong2 = gaetan.length > louis.length ? gaetan : louis console.log(nomLePlusLong2) // affiche Ga\u00ebtan","title":"L'op\u00e9rateur Ternaire"},{"location":"javascript/lesBasesDeJavaScript/#les-conditions-sur-les-variables","text":"Tester l\u2019existence du contenu d\u2019une variable var conditionTest = 'Fonctionnera ? Fonctionnera pas ?' if (conditionTest) { console.log('Fonctionne !') } else { console.log('Ne fonctionne pas !') } Le code affiche le texte \u201cFonctionne\u201d car la variable conditionTest a \u00e9t\u00e9 convertie en bool\u00e9en et son contenu a \u00e9t\u00e9 \u00e9valu\u00e9 comme true. Pour qu\u2019il soit \u00e9valu\u00e9 comme false, il faut que que ce soit un nombre \u00e9gal \u00e0 0 ou une cha\u00eene de caract\u00e8res vide. La valeur undefined renvoie aussi false. Le cas de l\u2019op\u00e9rateur OU var conditionTest1 = '', conditionTest2 = 'Une cha\u00eene de caract\u00e8res' console.log(conditionTest1 || conditionTest2) L\u2019op\u00e9rateur OU en plus de sa fonction principale, permet de renvoyer la premi\u00e8re valeur \u00e9valu\u00e9e \u00e0 true. Dans cet exemple, elle renvoie donc Une cha\u00eene de caract\u00e8res .","title":"Les conditions sur les variables"},{"location":"javascript/lesBasesDeJavaScript/#-_5","text":"","title":"----"},{"location":"javascript/lesBasesDeJavaScript/#les-boucles","text":"","title":"Les boucles"},{"location":"javascript/lesBasesDeJavaScript/#la-boucle-while","text":"C\u2019est un r\u00e9p\u00e9tition d\u2019instruction jusqu\u2019\u00e0 ce qu\u2019on dise \u00e0 la boucle de s\u2019arr\u00eater. A chaque r\u00e9p\u00e9tition, on parle d\u2019it\u00e9ration. Tant que la condition est vraie, la boucle se r\u00e9p\u00e8te. while (condition) { instruction_1 instruction_2 } Il est possible d\u2019arr\u00eater la boucle avec le mot cl\u00e9 break . Il est possible de mettre fin \u00e0 une it\u00e9ration et faire continuer la boucle avec continue .","title":"La boucle while"},{"location":"javascript/lesBasesDeJavaScript/#la-boucle-do-while","text":"Elle ressemble \u00e0 la boucle while sauf qu\u2019elle est toujours ex\u00e9cut\u00e9e au moins une fois. Dans le cas d\u2019une boucle while, si la condition n\u2019est pas valide, la boucle n\u2019est pas ex\u00e9cut\u00e9e. Avec do while, la boucle est ex\u00e9cut\u00e9e une premi\u00e8re fois, puis la condition est test\u00e9e pour savoir si la boucle doit continuer. do { instruction_1 instruction_2 } while (condition) Utilisation tr\u00e8s peu fr\u00e9quente car il est possible d\u2019utiliser une boucle while normale avec une condition qui fait que celle-ci est toujours ex\u00e9cut\u00e9e une fois.","title":"La boucle do while"},{"location":"javascript/lesBasesDeJavaScript/#la-boucle-for","text":"Ressemble dans son fonctionnement \u00e0 la boucle while for (initialisation; condition; incr\u00e9mentation) { instruction_1 instruction_2 } L\u2019incr\u00e9mentation a lieu \u00e0 la fin de chaque it\u00e9ration. Le premier tour de boucle dans l\u2019exemple ci-dessous est donc fait avec iter=0. for (var iter = 0; iter < 5; iter++) { console.log('It\u00e9ration n\u00b0' + iter) // affiche 0 puis 1, 2, 3 et 4 } console.log(iter) // affiche 5 Port\u00e9e des variables de boucle En JavaScript, il est d\u00e9conseill\u00e9 de d\u00e9clarer des variables au sein d\u2019une boucle car il n\u2019est pas n\u00e9cessaire de d\u00e9clarer une variable \u00e0 chaque passage dans la boucle. Il est conseill\u00e9 de les d\u00e9clarer dans le bloc d\u2019initialisation, mais attention une fois la boucle ex\u00e9cut\u00e9e, la variable existe toujours. Ce comportement est diff\u00e9rent de celui de nombreux autres langages dans lesquels une variable d\u00e9clar\u00e9e dans une boucle est d\u00e9truite une fois la boucle ex\u00e9cut\u00e9e. Priorit\u00e9 d\u2019ex\u00e9cution Les trois blocs de la boucle for ne sont pas ex\u00e9cut\u00e9s en m\u00eame temps : - initialisation : juste avant que la boucle ne d\u00e9marre - condition : avant chaque passage de boucle - incr\u00e9mentation : apr\u00e8s chaque passage de boucle. Cela veut dire que si on fait un break dans une boucle for, le passage dans la boucle lors du break ne sera pas comptabilis\u00e9. La boucle for est tr\u00e8s utilis\u00e9e en JavaScript, bien plus que la boucle while . Le fonctionnement de JavaScript fait que la boucle for est n\u00e9cessaire dans la majorit\u00e9 des cas comme la manipulation des tableaux ainsi que des objets. Nous verrons aussi une variante de la boucle for , appel\u00e9e for in .","title":"La boucle for"},{"location":"javascript/lesBasesDeJavaScript/#-_6","text":"","title":"----"},{"location":"javascript/lesBasesDeJavaScript/#les-fonctions","text":"","title":"Les fonctions"},{"location":"javascript/lesBasesDeJavaScript/#concevoir-des-fonctions","text":"// d\u00e9claration d'une fonction function myFunction(arguments) { // Le code que la fonction va devoir ex\u00e9cuter } myFunction() // ex\u00e9cution de la fonction L\u2019utilit\u00e9 basique des fonctions est d\u2019\u00e9viter la r\u00e9p\u00e9tition de code. Le code \u00e9crit dans une fonction ne s'ex\u00e9cute pas imm\u00e9diatement, sinon l'int\u00e9r\u00eat serait nul. Pour cela il faut appeler la fonction afin de l'ex\u00e9cuter.","title":"Concevoir des fonctions"},{"location":"javascript/lesBasesDeJavaScript/#la-portee-des-variables","text":"Toute variable d\u00e9clar\u00e9e dans une fonction n\u2019est utilisable que dans cette m\u00eame fonction, appel\u00e9e variable locale . Lorsqu\u2019une variable n\u2019est accessible que dans une partie du code, on dit qu\u2019elle se trouve au sein d\u2019un \u201cscope\u201d. Les variables d\u00e9clar\u00e9es en-dehors des fonctions sont appel\u00e9es variables globales , car elles sont accessibles partout dans le code, y compris dans les fonctions. Si on cr\u00e9e une variable locale avec le m\u00eame nom qu\u2019une variable globale, la variable locale prend le dessus le temps de l\u2019ex\u00e9cution de la fonction. Par principe, il faut d\u00e9clarer les variables qui ne servent que dans une fonction \u00e0 l\u2019int\u00e9rieur de celle-ci et non pas de mani\u00e8re globale.","title":"La port\u00e9e des variables"},{"location":"javascript/lesBasesDeJavaScript/#les-arguments-et-les-valeurs-de-retour","text":"function myFunction(arg) { console.log('Votre argument : ' + arg) } function moar(first, second) { // On peut maintenant utiliser les variables \u00ab first \u00bb et \u00ab second \u00bb comme on le souhaite : console.log('Votre premier argument : ' + first) console.log('Votre deuxi\u00e8me argument : ' + second) } Les arguments sont propres \u00e0 leur fonction, ils ne seront accessibles que dans cette fonction et nulle part ailleurs. Les valeurs de retour Chaque fonction ne peut retourner qu\u2019une seule et unique valeur. Il est possible de contourner le probl\u00e8me en renvoyant un tableau ou un objet. L\u2019instruction return met fin \u00e0 la fonction puis retourne la valeur. function sayHello() { return 'Bonjour !' } console.log(sayHello()) // on affiche la valeur retourn\u00e9e par la fonction sayHello()","title":"Les arguments et les valeurs de retour"},{"location":"javascript/lesBasesDeJavaScript/#les-fonctions-anonymes","text":"Elles sont extr\u00eamement importantes en JavaScript. Elles servent pour les objets, les \u00e9v\u00e9nements, les variables statiques, les closures\u2026 Elles n\u2019ont pas de nom ! C\u2019est la seule diff\u00e9rence avec une fonction traditionnelle. function (arguments) { // Le code de votre fonction anonyme } Pour l\u2019appeler, il existe de tr\u00e8s nombreuses fa\u00e7ons de faire. Pour le moment, il faut se limiter \u00e0 une seule solution : assigner la fonction \u00e0 une variable. var sayHello = function(){ console.log('Bonjour !') } sayHello() // Affiche : \u00ab Bonjour ! \u00bb La variable sayHello est devenue une fonction.","title":"Les fonctions anonymes"},{"location":"javascript/lesBasesDeJavaScript/#-_7","text":"","title":"----"},{"location":"javascript/lesBasesDeJavaScript/#les-objets-et-les-tableaux","text":"","title":"Les objets et les tableaux"},{"location":"javascript/lesBasesDeJavaScript/#introduction-aux-objets","text":"JavaScript est un langage orient\u00e9 objet, cela veut dire que le langage dispose d\u2019objets, qui disposent d\u2019une structure. JavaScript met \u00e0 notre disposition des objets natifs : un nombre, une cha\u00eene de caract\u00e8res, un bool\u00e9en. On dit que JavaScript n\u2019est pas un langage typ\u00e9 car les variables contiennent toujours la m\u00eame chose : un objet. Cet objet peut \u00eatre de nature diff\u00e9rente (nombre, bool\u00e9en\u2026). Il est \u00e9galement possible de cr\u00e9er nos propres objets, ce qui sera apr\u00e8s. Les objets contiennent trois choses distinctes : - un constructeur - code utilis\u00e9 quand on utilise un nouvel objet - permet d\u2019effectuer des actions comme d\u00e9finir diverses variables - r\u00e9alis\u00e9 automatiquement pour les objets natifs - des propri\u00e9t\u00e9s - une propri\u00e9t\u00e9 est une variable contenue dans l\u2019objet - des m\u00e9thodes - il est possible de modifier l\u2019objet gr\u00e2ce aux m\u00e9thodes qui sont des fonctions contenues dans l\u2019objet, qui permettent de r\u00e9aliser des op\u00e9rations sur le contenu de l\u2019objet var myString = 'Ceci est une cha\u00eene de caract\u00e8res' // On cr\u00e9e un objet String console.log(myString.length) // On affiche le nombre de caract\u00e8res, au moyen de la propri\u00e9t\u00e9 \u00ab length \u00bb console.log(myString.toUpperCase()) // On r\u00e9cup\u00e8re la cha\u00eene en majuscules, avec la m\u00e9thode toUpperCase() Le point apr\u00e8s un objet permet d\u2019acc\u00e9der aux propri\u00e9t\u00e9s et aux m\u00e9thodes d\u2019un objet. Nous avons d\u00e9j\u00e0 d\u00e9couvert trois objets natif : Number, Boolean, String. On allons maintenant d\u00e9couvrir l\u2019objet Array qui g\u00e8re les tableaux.","title":"Introduction aux objets"},{"location":"javascript/lesBasesDeJavaScript/#les-tableaux","text":"Un tableau, array en anglais, contient plusieurs valeurs appel\u00e9es item . Chaque item est accessible au moyen d\u2019un indice dont la num\u00e9rotation commence \u00e0 0. var myArray = [1, 2, 3, 4, 5] console.log(myArray.length) // affiche 5 console.log(myArray[0]) // affiche 1, le premier \u00e9l\u00e9ment du tableau myArray[0]=8 // modifie la valeur du premier \u00e9l\u00e9ment du tableau console.log(myArray[0]) // affiche 8, le premier \u00e9l\u00e9ment du tableau console.log(myArray[myArray.length-1]) // affiche 5, le dernier \u00e9l\u00e9ment du tableau Pour plus de d\u00e9tails sur les tableaux, voir la partie Objets et fonctions utiles en JavaScript .","title":"Les tableaux"},{"location":"javascript/lesBasesDeJavaScript/#les-objets-litteraux","text":"","title":"Les objets litt\u00e9raux"},{"location":"javascript/lesBasesDeJavaScript/#la-syntaxe-dun-objet","text":"Il est possible d\u2019acc\u00e9der aux propri\u00e9t\u00e9s d'un objet via un identifiant. Un objet est similaire \u00e0 un tableau sauf que l\u2019on met des accolades \u00e0 la place des crochets. var myObject = { propertyName1: propertyValue1, propertyName2: propertyValue2, methode1: function(){ } } Pour d\u00e9finir d\u00e8s l\u2019initialisation les items \u00e0 ajouter, il suffit d\u2019\u00e9crire l\u2019identifiant suivi de deux points et de la valeur \u00e0 lui attribuer. La s\u00e9paration des items se fait comme pour un tableau, avec une virgule. var louis = { prenom: 'Louis', nom: 'Varlet', direPapa: function(){ console.log(\"Papa !\") } } // Acc\u00e8s aux propri\u00e9t\u00e9s console.log(louis) // permet d'acc\u00e9der \u00e0 l'objet louis console.log(typeof louis) // affiche object console.log(louis.prenom) // affiche Louis console.log(louis[\"prenom\"]) // affiche Louis (m\u00e9thode est utile si l\u2019identifiant est contenu dans une variable) // Ajouter une propri\u00e9t\u00e9 en sp\u00e9cifiant un identifiant qui n\u2019est pas encore pr\u00e9sent. console.log(louis.age) // affiche undefined louis.age = 1 console.log(louis.age) // affiche 1 louis[\"prenomPere\"] = \"Ga\u00ebtan\" // on peut aussi le faire avec les crochets console.log(louis.prenomPere) // affiche Ga\u00ebtan // Ex\u00e9cution d'une m\u00e9thode louis.direPapa() // affiche Papa ! Autre fa\u00e7on de cr\u00e9er un objet : var gaetan = new Object() gaetan.prenom = 'Ga\u00ebtan' gaetan.nom = 'Varlet'","title":"La syntaxe d\u2019un objet"},{"location":"javascript/lesBasesDeJavaScript/#parcourir-un-objet-avec-for-in","text":"Il n\u2019est pas possible d\u2019utiliser une boucle for car elle incr\u00e9mente une variable num\u00e9rique ce qui est inutile sur un objet litt\u00e9ral puisque nous devons poss\u00e9der un identifiant. La boucle for in ne sert qu\u2019\u00e0 une chose : parcourir un objet. Le fonctionnement est quasiment le m\u00eame que pour un tableau, except\u00e9 qu\u2019il suffit de fournir une \u201cvariable cl\u00e9\u201d qui re\u00e7oit un identifiant (au lieu d\u2019un index) et de sp\u00e9cifier l\u2019objet \u00e0 parcourir : const louis = { prenom: \"Louis\", nom: \"Varlet\" } for(let property in louis){ console.log(louis[property]) } // affiche Louis // affiche Varlet","title":"Parcourir un objet avec for in"},{"location":"javascript/lesBasesDeJavaScript/#utilisation-des-objets-litteraux","text":"Ils peuvent \u00eatre utile pour ordonner un code. On les utilise aussi dans les fonctions, car return ne sait retourner qu\u2019une seule variable. Avec un objet, il est possible de retourner plusieurs variables en stockant les r\u00e9sultats dans l\u2019objet, plus commode qu\u2019un tableau. Exemple d\u2019une fonction qui calcule des coordonn\u00e9es d\u2019un \u00e9l\u00e9ment HTML sur une page Web et retourne les coordonn\u00e9es x et y : function getCoords() { /* Script incomplet, juste pour l'exemple */ return { x: 12, y: 21 } } var coords = getCoords() console.log(coords.x) // 12 console.log(coords.y) // 21","title":"Utilisation des objets litt\u00e9raux"},{"location":"javascript/lesBasesDeJavaScript/#les-constructeurs","text":"Ils permettent de cr\u00e9er un moule pour cr\u00e9er plusieurs objets \u00e0 partir de ce moule function Dog(name, color, age){ this.name = name this.color = color this.age = age this.aboie = function(){ console.log(\"wouf wouf \"+this.name) } } var monChien = new Dog(\"Rex\", \"noir\", 6) console.log(monChien); // affiche le chien monChien.aboie(); // affiche : wouf wouf Rex","title":"Les constructeurs"},{"location":"javascript/modelerVosPagesWeb/","text":"Manipuler le code HTML (partie 1/2) Manipuler le code HTML (partie 2/2) Naviguer entre les noeuds La propri\u00e9t\u00e9 parentNode Elle permet d'acc\u00e9der \u00e0 l'\u00e9l\u00e9ment parent d'un \u00e9l\u00e9ment. <blockquote> <p id=\"myP\">Ceci est un paragraphe !</p> </blockquote> var paragraph = document.getElementById('myP'); var blockquote = paragraph.parentNode; nodeType et nodeName permettent de v\u00e9rifier le type d'un noeud et le nom d'un noeud. nodeType retourne un nombre qui correspond \u00e0 un type de noeud : 1 pour noeuf \u00e9l\u00e9ment, 2 pour noeud attribut, 3 pour noeud texte... firstChild et lastChild permettent d'acc\u00e9der au premier et au dernier enfant d'un noeud. Dans l'exemple suivant, le premier enfant de <p> est un noeud textuel, le dernier enfant un \u00e9l\u00e9ment <strong> . Il existe aussi les prorpri\u00e9t\u00e9s firstElementChild et lastElementChild pour \u00e9viter les noeuds #text . <p id=\"myP\">Un peu de texte, <a>un lien</a> et <strong>une portion en emphase</strong></p> var paragraph = document.getElementById('myP'); var first = paragraph.firstChild; var last = paragraph.lastChild; Autres propri\u00e9t\u00e9s nodeValue et data sont des propri\u00e9t\u00e9s qui s'appliquent sur des noeuds textuels et affichent le contenu var paragraph = document.getElementById('myP'); var first = paragraph.firstChild; var last = paragraph.lastChild; alert(first.nodeValue); alert(last.firstChild.data); childNodes est une propri\u00e9t\u00e9 qui retourne un tableau contenant la liste des enfants d'un \u00e9l\u00e9ment nextSibling et previousSibling permettent d'acc\u00e9der au noeud suivant et pr\u00e9c\u00e9dent Attention au noeuds vides <div> <p>Paragraphe 1</p> <p>Paragraphe 2</p> <p>Paragraphe 3</p> </div> <div><p>Paragraphe 1</p><p>Paragraphe 2</p><p>Paragraphe 3</p></div> Les espaces ou les retours \u00e0 la ligne sont consid\u00e9r\u00e9s comme des noeuds textuels dans certains navigateurs. Dans le premier exemple, on a donc 7 noeuds enfants dans la <div> : un #text vide suivi d'un <p> suivi d'un #text vide... alors que dans le deuxi\u00e8me exemple, on a 3 noeuds enfants qui sont des <p> . Pour \u00e9viter ces noeuds textuels vides, il faut utiliser les attributs firstElementChild , lastElementChild , nextElementSibling et previousElementSibling qui ne retournent que les \u00e9l\u00e9ments HTML et ignorent donc les noeuds textuels. Cr\u00e9er et ins\u00e9rer des \u00e9l\u00e9ments Pour ajouter des \u00e9l\u00e9ments HTML avec le DOM il faut : - cr\u00e9er l'\u00e9l\u00e9ment - se fait avec la m\u00e9thode createElement() - var newLink = document.createElement('a'); cr\u00e9e un \u00e9l\u00e9ment <a> mais celui-ci n'est pas ins\u00e9r\u00e9 dans le document, il n'est donc pas visible - lui affecter des attributs - on d\u00e9finit des attributs soit avec setAttribute() , soit directement avec les propri\u00e9t\u00e9s ad\u00e9quates - newLink.id = 'sdz_link'; ou newLink.setAttribute('tabindex', '10'); - l'ins\u00e9rer dans le document - se fait avec la m\u00e9thode appendChild() - par exemple document.getElementById('myP').appendChild(newLink); ajoute notre \u00e9l\u00e9ment <a> dans l'\u00e9l\u00e9ment <p> portant l'ID myP en tant que dernier enfant Ajouter des noeuds textuels La m\u00e9thode createTextNode() sert \u00e0 cr\u00e9er un noeud de type #text . Il faut ensuite l'ins\u00e9rer avec la m\u00e9thode appendChild() sur l'\u00e9l\u00e9ment newLink . var newLinkText = document.createTextNode(\"Le Site du Z\u00e9ro\"); newLink.appendChild(newLinkText); Notions sur les r\u00e9f\u00e9rences En JavaScript, le contenu des variables est pass\u00e9 par valeur , c'est-\u00e0-dire que si on affecte la valeur d'une variable \u00e0 une autre variable, la valeur est copi\u00e9e dans une nouvelle, on a donc deux variables distinctes. Si on change la valeur d'une deux deux variables, l'autre reste inchang\u00e9. JavaScript poss\u00e8de aussi aussi un passage par r\u00e9f\u00e9rence , c'est-\u00e0-dire qu'on transmet l'adresse de la valeur, on peut donc avoir plusieurs variables qui pointent sur une m\u00eame valeur. On verra des exemples avec la cr\u00e9ation d'objets. Le concept de r\u00e9f\u00e9rence se retrouve avec le DOM : deux variables peuvent acc\u00e9der au m\u00eame \u00e9l\u00e9ment. Dans l'exemple suivant, la variable newLink contient une r\u00e9f\u00e9rence vers l'\u00e9l\u00e9ment <a> cr\u00e9\u00e9 (une adresse qui pointe vers <a> ). Une fois l'\u00e9l\u00e9ment HTML ins\u00e9r\u00e9 dans la page, on peut y acc\u00e9der de nombreuses fa\u00e7ons, comme avec getElementById . var newLink = document.createElement('a'); var newLinkText = document.createTextNode('Le Site du Z\u00e9ro'); newLink.id = 'sdz_link'; newLink.href = 'http://www.siteduzero.com'; newLink.appendChild(newLinkText); document.getElementById('myP').appendChild(newLink); Il faut retenir que les objets du DOM sont toujours accessibles par r\u00e9f\u00e9rence. On ne peut donc pas copier un \u00e9l\u00e9ment de la mani\u00e8re suivante, car les deux variables pointent vers le m\u00eame \u00e9l\u00e9ment. Pour duppliquer un \u00e9l\u00e9ment, il va faloir le cl\u00f4ner. var newDiv1 = document.createElement('div'); var newDiv2 = newDiv1; // On tente de copier le <div> Cl\u00f4ner, remplacer, supprimer cloneNode() permet de cloner un \u00e9l\u00e9ment, avec un param\u00e8tre \u00e0 renseigner \u00e0 true ou false si on souhaite cl\u00f4ner le noeud avec ou sans ses enfants et ses diff\u00e9rents attributs. Attention, les \u00e9v\u00e9nements ne sont pas copi\u00e9s. // On va cloner un \u00e9l\u00e9ment cr\u00e9\u00e9 : var hr1 = document.createElement('hr'); var hr2 = hr1.cloneNode(false); // Il n'a pas d'enfants\u2026 // Ici, on clone un \u00e9l\u00e9ment existant : var paragraph1 = document.getElementById('myP'); var paragraph2 = paragraph1.cloneNode(true); // Et attention, l'\u00e9l\u00e9ment est clon\u00e9, mais pas \u00ab ins\u00e9r\u00e9 \u00bb tant que l'on n'a pas appel\u00e9 appendChild() : paragraph1.parentNode.appendChild(paragraph2); replaceChild() permet de remplacer un \u00e9l\u00e9ment par un autre. Il y a deux param\u00e8tres : le nouvel \u00e9l\u00e9ment et l'\u00e9l\u00e9ment \u00e0 remplacer <body> <div> <p id=\"myP\">Un peu de texte <a>et un lien</a></p> </div> <script> var link = document.querySelector('a'); var newLabel = document.createTextNode('et un hyperlien'); link.replaceChild(newLabel, link.firstChild); </script> </body> removeChild() permet de supprimer un \u00e9l\u00e9ment. La m\u00e9thode prend en param\u00e8tre le noeud enfant \u00e0 retirer. La m\u00e9thode retourne l'\u00e9l\u00e9ment supprim\u00e9, il est donc possible de supprimer un \u00e9l\u00e9ment HTML et de la r\u00e9int\u00e9grer ensuite. var link = document.querySelector('a'); link.parentNode.removeChild(link); Autres actions hasChildNodes appliqu\u00e9e sur un \u00e9l\u00e9ment renvoie true si l'\u00e9l\u00e9ment poss\u00e8de au moins un enfant, false sinon insertBefore permet d'ins\u00e9rer un \u00e9l\u00e9ment avant un autre, avec en param\u00e8tre l'\u00e9l\u00e9ment \u00e0 ins\u00e9rer et l'\u00e9l\u00e9ment avant lequel ins\u00e9rer l'\u00e9l\u00e9ment ---- Les \u00e9v\u00e9nements Que sont les \u00e9v\u00e9nements Les \u00e9v\u00e9nements permettent de d\u00e9clencher une fonction selon qu'une action s'est produite ou non, par exemple faire appara\u00eetre une fen\u00eatre alert() au survol d'une zone d'un \u00e9l\u00e9ment. Liste des \u00e9v\u00e9nements click : cliquer (appuyer puis rel\u00e2cher) sur l'\u00e9l\u00e9ment dblclick : double-cliquer sur l'\u00e9l\u00e9ment mouseover : faire entrer le curseur sur l'\u00e9l\u00e9ment mouseout : faire sortir le curseur de l'\u00e9l\u00e9ment mousedown : appuyer (sans rel\u00e2cher) sur le bouton gauche de la souris sur l'\u00e9l\u00e9ment mouseup : rel\u00e2cher le bouton gauche de la souris sur l'\u00e9l\u00e9ment mousemove : faire d\u00e9placer le curseur sur l'\u00e9l\u00e9ment keydown : appuyer (sans rel\u00e2cher) sur une touche de clavier sur l'\u00e9l\u00e9ment keyup : rel\u00e2cher une touche de clavier sur l'\u00e9l\u00e9ment keypress : frapper (appuyer puis rel\u00e2cher) une touche de clavier sur l'\u00e9l\u00e9ment focus : cibler l'\u00e9l\u00e9ment, pour qu'il re\u00e7oive tous les \u00e9v\u00e9nement du clavier blur : annuler le ciblage de l'\u00e9l\u00e9ment input : taper un caract\u00e8re dans un champ texte (support incomplet selon les navigateurs) select : s\u00e9lectionner le contenu d'un champ de texte (input, textarea...) Il existe aussi deux \u00e9v\u00e9n\u00e9ments sp\u00e9cifiques \u00e0 l'\u00e9l\u00e9ment form - submit pour envoyer le formulaire - reset pour r\u00e9initialiser le formulaire Utiliser les \u00e9v\u00e9n\u00e9ments sans le DOM l'\u00e9v\u00e9nement click . Dans l'exemple, il permet en cliquant sur le texte d'afficher la boite de dialogue <span onclick=\"alert('Hello !');\">Cliquez-moi !</span> le mot cl\u00e9 this est une propri\u00e9t\u00e9 pointant sur l'objet courant. L'appel \u00e0 ce mot-cl\u00e9 lors d'un \u00e9v\u00e9nement fait que l'objet point\u00e9 est l'\u00e9l\u00e9ment qui a d\u00e9clanch\u00e9 l'\u00e9v\u00e9nement <span onclick=\"alert('Voici le contenu de l\\'\u00e9l\u00e9ment que vous avez cliqu\u00e9 :\\n\\n' + this.innerHTML);\">Cliquez-moi !</span> le focus. Dans l'exemple, lorsqu'on clique sur l'input, il poss\u00e8de le focus et ex\u00e9cute l'\u00e9v\u00e9nement focus . Lorsque l'input perd le focus, cela d\u00e9clenche l'\u00e9v\u00e9nement blur <input id=\"input\" type=\"text\" size=\"50\" value=\"Cliquez ici !\" onfocus=\"this.value='Appuyez maintenant sur votre touche de tabulation.';\" onblur=\"this.value='Cliquez ici !';\"/> <br /><br/> <a href=\"#\" onfocus=\"document.getElementById('input').value = 'Vous avez maintenant le focus sur le lien, bravo !';\">Un lien bidon</a> bloquer l'action par d\u00e9faut. Par exemple, ne pas rediriger vers l'URL indiqu\u00e9 lorsqu'on clique sur un lien, en ajoutant dans return false; dans l'\u00e9v\u00e9n\u00e9ment . On peut \u00e9ventuellement mettre \"#\" dans le href, ce qui redirige en haut de la page Web <a href=\"http://www.siteduzero.com\" onclick=\"alert('Vous avez cliqu\u00e9 !'); return false;\">Cliquez-moi !</a> Par ailleurs, la balise <a> est con\u00e7ue pour rediriger vers une page Web et non pour servir de d\u00e9clencheur. Pour cela, utiliser une balise <button> a\u00e0 laquelle on retire le style CSS Les \u00e9v\u00e9nements au travers du DOM Le DOM-0 interface ancienne impl\u00e9ment\u00e9e par Netscape, appel\u00e9e DOM-0 on d\u00e9finit les \u00e9v\u00e9nements non plus dans le code HTML mais directement en JavaScript. Chaque \u00e9v\u00e9nement standard poss\u00e8de une propri\u00e9t\u00e9 dont le nom est pr\u00e9c\u00e9d\u00e9 des deux lettres \"on\". Cette propri\u00e9t\u00e9 prend pour valeur une fonction ou une fonction anonyme pour supprimer un \u00e9v\u00e9nement avec le DOM-0, il fait lui attribuer une fonction anonyme vide element.onclick = function() {}; <span id=\"clickme\">Cliquez-moi !</span> <script> var element = document.getElementById('clickme'); element.onclick = function() { alert(\"Vous m'avez cliqu\u00e9 !\"); }; </script> Le DOM-2 la m\u00e9thode sans le DOM ne permet pas d'acc\u00e9der \u00e0 l'objet Event qui contient beaucoup d'informations sur l'\u00e9v\u00e9nement d\u00e9clench\u00e9 le DOM-0 est vieux et ne permet pas de cr\u00e9er plusieurs fois le m\u00eame \u00e9v\u00e9nement le DOM-2 permet la cr\u00e9ation multiple d'un m\u00eame \u00e9v\u00e9nement et g\u00e8re aussi l'objet Event <span id=\"clickme\">Cliquez-moi !</span> <script> var element = document.getElementById('clickme'); element.addEventListener('click', function() { alert(\"Vous m'avez cliqu\u00e9 !\"); }); </script> Dans cet exemple, ce qui change par rapport au DOM-0 et qu'on n'utilise plus une propri\u00e9t\u00e9 mais la m\u00e9thode addEventListener() qui prend 3 param\u00e8tres : le nom de l'\u00e9v\u00e9n\u00e9ment sans \"on, la fonction \u00e0 ex\u00e9cuter, et un bool\u00e9en optionnel pour sp\u00e9cifier si on souhaite utiliser la phase de capture ou de bouillennement (cf ci-apr\u00e8s) On peut cr\u00e9er deux \u00e9v\u00e9nements identiques pour un m\u00eame \u00e9l\u00e9ment. Ainsi, lors du d\u00e9clenchement, les 2 \u00e9v\u00e9nements seront ex\u00e9cut\u00e9s. <span id=\"clickme\">Cliquez-moi !</span> <script> var element = document.getElementById('clickme'); // Premier \u00e9v\u00e9nement click element.addEventListener('click', function() { alert(\"Et de un !\"); }); // Deuxi\u00e8me \u00e9v\u00e9nement click element.addEventListener('click', function() { alert(\"Et de deux !\"); }); </script> Pour supprimer un \u00e9v\u00e9nement, il faut utiliser la m\u00e9thode removeEventListener() avec les m\u00eames param\u00e8tres utilis\u00e9s lors de sa cr\u00e9ation element.addEventListener('click', myFunction); // On cr\u00e9e l'\u00e9v\u00e9nement element.removeEventListener('click', myFunction); // On supprime l'\u00e9v\u00e9nement en lui repassant les m\u00eames param\u00e8tres Les phases de capture et de bouillonnement Ce sont deux \u00e9tapes distinctes de l'ex\u00e9cution d'un \u00e9v\u00e9nement. La capture s'ex\u00e9cute avant le d\u00e9clenchement de l'\u00e9v\u00e9nement tandis que le bouillonnement s'ex\u00e9cute apr\u00e8s le d\u00e9clenchement de l'\u00e9v\u00e9nement. Elles permettent de d\u00e9finir le sens de propagation des \u00e9v\u00e9nements <div> <span>Du texte !</span> </div> Dans cet exemple, si on attribue une fonction \u00e0 l'\u00e9v\u00e9nement click de chacun de ces deux \u00e9l\u00e9ments, quel \u00e9v\u00e9nement va se d\u00e9clencher en premier ? Avec la capture, l'\u00e9v\u00e9nement du <div> se d\u00e9clenchera en premier suivi de celui du <span> . Avec le bouillonnement, l'\u00e9v\u00e9nement du <span> se d\u00e9clenchera d'abord. La phase de bouillonnement est d\u00e9finie par d\u00e9faut et celle qu'on utilise le plus souvent. L'objet Event L'objet Event fournit une multitude d'informations sur l'\u00e9v\u00e9nement actuellement d\u00e9clench\u00e9, comme les touches actuellement enfonc\u00e9s, les coordonn\u00e9es du curseur, l'\u00e9l\u00e9ment qui a d\u00e9clench\u00e9 l'\u00e9v\u00e9nement... Cet objet n'est accessible que lorsqu'on \u00e9v\u00e9nement est d\u00e9clench\u00e9, dans une fonction ex\u00e9cut\u00e9e par un \u00e9v\u00e9nement element.addEventListener('click', function(e) { // L'argument \u00ab e \u00bb va r\u00e9cup\u00e9rer une r\u00e9f\u00e9rence vers l'objet \u00ab Event \u00bb alert(e.type); // Ceci affiche le type de l'\u00e9v\u00e9nement (click, mouseover, etc.) }); la propri\u00e9t\u00e9 type permet de savoir quel type d'\u00e9v\u00e9nement s'est d\u00e9clench\u00e9 la propri\u00e9t\u00e9 target permet de r\u00e9cup\u00e9rer l'\u00e9l\u00e9ment de l'\u00e9v\u00e9nement actuellement d\u00e9clench\u00e9, pour par exemple modifier le contenu d'un \u00e9l\u00e9ment cliqu\u00e9 <span id=\"clickme\">Cliquez-moi !</span> <script> var clickme = document.getElementById('clickme'); clickme.addEventListener('click', function(e) { e.target.innerHTML = 'Vous avez cliqu\u00e9 !'; }); </script> la propri\u00e9t\u00e9 currentTarget permet de conna\u00eetre l'\u00e9l\u00e9ment \u00e0 l'origine de l'\u00e9v\u00e9nement, alors que target permet de conna\u00eetre l'\u00e9l\u00e9ment d\u00e9clencheur qui peut \u00eatre un \u00e9l\u00e9ment enfant. Il s'utilise de la m\u00eame mani\u00e8re que target r\u00e9cup\u00e9rer la position du curseur, g\u00e9n\u00e9ralement par raport au coin sup\u00e9rieur gauche de la page Web, ou aussi au coin sup\u00e9rieur gauche de l'\u00e9cran. Il faut utiliser les propri\u00e9t\u00e9s clientX et clientY pour les positons horizontales et verticales. Souvent combin\u00e9 avec l'\u00e9v\u00e9nement mousemove car la position change \u00e0 chaque d\u00e9placement de la souris <div id=\"position\"></div> <script> var position = document.getElementById('position'); document.addEventListener('mousemove', function(e) { position.innerHTML = 'Position X : ' + e.clientX + 'px<br />Position Y : ' + e.clientY + 'px'; }); </script> la propri\u00e9t\u00e9 relatedTarget permet de r\u00e9cup\u00e9rer l'\u00e9l\u00e9ment en relation avec un \u00e9v\u00e9nement de souris. Elle ne s'utilise qu'avec les \u00e9v\u00e9nements mouseover (objet de l'\u00e9l\u00e9ment dont le curseur vient de sortir) et mouseout (objet de l'\u00e9l\u00e9ment sur lequel le curseur vient d'entrer) r\u00e9cup\u00e9rer les touches frapp\u00e9es par l'utilisateur, se fait par le biais de trois \u00e9v\u00e9nements les \u00e9v\u00e9nements keyup et keydown servent \u00e0 capter toutes les frappes des touches, ils retournent un caract\u00e8re majuscule que la touche Maj soit press\u00e9e ou non l'\u00e9v\u00e9nement keypress sert \u00e0 capter les touches qui \u00e9crivent. En tapant Maj+A, keypress d\u00e9tectera nien un A majuscule il existe trois propri\u00e9t\u00e9s capables de fournir une valeur : keyCode , charCode et which . keyCode est suffisante bloquer l'action par d\u00e9faut de certains \u00e9v\u00e9nements avec DOM-2, avec la m\u00e9thode preventDefault() <a id=\"link\" href=\"http://www.siteduzero.com\">Cliquez-moi !</a> <script> var link = document.getElementById('link'); link.addEventListener('click', function(e) { e.preventDefault(); // On bloque l'action par d\u00e9faut de cet \u00e9v\u00e9nement alert('Vous avez cliqu\u00e9 !'); }); </script> R\u00e9soudre les probl\u00e8mes d'h\u00e9ritage des \u00e9v\u00e9nements Parfois, un \u00e9v\u00e9nement appliqu\u00e9 sur un parent se propage \u00e0 ses enfants. Cet h\u00e9ritage des \u00e9v\u00e9nements peut provoquer des comportements inattendus. C'est le cas des \u00e9v\u00e9nements mouseover , mouseout , mousemove , click ... Pour r\u00e9gler cela, il faut utiliser la propri\u00e9t\u00e9 relatedTarget pour d\u00e9tecter quel est l'\u00e9l\u00e9ment vers lequel le curseur se dirige ou de quel \u00e9l\u00e9ment il provient. ---- Les formulaires Les propri\u00e9t\u00e9s On va s'int\u00e9resser aux propri\u00e9t\u00e9s sp\u00e9cifiques aux \u00e9l\u00e9ments d'un formulaire : value , disabled , checked ... La propri\u00e9t\u00e9 value Elle permet de d\u00e9finir une valeur pour diff\u00e9rents \u00e9l\u00e9ments d'un formulaire comme les <input> en lui assignant une valeur et elle est affich\u00e9e sur l'\u00e9l\u00e9ment HTML. Elle s'utilise aussi avec l'\u00e9l\u00e9ment <textarea> . Pour ce dernier, on ne peut pas utiiser innerHTML <input id=\"text\" type=\"text\" size=\"60\" value=\"Vous n'avez pas le focus !\" /> <script> var text = document.getElementById('text'); text.addEventListener('focus', function(e) { e.target.value = \"Vous avez le focus !\"; }); text.addEventListener('blur', function(e) { e.target.value = \"Vous n'avez pas le focus !\"; }); </script> Les bool\u00e9ens avec disabled , checked et readonly En HTML, ces 3 propri\u00e9t\u00e9s s'utilisent de la mani\u00e8re suivante : <input type=\"text\" disabled=\"disabled\" /> . En JavaScript, ces propri\u00e9t\u00e9s sont des bool\u00e9ens. <input id=\"text\" type=\"text\" /> <script> var text = document.getElementById('text'); text.disabled = true; </script> Pour les boutos de type radio, on peut utiliser la m\u00e9thode querySelectorAll() <label><input type=\"radio\" name=\"check\" value=\"1\" /> Case n\u00b01</label><br /> <label><input type=\"radio\" name=\"check\" value=\"2\" /> Case n\u00b02</label><br /> <label><input type=\"radio\" name=\"check\" value=\"3\" /> Case n\u00b03</label><br /> <label><input type=\"radio\" name=\"check\" value=\"4\" /> Case n\u00b04</label> <br /><br /> <input type=\"button\" value=\"Afficher la case coch\u00e9e\" onclick=\"check();\" /> <script> function check() { var inputs = document.querySelectorAll('input[type=radio]:checked'), inputsLength = inputs.length; for (var i = 0; i < inputsLength; i++) { alert('La case coch\u00e9e est la n\u00b0' + inputs[i].value); } } </script> Les listes d\u00e9roulantes avec selectedIndex et options","title":"Modeler vos pages web (RECUP DES CHOSES PUIS SUPPRIMER)"},{"location":"javascript/modelerVosPagesWeb/#manipuler-le-code-html-partie-12","text":"","title":"Manipuler le code HTML (partie 1/2)"},{"location":"javascript/modelerVosPagesWeb/#manipuler-le-code-html-partie-22","text":"","title":"Manipuler le code HTML (partie 2/2)"},{"location":"javascript/modelerVosPagesWeb/#naviguer-entre-les-noeuds","text":"","title":"Naviguer entre les noeuds"},{"location":"javascript/modelerVosPagesWeb/#la-propriete-parentnode","text":"Elle permet d'acc\u00e9der \u00e0 l'\u00e9l\u00e9ment parent d'un \u00e9l\u00e9ment. <blockquote> <p id=\"myP\">Ceci est un paragraphe !</p> </blockquote> var paragraph = document.getElementById('myP'); var blockquote = paragraph.parentNode; nodeType et nodeName permettent de v\u00e9rifier le type d'un noeud et le nom d'un noeud. nodeType retourne un nombre qui correspond \u00e0 un type de noeud : 1 pour noeuf \u00e9l\u00e9ment, 2 pour noeud attribut, 3 pour noeud texte... firstChild et lastChild permettent d'acc\u00e9der au premier et au dernier enfant d'un noeud. Dans l'exemple suivant, le premier enfant de <p> est un noeud textuel, le dernier enfant un \u00e9l\u00e9ment <strong> . Il existe aussi les prorpri\u00e9t\u00e9s firstElementChild et lastElementChild pour \u00e9viter les noeuds #text . <p id=\"myP\">Un peu de texte, <a>un lien</a> et <strong>une portion en emphase</strong></p> var paragraph = document.getElementById('myP'); var first = paragraph.firstChild; var last = paragraph.lastChild;","title":"La propri\u00e9t\u00e9 parentNode"},{"location":"javascript/modelerVosPagesWeb/#autres-proprietes","text":"nodeValue et data sont des propri\u00e9t\u00e9s qui s'appliquent sur des noeuds textuels et affichent le contenu var paragraph = document.getElementById('myP'); var first = paragraph.firstChild; var last = paragraph.lastChild; alert(first.nodeValue); alert(last.firstChild.data); childNodes est une propri\u00e9t\u00e9 qui retourne un tableau contenant la liste des enfants d'un \u00e9l\u00e9ment nextSibling et previousSibling permettent d'acc\u00e9der au noeud suivant et pr\u00e9c\u00e9dent","title":"Autres propri\u00e9t\u00e9s"},{"location":"javascript/modelerVosPagesWeb/#attention-au-noeuds-vides","text":"<div> <p>Paragraphe 1</p> <p>Paragraphe 2</p> <p>Paragraphe 3</p> </div> <div><p>Paragraphe 1</p><p>Paragraphe 2</p><p>Paragraphe 3</p></div> Les espaces ou les retours \u00e0 la ligne sont consid\u00e9r\u00e9s comme des noeuds textuels dans certains navigateurs. Dans le premier exemple, on a donc 7 noeuds enfants dans la <div> : un #text vide suivi d'un <p> suivi d'un #text vide... alors que dans le deuxi\u00e8me exemple, on a 3 noeuds enfants qui sont des <p> . Pour \u00e9viter ces noeuds textuels vides, il faut utiliser les attributs firstElementChild , lastElementChild , nextElementSibling et previousElementSibling qui ne retournent que les \u00e9l\u00e9ments HTML et ignorent donc les noeuds textuels.","title":"Attention au noeuds vides"},{"location":"javascript/modelerVosPagesWeb/#creer-et-inserer-des-elements","text":"Pour ajouter des \u00e9l\u00e9ments HTML avec le DOM il faut : - cr\u00e9er l'\u00e9l\u00e9ment - se fait avec la m\u00e9thode createElement() - var newLink = document.createElement('a'); cr\u00e9e un \u00e9l\u00e9ment <a> mais celui-ci n'est pas ins\u00e9r\u00e9 dans le document, il n'est donc pas visible - lui affecter des attributs - on d\u00e9finit des attributs soit avec setAttribute() , soit directement avec les propri\u00e9t\u00e9s ad\u00e9quates - newLink.id = 'sdz_link'; ou newLink.setAttribute('tabindex', '10'); - l'ins\u00e9rer dans le document - se fait avec la m\u00e9thode appendChild() - par exemple document.getElementById('myP').appendChild(newLink); ajoute notre \u00e9l\u00e9ment <a> dans l'\u00e9l\u00e9ment <p> portant l'ID myP en tant que dernier enfant Ajouter des noeuds textuels La m\u00e9thode createTextNode() sert \u00e0 cr\u00e9er un noeud de type #text . Il faut ensuite l'ins\u00e9rer avec la m\u00e9thode appendChild() sur l'\u00e9l\u00e9ment newLink . var newLinkText = document.createTextNode(\"Le Site du Z\u00e9ro\"); newLink.appendChild(newLinkText);","title":"Cr\u00e9er et ins\u00e9rer des \u00e9l\u00e9ments"},{"location":"javascript/modelerVosPagesWeb/#notions-sur-les-references","text":"En JavaScript, le contenu des variables est pass\u00e9 par valeur , c'est-\u00e0-dire que si on affecte la valeur d'une variable \u00e0 une autre variable, la valeur est copi\u00e9e dans une nouvelle, on a donc deux variables distinctes. Si on change la valeur d'une deux deux variables, l'autre reste inchang\u00e9. JavaScript poss\u00e8de aussi aussi un passage par r\u00e9f\u00e9rence , c'est-\u00e0-dire qu'on transmet l'adresse de la valeur, on peut donc avoir plusieurs variables qui pointent sur une m\u00eame valeur. On verra des exemples avec la cr\u00e9ation d'objets. Le concept de r\u00e9f\u00e9rence se retrouve avec le DOM : deux variables peuvent acc\u00e9der au m\u00eame \u00e9l\u00e9ment. Dans l'exemple suivant, la variable newLink contient une r\u00e9f\u00e9rence vers l'\u00e9l\u00e9ment <a> cr\u00e9\u00e9 (une adresse qui pointe vers <a> ). Une fois l'\u00e9l\u00e9ment HTML ins\u00e9r\u00e9 dans la page, on peut y acc\u00e9der de nombreuses fa\u00e7ons, comme avec getElementById . var newLink = document.createElement('a'); var newLinkText = document.createTextNode('Le Site du Z\u00e9ro'); newLink.id = 'sdz_link'; newLink.href = 'http://www.siteduzero.com'; newLink.appendChild(newLinkText); document.getElementById('myP').appendChild(newLink); Il faut retenir que les objets du DOM sont toujours accessibles par r\u00e9f\u00e9rence. On ne peut donc pas copier un \u00e9l\u00e9ment de la mani\u00e8re suivante, car les deux variables pointent vers le m\u00eame \u00e9l\u00e9ment. Pour duppliquer un \u00e9l\u00e9ment, il va faloir le cl\u00f4ner. var newDiv1 = document.createElement('div'); var newDiv2 = newDiv1; // On tente de copier le <div>","title":"Notions sur les r\u00e9f\u00e9rences"},{"location":"javascript/modelerVosPagesWeb/#cloner-remplacer-supprimer","text":"cloneNode() permet de cloner un \u00e9l\u00e9ment, avec un param\u00e8tre \u00e0 renseigner \u00e0 true ou false si on souhaite cl\u00f4ner le noeud avec ou sans ses enfants et ses diff\u00e9rents attributs. Attention, les \u00e9v\u00e9nements ne sont pas copi\u00e9s. // On va cloner un \u00e9l\u00e9ment cr\u00e9\u00e9 : var hr1 = document.createElement('hr'); var hr2 = hr1.cloneNode(false); // Il n'a pas d'enfants\u2026 // Ici, on clone un \u00e9l\u00e9ment existant : var paragraph1 = document.getElementById('myP'); var paragraph2 = paragraph1.cloneNode(true); // Et attention, l'\u00e9l\u00e9ment est clon\u00e9, mais pas \u00ab ins\u00e9r\u00e9 \u00bb tant que l'on n'a pas appel\u00e9 appendChild() : paragraph1.parentNode.appendChild(paragraph2); replaceChild() permet de remplacer un \u00e9l\u00e9ment par un autre. Il y a deux param\u00e8tres : le nouvel \u00e9l\u00e9ment et l'\u00e9l\u00e9ment \u00e0 remplacer <body> <div> <p id=\"myP\">Un peu de texte <a>et un lien</a></p> </div> <script> var link = document.querySelector('a'); var newLabel = document.createTextNode('et un hyperlien'); link.replaceChild(newLabel, link.firstChild); </script> </body> removeChild() permet de supprimer un \u00e9l\u00e9ment. La m\u00e9thode prend en param\u00e8tre le noeud enfant \u00e0 retirer. La m\u00e9thode retourne l'\u00e9l\u00e9ment supprim\u00e9, il est donc possible de supprimer un \u00e9l\u00e9ment HTML et de la r\u00e9int\u00e9grer ensuite. var link = document.querySelector('a'); link.parentNode.removeChild(link);","title":"Cl\u00f4ner, remplacer, supprimer"},{"location":"javascript/modelerVosPagesWeb/#autres-actions","text":"hasChildNodes appliqu\u00e9e sur un \u00e9l\u00e9ment renvoie true si l'\u00e9l\u00e9ment poss\u00e8de au moins un enfant, false sinon insertBefore permet d'ins\u00e9rer un \u00e9l\u00e9ment avant un autre, avec en param\u00e8tre l'\u00e9l\u00e9ment \u00e0 ins\u00e9rer et l'\u00e9l\u00e9ment avant lequel ins\u00e9rer l'\u00e9l\u00e9ment","title":"Autres actions"},{"location":"javascript/modelerVosPagesWeb/#-","text":"","title":"----"},{"location":"javascript/modelerVosPagesWeb/#les-evenements","text":"","title":"Les \u00e9v\u00e9nements"},{"location":"javascript/modelerVosPagesWeb/#que-sont-les-evenements","text":"Les \u00e9v\u00e9nements permettent de d\u00e9clencher une fonction selon qu'une action s'est produite ou non, par exemple faire appara\u00eetre une fen\u00eatre alert() au survol d'une zone d'un \u00e9l\u00e9ment.","title":"Que sont les \u00e9v\u00e9nements"},{"location":"javascript/modelerVosPagesWeb/#liste-des-evenements","text":"click : cliquer (appuyer puis rel\u00e2cher) sur l'\u00e9l\u00e9ment dblclick : double-cliquer sur l'\u00e9l\u00e9ment mouseover : faire entrer le curseur sur l'\u00e9l\u00e9ment mouseout : faire sortir le curseur de l'\u00e9l\u00e9ment mousedown : appuyer (sans rel\u00e2cher) sur le bouton gauche de la souris sur l'\u00e9l\u00e9ment mouseup : rel\u00e2cher le bouton gauche de la souris sur l'\u00e9l\u00e9ment mousemove : faire d\u00e9placer le curseur sur l'\u00e9l\u00e9ment keydown : appuyer (sans rel\u00e2cher) sur une touche de clavier sur l'\u00e9l\u00e9ment keyup : rel\u00e2cher une touche de clavier sur l'\u00e9l\u00e9ment keypress : frapper (appuyer puis rel\u00e2cher) une touche de clavier sur l'\u00e9l\u00e9ment focus : cibler l'\u00e9l\u00e9ment, pour qu'il re\u00e7oive tous les \u00e9v\u00e9nement du clavier blur : annuler le ciblage de l'\u00e9l\u00e9ment input : taper un caract\u00e8re dans un champ texte (support incomplet selon les navigateurs) select : s\u00e9lectionner le contenu d'un champ de texte (input, textarea...) Il existe aussi deux \u00e9v\u00e9n\u00e9ments sp\u00e9cifiques \u00e0 l'\u00e9l\u00e9ment form - submit pour envoyer le formulaire - reset pour r\u00e9initialiser le formulaire","title":"Liste des \u00e9v\u00e9nements"},{"location":"javascript/modelerVosPagesWeb/#utiliser-les-evenements-sans-le-dom","text":"l'\u00e9v\u00e9nement click . Dans l'exemple, il permet en cliquant sur le texte d'afficher la boite de dialogue <span onclick=\"alert('Hello !');\">Cliquez-moi !</span> le mot cl\u00e9 this est une propri\u00e9t\u00e9 pointant sur l'objet courant. L'appel \u00e0 ce mot-cl\u00e9 lors d'un \u00e9v\u00e9nement fait que l'objet point\u00e9 est l'\u00e9l\u00e9ment qui a d\u00e9clanch\u00e9 l'\u00e9v\u00e9nement <span onclick=\"alert('Voici le contenu de l\\'\u00e9l\u00e9ment que vous avez cliqu\u00e9 :\\n\\n' + this.innerHTML);\">Cliquez-moi !</span> le focus. Dans l'exemple, lorsqu'on clique sur l'input, il poss\u00e8de le focus et ex\u00e9cute l'\u00e9v\u00e9nement focus . Lorsque l'input perd le focus, cela d\u00e9clenche l'\u00e9v\u00e9nement blur <input id=\"input\" type=\"text\" size=\"50\" value=\"Cliquez ici !\" onfocus=\"this.value='Appuyez maintenant sur votre touche de tabulation.';\" onblur=\"this.value='Cliquez ici !';\"/> <br /><br/> <a href=\"#\" onfocus=\"document.getElementById('input').value = 'Vous avez maintenant le focus sur le lien, bravo !';\">Un lien bidon</a> bloquer l'action par d\u00e9faut. Par exemple, ne pas rediriger vers l'URL indiqu\u00e9 lorsqu'on clique sur un lien, en ajoutant dans return false; dans l'\u00e9v\u00e9n\u00e9ment . On peut \u00e9ventuellement mettre \"#\" dans le href, ce qui redirige en haut de la page Web <a href=\"http://www.siteduzero.com\" onclick=\"alert('Vous avez cliqu\u00e9 !'); return false;\">Cliquez-moi !</a> Par ailleurs, la balise <a> est con\u00e7ue pour rediriger vers une page Web et non pour servir de d\u00e9clencheur. Pour cela, utiliser une balise <button> a\u00e0 laquelle on retire le style CSS","title":"Utiliser les \u00e9v\u00e9n\u00e9ments sans le DOM"},{"location":"javascript/modelerVosPagesWeb/#les-evenements-au-travers-du-dom","text":"","title":"Les \u00e9v\u00e9nements au travers du DOM"},{"location":"javascript/modelerVosPagesWeb/#le-dom-0","text":"interface ancienne impl\u00e9ment\u00e9e par Netscape, appel\u00e9e DOM-0 on d\u00e9finit les \u00e9v\u00e9nements non plus dans le code HTML mais directement en JavaScript. Chaque \u00e9v\u00e9nement standard poss\u00e8de une propri\u00e9t\u00e9 dont le nom est pr\u00e9c\u00e9d\u00e9 des deux lettres \"on\". Cette propri\u00e9t\u00e9 prend pour valeur une fonction ou une fonction anonyme pour supprimer un \u00e9v\u00e9nement avec le DOM-0, il fait lui attribuer une fonction anonyme vide element.onclick = function() {}; <span id=\"clickme\">Cliquez-moi !</span> <script> var element = document.getElementById('clickme'); element.onclick = function() { alert(\"Vous m'avez cliqu\u00e9 !\"); }; </script>","title":"Le DOM-0"},{"location":"javascript/modelerVosPagesWeb/#le-dom-2","text":"la m\u00e9thode sans le DOM ne permet pas d'acc\u00e9der \u00e0 l'objet Event qui contient beaucoup d'informations sur l'\u00e9v\u00e9nement d\u00e9clench\u00e9 le DOM-0 est vieux et ne permet pas de cr\u00e9er plusieurs fois le m\u00eame \u00e9v\u00e9nement le DOM-2 permet la cr\u00e9ation multiple d'un m\u00eame \u00e9v\u00e9nement et g\u00e8re aussi l'objet Event <span id=\"clickme\">Cliquez-moi !</span> <script> var element = document.getElementById('clickme'); element.addEventListener('click', function() { alert(\"Vous m'avez cliqu\u00e9 !\"); }); </script> Dans cet exemple, ce qui change par rapport au DOM-0 et qu'on n'utilise plus une propri\u00e9t\u00e9 mais la m\u00e9thode addEventListener() qui prend 3 param\u00e8tres : le nom de l'\u00e9v\u00e9n\u00e9ment sans \"on, la fonction \u00e0 ex\u00e9cuter, et un bool\u00e9en optionnel pour sp\u00e9cifier si on souhaite utiliser la phase de capture ou de bouillennement (cf ci-apr\u00e8s) On peut cr\u00e9er deux \u00e9v\u00e9nements identiques pour un m\u00eame \u00e9l\u00e9ment. Ainsi, lors du d\u00e9clenchement, les 2 \u00e9v\u00e9nements seront ex\u00e9cut\u00e9s. <span id=\"clickme\">Cliquez-moi !</span> <script> var element = document.getElementById('clickme'); // Premier \u00e9v\u00e9nement click element.addEventListener('click', function() { alert(\"Et de un !\"); }); // Deuxi\u00e8me \u00e9v\u00e9nement click element.addEventListener('click', function() { alert(\"Et de deux !\"); }); </script> Pour supprimer un \u00e9v\u00e9nement, il faut utiliser la m\u00e9thode removeEventListener() avec les m\u00eames param\u00e8tres utilis\u00e9s lors de sa cr\u00e9ation element.addEventListener('click', myFunction); // On cr\u00e9e l'\u00e9v\u00e9nement element.removeEventListener('click', myFunction); // On supprime l'\u00e9v\u00e9nement en lui repassant les m\u00eames param\u00e8tres","title":"Le DOM-2"},{"location":"javascript/modelerVosPagesWeb/#les-phases-de-capture-et-de-bouillonnement","text":"Ce sont deux \u00e9tapes distinctes de l'ex\u00e9cution d'un \u00e9v\u00e9nement. La capture s'ex\u00e9cute avant le d\u00e9clenchement de l'\u00e9v\u00e9nement tandis que le bouillonnement s'ex\u00e9cute apr\u00e8s le d\u00e9clenchement de l'\u00e9v\u00e9nement. Elles permettent de d\u00e9finir le sens de propagation des \u00e9v\u00e9nements <div> <span>Du texte !</span> </div> Dans cet exemple, si on attribue une fonction \u00e0 l'\u00e9v\u00e9nement click de chacun de ces deux \u00e9l\u00e9ments, quel \u00e9v\u00e9nement va se d\u00e9clencher en premier ? Avec la capture, l'\u00e9v\u00e9nement du <div> se d\u00e9clenchera en premier suivi de celui du <span> . Avec le bouillonnement, l'\u00e9v\u00e9nement du <span> se d\u00e9clenchera d'abord. La phase de bouillonnement est d\u00e9finie par d\u00e9faut et celle qu'on utilise le plus souvent.","title":"Les phases de capture et de bouillonnement"},{"location":"javascript/modelerVosPagesWeb/#lobjet-event","text":"L'objet Event fournit une multitude d'informations sur l'\u00e9v\u00e9nement actuellement d\u00e9clench\u00e9, comme les touches actuellement enfonc\u00e9s, les coordonn\u00e9es du curseur, l'\u00e9l\u00e9ment qui a d\u00e9clench\u00e9 l'\u00e9v\u00e9nement... Cet objet n'est accessible que lorsqu'on \u00e9v\u00e9nement est d\u00e9clench\u00e9, dans une fonction ex\u00e9cut\u00e9e par un \u00e9v\u00e9nement element.addEventListener('click', function(e) { // L'argument \u00ab e \u00bb va r\u00e9cup\u00e9rer une r\u00e9f\u00e9rence vers l'objet \u00ab Event \u00bb alert(e.type); // Ceci affiche le type de l'\u00e9v\u00e9nement (click, mouseover, etc.) }); la propri\u00e9t\u00e9 type permet de savoir quel type d'\u00e9v\u00e9nement s'est d\u00e9clench\u00e9 la propri\u00e9t\u00e9 target permet de r\u00e9cup\u00e9rer l'\u00e9l\u00e9ment de l'\u00e9v\u00e9nement actuellement d\u00e9clench\u00e9, pour par exemple modifier le contenu d'un \u00e9l\u00e9ment cliqu\u00e9 <span id=\"clickme\">Cliquez-moi !</span> <script> var clickme = document.getElementById('clickme'); clickme.addEventListener('click', function(e) { e.target.innerHTML = 'Vous avez cliqu\u00e9 !'; }); </script> la propri\u00e9t\u00e9 currentTarget permet de conna\u00eetre l'\u00e9l\u00e9ment \u00e0 l'origine de l'\u00e9v\u00e9nement, alors que target permet de conna\u00eetre l'\u00e9l\u00e9ment d\u00e9clencheur qui peut \u00eatre un \u00e9l\u00e9ment enfant. Il s'utilise de la m\u00eame mani\u00e8re que target r\u00e9cup\u00e9rer la position du curseur, g\u00e9n\u00e9ralement par raport au coin sup\u00e9rieur gauche de la page Web, ou aussi au coin sup\u00e9rieur gauche de l'\u00e9cran. Il faut utiliser les propri\u00e9t\u00e9s clientX et clientY pour les positons horizontales et verticales. Souvent combin\u00e9 avec l'\u00e9v\u00e9nement mousemove car la position change \u00e0 chaque d\u00e9placement de la souris <div id=\"position\"></div> <script> var position = document.getElementById('position'); document.addEventListener('mousemove', function(e) { position.innerHTML = 'Position X : ' + e.clientX + 'px<br />Position Y : ' + e.clientY + 'px'; }); </script> la propri\u00e9t\u00e9 relatedTarget permet de r\u00e9cup\u00e9rer l'\u00e9l\u00e9ment en relation avec un \u00e9v\u00e9nement de souris. Elle ne s'utilise qu'avec les \u00e9v\u00e9nements mouseover (objet de l'\u00e9l\u00e9ment dont le curseur vient de sortir) et mouseout (objet de l'\u00e9l\u00e9ment sur lequel le curseur vient d'entrer) r\u00e9cup\u00e9rer les touches frapp\u00e9es par l'utilisateur, se fait par le biais de trois \u00e9v\u00e9nements les \u00e9v\u00e9nements keyup et keydown servent \u00e0 capter toutes les frappes des touches, ils retournent un caract\u00e8re majuscule que la touche Maj soit press\u00e9e ou non l'\u00e9v\u00e9nement keypress sert \u00e0 capter les touches qui \u00e9crivent. En tapant Maj+A, keypress d\u00e9tectera nien un A majuscule il existe trois propri\u00e9t\u00e9s capables de fournir une valeur : keyCode , charCode et which . keyCode est suffisante bloquer l'action par d\u00e9faut de certains \u00e9v\u00e9nements avec DOM-2, avec la m\u00e9thode preventDefault() <a id=\"link\" href=\"http://www.siteduzero.com\">Cliquez-moi !</a> <script> var link = document.getElementById('link'); link.addEventListener('click', function(e) { e.preventDefault(); // On bloque l'action par d\u00e9faut de cet \u00e9v\u00e9nement alert('Vous avez cliqu\u00e9 !'); }); </script>","title":"L'objet Event"},{"location":"javascript/modelerVosPagesWeb/#resoudre-les-problemes-dheritage-des-evenements","text":"Parfois, un \u00e9v\u00e9nement appliqu\u00e9 sur un parent se propage \u00e0 ses enfants. Cet h\u00e9ritage des \u00e9v\u00e9nements peut provoquer des comportements inattendus. C'est le cas des \u00e9v\u00e9nements mouseover , mouseout , mousemove , click ... Pour r\u00e9gler cela, il faut utiliser la propri\u00e9t\u00e9 relatedTarget pour d\u00e9tecter quel est l'\u00e9l\u00e9ment vers lequel le curseur se dirige ou de quel \u00e9l\u00e9ment il provient.","title":"R\u00e9soudre les probl\u00e8mes d'h\u00e9ritage des \u00e9v\u00e9nements"},{"location":"javascript/modelerVosPagesWeb/#-_1","text":"","title":"----"},{"location":"javascript/modelerVosPagesWeb/#les-formulaires","text":"","title":"Les formulaires"},{"location":"javascript/modelerVosPagesWeb/#les-proprietes","text":"On va s'int\u00e9resser aux propri\u00e9t\u00e9s sp\u00e9cifiques aux \u00e9l\u00e9ments d'un formulaire : value , disabled , checked ...","title":"Les propri\u00e9t\u00e9s"},{"location":"javascript/modelerVosPagesWeb/#la-propriete-value","text":"Elle permet de d\u00e9finir une valeur pour diff\u00e9rents \u00e9l\u00e9ments d'un formulaire comme les <input> en lui assignant une valeur et elle est affich\u00e9e sur l'\u00e9l\u00e9ment HTML. Elle s'utilise aussi avec l'\u00e9l\u00e9ment <textarea> . Pour ce dernier, on ne peut pas utiiser innerHTML <input id=\"text\" type=\"text\" size=\"60\" value=\"Vous n'avez pas le focus !\" /> <script> var text = document.getElementById('text'); text.addEventListener('focus', function(e) { e.target.value = \"Vous avez le focus !\"; }); text.addEventListener('blur', function(e) { e.target.value = \"Vous n'avez pas le focus !\"; }); </script>","title":"La propri\u00e9t\u00e9 value"},{"location":"javascript/modelerVosPagesWeb/#les-booleens-avec-disabled-checked-et-readonly","text":"En HTML, ces 3 propri\u00e9t\u00e9s s'utilisent de la mani\u00e8re suivante : <input type=\"text\" disabled=\"disabled\" /> . En JavaScript, ces propri\u00e9t\u00e9s sont des bool\u00e9ens. <input id=\"text\" type=\"text\" /> <script> var text = document.getElementById('text'); text.disabled = true; </script> Pour les boutos de type radio, on peut utiliser la m\u00e9thode querySelectorAll() <label><input type=\"radio\" name=\"check\" value=\"1\" /> Case n\u00b01</label><br /> <label><input type=\"radio\" name=\"check\" value=\"2\" /> Case n\u00b02</label><br /> <label><input type=\"radio\" name=\"check\" value=\"3\" /> Case n\u00b03</label><br /> <label><input type=\"radio\" name=\"check\" value=\"4\" /> Case n\u00b04</label> <br /><br /> <input type=\"button\" value=\"Afficher la case coch\u00e9e\" onclick=\"check();\" /> <script> function check() { var inputs = document.querySelectorAll('input[type=radio]:checked'), inputsLength = inputs.length; for (var i = 0; i < inputsLength; i++) { alert('La case coch\u00e9e est la n\u00b0' + inputs[i].value); } } </script>","title":"Les bool\u00e9ens avec disabled, checked et readonly"},{"location":"javascript/modelerVosPagesWeb/#les-listes-deroulantes-avec-selectedindex-et-options","text":"","title":"Les listes d\u00e9roulantes avec selectedIndex et options"},{"location":"javascript/objetsEtFonctionsUtilesJavascript/","text":"Objets et fonctions utiles Javascript L'Objet Math L'objet Math est un objet natif dont les m\u00e9thodes et propri\u00e9t\u00e9s permettent l'utilisation de constantes et fonctions math\u00e9matiques. Contrairement aux autres objets globaux, Math n'est pas un constructeur. Toutes les propri\u00e9t\u00e9s et les m\u00e9thodes de Math sont statiques. Exemples de propri\u00e9t\u00e9s Math.E // nombre d'Euler, environ 2.718 Math.PI // nombre PI, environ 3.1416 Exemples de m\u00e9thodes Math.abs(x) // retourne la valeur absolue d'un nombre Math.cos(x) // retourne le cosinus d'un nombre Math.sin(x) // retourne le sinus d'un nombre Math.exp(x) // retourne l'exponentielle d'un nombre Math.log(x) // retourne le logarithme naturel (log e) d'un nombre Math.sqrt(x) // retourne la racine carr\u00e9e d'un nombre Math.pow(x,y) // retourne le calcul de x \u00e0 la puissance y Math.max(x,y,...) // retourne la plus grande valeur d'une liste de nombres, par exemple Math.max(0,-5,3,2) retourne 3 Math.min(x,y,...) // retourne la plus petite valeur d'une liste de nombres, par exemple Math.min(0,-5,3,2) retourne -5 Math.random() // retourne un nombre pseudo-al\u00e9atoire compris entre 0 (inclus) et 1 (exclu) Math.floor(x) // retourne le plus grand entier inf\u00e9rieur ou \u00e9gal \u00e0 la valeur pass\u00e9e en param\u00e8tre Math.ceil(x) // retourne le plus petit entier sup\u00e9rieur ou \u00e9gal \u00e0 la valeur pass\u00e9e en param\u00e8tre Math.round(x) // retourne l'arrondi \u00e0 l'unit\u00e9 d'un nombre Math.trunc(x) // retourne la partie enti\u00e8re d'un nombre (diff\u00e9rent de floor() pour les nombres n\u00e9gatifs) Pour arrondir \u00e0 2 chiffres apr\u00e8s la virgule, on peut faire Math.round(x * 100) / 100 . Exemple console.log(Math.round(123.45678 * 100) / 100) // affiche 123.46 Pour g\u00e9n\u00e9rer un nombre al\u00e9atoire entre 1 et 100, on peut faire : const myNumber = Math.trunc(Math.random() * 100) + 1 console.log(myNumber) L'objet Date Ce constructeur permet de cr\u00e9er des instances Date qui repr\u00e9sentent un moment pr\u00e9cis dans le temps. Les objets Date se basent sur une valeur de temps qui est le nombre de millisecondes depuis 1er janvier 1970 minuit UTC. Sans argument, le constructeur cr\u00e9e un objet Date pour la date du jour et l'heure selon l'heure locale du syst\u00e8me const date = new Date() console.log(date) // affiche : Thu Sep 06 2018 10:17:13 GMT+0200 (heure d\u2019\u00e9t\u00e9 d\u2019Europe centrale) const date2 = Date.now() // retourne la valeur num\u00e9rique correspondant au temps courant. Le nombre de millisecondes depuis le 1 janvier 1970, 00:00:00 UTC console.log(date2) // 1536222742607 On peut aussi cr\u00e9er une date avec des arguments, par exemple le 28 mars 2018 (attention, l'indice des mois commence \u00e0 0) : const date = new Date(2018,2,28) console.log(date) // affiche : Wed Mar 28 2018 00:00:00 GMT+0200 (heure d\u2019\u00e9t\u00e9 d\u2019Europe centrale) const date = new Date('2018/3/28') // \u00e9auivalent en passant une String en param\u00e8tre On peut r\u00e9cup\u00e8re des param\u00e8tres d'une date (mois, jour, heure...). Exemple : const date = new Date() console.log(date) // Thu Sep 06 2018 10:43:30 GMT+0200 (heure d\u2019\u00e9t\u00e9 d\u2019Europe centrale) console.log(date.getDate()) // 6 console.log(date.getDay()) // 4 console.log(date.getMonth()) // 8 console.log(date.getFullYear()) // 2018 console.log(date.getHours()) // 10 console.log(date.getTime()) // 1536223410659 (correspond au nombre de millisecondes depuis le 1er janvier 1970) Calculer le temps \u00e9coul\u00e9 function traitementQuiPrendBeaucoupDeTemps(){ let j = 0 for(let i =0 ; i < 1000000 ; i++){ j++ } return j } // en utilisant les objets Date const debut = Date.now() // l'\u00e9v\u00e8nement \u00e0 mesurer se trouve ici : traitementQuiPrendBeaucoupDeTemps() const fin = Date.now() const tempsEcoule = fin - debut // temps \u00e9coul\u00e9 en millisecondes console.log(tempsEcoule) // affiche 15 // en utilisant les m\u00e9thodes natives const debut2 = new Date() // l'\u00e9v\u00e8nement \u00e0 mesurer se trouve ici : traitementQuiPrendBeaucoupDeTemps() const fin2 = new Date() const tempsEcoule2 = fin2.getTime() - debut2.getTime() // temps \u00e9coul\u00e9 en millisecondes console.log(tempsEcoule2) // affiche 10 Expressions R\u00e9guli\u00e8res Les expressions r\u00e9guli\u00e8res sont des motifs utilis\u00e9s pour correspondre \u00e0 certaines combinaisons de caract\u00e8res au sein de cha\u00eenes de caract\u00e8res. En JavaScript, les expressions r\u00e9guli\u00e8res sont \u00e9galement des objets. Ces motifs sont utilis\u00e9s avec les m\u00e9thodes exec et test de la classe RegExp , et avec les m\u00e9thodes match , replace , search et split de String . Il est possible de construire une expression r\u00e9guli\u00e8re de deux fa\u00e7ons : const re1 = /ab+c/ // avec un litt\u00e9ral d'expression r\u00e9guli\u00e8re, compil\u00e9 lors du chargement du script. Plus performant si l'expression reste constante const re2 = new RegExp(\"ab+c\") // avec le constructeur de l'objet RegExp, compil\u00e9 lors de l'ex\u00e9cution console.log(re1) // affiche /ab+c/ console.log(re2) // affiche /ab+c/ Exemples d'utilisation des m\u00e9thodes : const monTemplate = /ab/ console.log(monTemplate) // affiche /ab/ // m\u00e9thodes de RegExp // ex\u00e9cute une recherche de correspondance dans une cha\u00eene de caract\u00e8res. Elle renvoie un tableau d'informations ou null lorsqu'il n'y a pas de correspondance console.log(monTemplate.exec(\"abc\")) // affiche un tableau avec l'index \u00e0 l'endroit ou commence le template dans la cha\u00eene console.log(monTemplate.exec(\"qsd\")) // affiche null // teste la pr\u00e9sence d'une correspondance dans une cha\u00eene de caract\u00e8res. Elle renvoie true ou false console.log(monTemplate.test(\"abc\")) // true console.log(monTemplate.test(\"qsd\")) // false // m\u00e9thodes de String // ex\u00e9cute une recherche de correspondance dans une cha\u00eene de caract\u00e8res. Elle renvoie un tableau d'informations ou null lorsqu'il n'y a pas de correspondance console.log(\"abc\".match(monTemplate)) // affiche un tableau comme la m\u00e9thode exec() console.log(\"qsd\".match(monTemplate)) // affiche null // teste la pr\u00e9sence d'une correspondance dans une cha\u00eene de correspondance. Elle renvoie la position de la correspondance ou -1 s'il n'y en a pas console.log(\"abc\".search(monTemplate)) // affiche 0 console.log(\"qsd\".search(monTemplate)) // affiche -1 // recherche une correspondance dans une cha\u00eene de caract\u00e8res et qui remplace la correspondance par une cha\u00eene de substitution console.log(\"abc\".replace(monTemplate, \"ZZZ\")) // affiche ZZZc // utilise une expression r\u00e9guli\u00e8re ou une cha\u00eene de caract\u00e8res pour d\u00e9couper une cha\u00eene de caract\u00e8res en un tableau comprenant les fragments r\u00e9sultants console.log(\"Bonjourabjeabm'appelleabGa\u00ebtan\".split(monTemplate)) // affiche [\"Bonjour\", \"je\", \"m'appelle\", \"Ga\u00ebtan\"] Le motif d'une expression r\u00e9guli\u00e8re est compos\u00e9 de motifs simples comme /abc/ ou de caract\u00e8res sp\u00e9ciaux comme /ab*c/ . Les motifs simples doivent avoir une correspondance directe, on doit observer exactement les caract\u00e8res 'des' ensemble et dans cet ordre pr\u00e9cis. Lorsque le motif \u00e0 trouver est plus complexe qu'une simple \u00e9galit\u00e9, le motif devra contenir des caract\u00e8res sp\u00e9ciaux. (voir la documentation en ligne pour plus de d\u00e9tail). Les expressions r\u00e9guli\u00e8res sont souvent utilis\u00e9s dans les formulaires pour v\u00e9rifier la validit\u00e9 des donn\u00e9es saisies par l'utilisateur. setTimeout et setInterval Ce sont 2 m\u00e9thodes de l'objet global window . On s'en sert beaucoup dans les animations. La m\u00e9thode setTimeout() permet de d\u00e9finir un \u00ab minuteur \u00bb (timer) qui ex\u00e9cute une fonction ou un code donn\u00e9 apr\u00e8s la fin du d\u00e9lai indiqu\u00e9. Le d\u00e9lai est exprim\u00e9e en millisecondes. function hello(){ console.log(\"hello\") } setTimeout(hello, 2000) // ex\u00e9cute 1 fois hello() au bout de 2 secondes La valeur renvoy\u00e9e par la fonction est un entier qui repr\u00e9sente un identifiant du minuteur cr\u00e9\u00e9 par l'appel \u00e0 setTimeout(). Cet identifiant pourra \u00eatre pass\u00e9 \u00e0 la m\u00e9thode clearTimeout() afin d'annuler ce minuteur donn\u00e9, par exemple avec un bouton. Il est possible d'ex\u00e9cuter plusieurs fois une fonction avec setTimeout() : function hello(){ console.log(\"hello\") setTimeout(hello, 2000) } hello() // la m\u00e9thode s'ex\u00e9cute une premi\u00e8re fois imm\u00e9diatement puis toutes les 2 secondes La m\u00e9thode setInterval() appelle une fonction de mani\u00e8re r\u00e9p\u00e9t\u00e9e, avec un certain d\u00e9lai fix\u00e9 entre chaque appel setInterval(hello, 2000) // ex\u00e9cute hello() toutes de 2 secondes au bout de 2 secondes la premi\u00e8re fois On peut arr\u00eater la m\u00e9thode setInterval() avec la m\u00e9thode clearInterval() . Il faut stocker l'interval dans une variable pour r\u00e9cup\u00e9rer l'intervalID. Dans l'exemple ci-dessous, hello() s'ex\u00e9cute 3 fois. function hello(){ console.log(\"hello\") } const monInterval = setInterval(hello, 2000) setTimeout(function(){ clearInterval(monInterval) }, 6000) Fonctions de String L'objet global String est un constructeur de cha\u00eenes de caract\u00e8res. Les objets String sont cr\u00e9\u00e9s en appelant le constructeur new String() . La fonction globale String() peut \u00e9galement \u00eatre appel\u00e9e sans l'op\u00e9rateur new pour cr\u00e9er une cha\u00eene primitive. Les objets String peuvent \u00eatre convertis en cha\u00eenes primitives \u00e0 l'aide de String.valueOf() : // cr\u00e9ation d'une cha\u00eene primitve const chainePrimitive = \"toto\"; // cr\u00e9ation d'un objet String const objetString = new String(chainePrimitive); console.log(typeof chainePrimitive); // affiche \"string\" console.log(typeof objetString); // affiche \"object\" console.log(typeof objetString.valueOf()); // affiche \"string\" \u00c9tant donn\u00e9 que JavaScript effectue automatiquement les conversions entre cha\u00eenes primitives et objets String, toute m\u00e9thode de l'objet String peut \u00eatre appel\u00e9e sur une cha\u00eene primitive. La propri\u00e9t\u00e9 length retourne la longueur de la cha\u00eene. Quelques m\u00e9thodes utiles : - charAt(index) renvoie une nouvelle cha\u00eene contenant le caract\u00e8re \u00e0 la position indiqu\u00e9e en argument - concat(string2,...stringN) combine le texte de plusieurs cha\u00eenes avec la cha\u00eene appelante et renvoie la nouvelle cha\u00eene ainsi form\u00e9e - endsWith(cha\u00eeneRecherch\u00e9e) renvoie un bool\u00e9en indiquant si la chaine de caract\u00e8res se termine par la chaine de caract\u00e8res fournie en argument - indexOf(valeurRecherch\u00e9e) renvoie l'indice de la premi\u00e8re occurence de la valeur cherch\u00e9e au sein de la cha\u00eene courante. Elle renvoie -1 si la valeur cherch\u00e9e n'est pas trouv\u00e9e - lastIndexOf(valeurRecherch\u00e9e) envoie l'indice, dans la cha\u00eene courante, de la derni\u00e8re occurence de la valeur donn\u00e9e en argument. Si cette sous-cha\u00eene n'est pas trouv\u00e9e, la m\u00e9thode renvoie -1 - replace() rechercher une correspondance entre une expression r\u00e9guli\u00e8re et une cha\u00eene, et remplace la sous-cha\u00eene correspondante par une nouvelle cha\u00eene - search(regexp) renvoie l'indice de la premi\u00e8re correspondance pour l'expression r\u00e9guli\u00e8re au sein de la chaine de caract\u00e8res, sinon, la m\u00e9thode renvoie -1 - slice(indiceDebut[, indiceFin]) extrait une section d'une chaine de caract\u00e8res et la retourne comme une nouvelle chaine de caract\u00e8res - split(s\u00e9parateur) permet de diviser une cha\u00eene de caract\u00e8res \u00e0 partir d'un s\u00e9parateur pour fournir un tableau de sous-cha\u00eenes - startsWith(cha\u00eeneRecherch\u00e9e) renvoie un bool\u00e9en indiquant si la chaine de caract\u00e8res commence par la deuxi\u00e8me chaine de caract\u00e8res fournie en argument - substring(indiceA[, indiceB]) retourne une sous-cha\u00eene de la cha\u00eene courante, entre un indice de d\u00e9but et un indice de fin - toLowerCase() retourne la cha\u00eene de caract\u00e8res courante en minuscules - toString() renvoie une chaine de caract\u00e8res repr\u00e9sentant l'objet renseign\u00e9 - toUpperCase() retourne la valeur de la cha\u00eene courante, convertie en majuscules - trim() permet de retirer les blancs en d\u00e9but et fin de cha\u00eene - valueOf() renvoie la valeur primitive de l'objet String Exemples : console.log(gaetan.length) // affiche 6 console.log(gaetan.charAt(1)) // affiche a console.log(gaetan[1]) // affiche a console.log(gaetan.concat(\" et Louis\")) // affiche Ga\u00ebtan et Louis console.log(gaetan.substring(1,3)) // affiche a\u00eb Fonctions de Array L'objet global Array est utilis\u00e9 pour cr\u00e9er des tableaux. On peut cr\u00e9er un tableau avec le constructeur Array, et aussi la syntaxe crochets. La propri\u00e9t\u00e9 length retourne la longueur de la cha\u00eene. Un tableau contient plusieurs valeurs appel\u00e9es item . Chaque item est accessible au moyen d\u2019un indice dont la num\u00e9rotation commence \u00e0 0. On acc\u00e9de \u00e0 un \u00e9l\u00e9ment d'un tableau en indiquant son indice entre crochets et on peut modifier la valeur d'un \u00e9l\u00e9m\u00e9net de cette mani\u00e8re. const myArray = [1, 2, 3, 4, 5] const myArray2 = new Array(1, 2, 3, 4, 5) console.log(myArray.length) // affiche 5 console.log(myArray[0]) // affiche 1, le premier \u00e9l\u00e9ment du tableau myArray[0]=8 // modifie la valeur du premier \u00e9l\u00e9ment du tableau console.log(myArray[0]) // affiche 8, le premier \u00e9l\u00e9ment du tableau console.log(myArray[myArray.length-1]) // affiche 5, le dernier \u00e9l\u00e9ment du tableau const myArray = [1, 2, 3, 4, 5] myArray.push(6) // ajoute l'\u00e9l\u00e9ment en param\u00e8tre \u00e0 la fin du tableau myArray.pop() // enl\u00e8ve le dernier \u00e9l\u00e9ment du tableau et le retourne myArray.shift() // enl\u00e8ve le premier \u00e9l\u00e9ment du tableau et le retourne myArray.unshift(0) // ajoute l'\u00e9l\u00e9ment en param\u00e8tre au d\u00e9but du tableau console.log(myArray) isArray() permet de d\u00e9terminer si l'objet pass\u00e9 en argument est un objet Array reverse() permet d'inverser l'ordre des \u00e9l\u00e9ments du tableau. La m\u00e9thode modifie le tableau courant et renvoie une r\u00e9f\u00e9rence \u00e0 ce tableau sort() trie les \u00e9l\u00e9ments d'un tableau, dans ce m\u00eame tableau, et renvoie le tableau splice() modifie le contenu d'un tableau en retirant des \u00e9l\u00e9ments et/ou en ajoutant de nouveaux \u00e9l\u00e9ments const mesPoissons = [\"scalaire\", \"clown\", \"mandarin\", \"chirurgien\"] // supprime 0 \u00e9l\u00e9ment \u00e0 partir de l'index 2, et ins\u00e8re \"tambour\" enleves = mesPoissons.splice(2, 0, \"tambour\") // mesPoissons est [\"scalaire\", \"clown\", \"tambour\", \"mandarin\", \"chirurgien\"] // enleves est [], aucun \u00e9l\u00e9ment supprim\u00e9 // supprime 1 \u00e9l\u00e9ment \u00e0 partir de l'index 3 enleves = mesPoissons.splice(3, 1) // mesPoissons est [\"scalaire\", \"clown\", \"tambour\", \"chirurgien\"] // enleves est [\"mandarin\"] // supprime 1 \u00e9l\u00e9ment \u00e0 partir de l'index 2, et ins\u00e8re \"trompette\" enleves = mesPoissons.splice(2, 1, \"trompette\") // mesPoissons est [\"scalaire\", \"clown\", \"trompette\", \"chirurgien\"] // enleves est [\"tambour\"] concat(array2) est utilis\u00e9e afin de fusionner un ou plusieurs tableaux en les concat\u00e9nant. Cette m\u00e9thode ne modifie pas les tableaux existants, elle renvoie un nouveau tableau qui est le r\u00e9sultat de l'op\u00e9ration includes(\u00e9l\u00e9mentRecherch\u00e9) permet de d\u00e9terminer si un tableau contient un \u00e9l\u00e9ment et renvoie true si c'est le cas, false sinon indexOf(\u00e9l\u00e9mentRecherch\u00e9) renvoie le premier indice pour lequel on trouve un \u00e9l\u00e9ment donn\u00e9 dans un tableau. Si l'\u00e9l\u00e9ment cherch\u00e9 n'est pas pr\u00e9sent dans le tableau, la m\u00e9thode renverra -1 var beasts = ['ant', 'bison', 'camel', 'duck', 'bison']; console.log(beasts.indexOf('bison')); // expected output: 1 console.log(beasts.indexOf('bison', 2)); // start from index 2, expected output: 4 console.log(beasts.indexOf('giraffe')); // expected output: -1 join(s\u00e9parateur) r\u00e9unit tous les \u00e9l\u00e9ments d'un tableau dans une chaine de caract\u00e8res et renvoie cette nouvelle cha\u00eene de caract\u00e8res lastIndexOf(\u00e9l\u00e9mentRecherch\u00e9) permet de renvoyer le dernier indice pour lequel une valeur donn\u00e9e est pr\u00e9sente dans un tableau. Si la valeur recherch\u00e9e n'est pas pr\u00e9sente, le r\u00e9sultat sera -1 slice() renvoie un objet tableau contenant une copie d'une portion du tableau d'origine. La portion est d\u00e9finie par un indice de d\u00e9but et un indice de fin exclu optionnel var animals = ['ant', 'bison', 'camel', 'duck', 'elephant']; console.log(animals.slice()); // expected output: Array ['ant', 'bison', 'camel', 'duck', 'elephant'] console.log(animals.slice(2)); // expected output: Array ['camel', 'duck', 'elephant'] console.log(animals.slice(2, 4)); // expected output: Array ['camel', 'duck'] toString() renvoie une chaine de caract\u00e8res repr\u00e9sentant le tableau sp\u00e9cifi\u00e9 et ses \u00e9l\u00e9ments const mesPoissons = [\"scalaire\", \"clown\", \"mandarin\", \"chirurgien\"] console.log(mesPoissons.toString()) // scalaire,clown,mandarin,chirurgien Les m\u00e9thodes d'it\u00e9ration La m\u00e9thode every() permet de tester si tous les \u00e9l\u00e9ments d'un tableau v\u00e9rifient une condition donn\u00e9e par une fonction en argument : function isBelowThreshold(currentValue) { return currentValue < 40; } var array1 = [1, 30, 39, 29, 10, 13]; console.log(array1.every(isBelowThreshold)); // expected output: true La m\u00e9thode forEach() permet d'ex\u00e9cuter une fonction donn\u00e9e sur chaque \u00e9l\u00e9ment du tableau. La m\u00e9thode map() cr\u00e9e un nouveau tableau avec les r\u00e9sultats de l'appel d'une fonction fournie sur chaque \u00e9l\u00e9ment du tableau appelant. La m\u00e9thode filter() cr\u00e9e et retourne un nouveau tableau contenant tous les \u00e9l\u00e9ments du tableau d'origine qui remplissent une condition d\u00e9termin\u00e9e par la fonction callback. const myArray = [1, 2, 3, 4, 5] myArray.forEach((element, index, array) => { console.log(element+\" \"+index+\" \"+array) }) // a 0 a,b,c,d,e // b 1 a,b,c,d,e ... const myArray2 = myArray.map(element => { return element * 2 }) console.log(myArray2) // [2, 4, 6, 8, 10] const myArray3 = myArray.filter(element => { return element >= 3 }) console.log(myArray3) // [3, 4, 5] La m\u00e9thode every() permet de tester si tous les \u00e9l\u00e9ments d'un tableau v\u00e9rifient une condition donn\u00e9e par une fonction en argument. function isBelowThreshold(currentValue) { return currentValue < 40; } var array1 = [1, 30, 39, 29, 10, 13]; console.log(array1.every(isBelowThreshold)); // expected output: true La m\u00e9thode some() teste si au moins un \u00e9l\u00e9ment du tableau passe le test impl\u00e9ment\u00e9 par la fonction fournie. var array = [1, 2, 3, 4, 5]; var even = function(element) { // checks whether an element is even return element % 2 === 0; }; console.log(array.some(even)); // expected output: true La m\u00e9thode reduce() applique une fonction qui est un \u00ab accumulateur \u00bb et qui traite chaque valeur d'une liste (de la gauche vers la droite) afin de la r\u00e9duire \u00e0 une seule valeur. const array1 = [1, 2, 3, 4]; const reducer = (accumulator, currentValue) => accumulator + currentValue; // 1 + 2 + 3 + 4 console.log(array1.reduce(reducer)); // expected output: 10 Parcourir un tableau avec une boucle for : const fruits = [\"Pomme\", \"Melon\", \"Fraise\"] for(let fruit of fruits){ console.log(fruit) } // affiche Pomme, puis Melon, puis Fraise La m\u00e9thode from() permet de cr\u00e9er une nouvelle instance d'Array \u00e0 partir d'un objet it\u00e9rable ou semblable \u00e0 un tableau const paragraphes = document.querySelectorAll(\"p\") // r\u00e9cup\u00e8re tous les paragraphes // paragraphes est une NodeList, qui ressemble \u00e0 un tableau // on ne peut pas appliquer toutes les m\u00e9thodes d'un tableau dessus // on peut le convertir en vrai tableau pour le manipuler comme un tableau const paragraphesArray = Array.from(paragraphes) L'Objet JSON L\u2019objet JSON contient des m\u00e9thodes pour interpr\u00e9ter du JSON (JavaScript Object Notation) et convertir des valeurs en JSON. La m\u00e9thode JSON.parse() parse une cha\u00eene de caract\u00e8res JSON et construit la valeur JavaScript ou l'objet d\u00e9crit par cette cha\u00eene. La m\u00e9thode JSON.stringify() convertit une valeur JavaScript en cha\u00eene JSON. var json = '{\"result\":true, \"count\":42}' obj = JSON.parse(json) console.log(obj.count) // expected output: 42 console.log(JSON.stringify({ x: 5, y: 6 })) // expected output: \"{\"x\":5,\"y\":6}\"","title":"Objets et fonctions utiles Javascript"},{"location":"javascript/objetsEtFonctionsUtilesJavascript/#objets-et-fonctions-utiles-javascript","text":"","title":"Objets et fonctions utiles Javascript"},{"location":"javascript/objetsEtFonctionsUtilesJavascript/#lobjet-math","text":"L'objet Math est un objet natif dont les m\u00e9thodes et propri\u00e9t\u00e9s permettent l'utilisation de constantes et fonctions math\u00e9matiques. Contrairement aux autres objets globaux, Math n'est pas un constructeur. Toutes les propri\u00e9t\u00e9s et les m\u00e9thodes de Math sont statiques. Exemples de propri\u00e9t\u00e9s Math.E // nombre d'Euler, environ 2.718 Math.PI // nombre PI, environ 3.1416 Exemples de m\u00e9thodes Math.abs(x) // retourne la valeur absolue d'un nombre Math.cos(x) // retourne le cosinus d'un nombre Math.sin(x) // retourne le sinus d'un nombre Math.exp(x) // retourne l'exponentielle d'un nombre Math.log(x) // retourne le logarithme naturel (log e) d'un nombre Math.sqrt(x) // retourne la racine carr\u00e9e d'un nombre Math.pow(x,y) // retourne le calcul de x \u00e0 la puissance y Math.max(x,y,...) // retourne la plus grande valeur d'une liste de nombres, par exemple Math.max(0,-5,3,2) retourne 3 Math.min(x,y,...) // retourne la plus petite valeur d'une liste de nombres, par exemple Math.min(0,-5,3,2) retourne -5 Math.random() // retourne un nombre pseudo-al\u00e9atoire compris entre 0 (inclus) et 1 (exclu) Math.floor(x) // retourne le plus grand entier inf\u00e9rieur ou \u00e9gal \u00e0 la valeur pass\u00e9e en param\u00e8tre Math.ceil(x) // retourne le plus petit entier sup\u00e9rieur ou \u00e9gal \u00e0 la valeur pass\u00e9e en param\u00e8tre Math.round(x) // retourne l'arrondi \u00e0 l'unit\u00e9 d'un nombre Math.trunc(x) // retourne la partie enti\u00e8re d'un nombre (diff\u00e9rent de floor() pour les nombres n\u00e9gatifs) Pour arrondir \u00e0 2 chiffres apr\u00e8s la virgule, on peut faire Math.round(x * 100) / 100 . Exemple console.log(Math.round(123.45678 * 100) / 100) // affiche 123.46 Pour g\u00e9n\u00e9rer un nombre al\u00e9atoire entre 1 et 100, on peut faire : const myNumber = Math.trunc(Math.random() * 100) + 1 console.log(myNumber)","title":"L'Objet Math"},{"location":"javascript/objetsEtFonctionsUtilesJavascript/#lobjet-date","text":"Ce constructeur permet de cr\u00e9er des instances Date qui repr\u00e9sentent un moment pr\u00e9cis dans le temps. Les objets Date se basent sur une valeur de temps qui est le nombre de millisecondes depuis 1er janvier 1970 minuit UTC. Sans argument, le constructeur cr\u00e9e un objet Date pour la date du jour et l'heure selon l'heure locale du syst\u00e8me const date = new Date() console.log(date) // affiche : Thu Sep 06 2018 10:17:13 GMT+0200 (heure d\u2019\u00e9t\u00e9 d\u2019Europe centrale) const date2 = Date.now() // retourne la valeur num\u00e9rique correspondant au temps courant. Le nombre de millisecondes depuis le 1 janvier 1970, 00:00:00 UTC console.log(date2) // 1536222742607 On peut aussi cr\u00e9er une date avec des arguments, par exemple le 28 mars 2018 (attention, l'indice des mois commence \u00e0 0) : const date = new Date(2018,2,28) console.log(date) // affiche : Wed Mar 28 2018 00:00:00 GMT+0200 (heure d\u2019\u00e9t\u00e9 d\u2019Europe centrale) const date = new Date('2018/3/28') // \u00e9auivalent en passant une String en param\u00e8tre On peut r\u00e9cup\u00e8re des param\u00e8tres d'une date (mois, jour, heure...). Exemple : const date = new Date() console.log(date) // Thu Sep 06 2018 10:43:30 GMT+0200 (heure d\u2019\u00e9t\u00e9 d\u2019Europe centrale) console.log(date.getDate()) // 6 console.log(date.getDay()) // 4 console.log(date.getMonth()) // 8 console.log(date.getFullYear()) // 2018 console.log(date.getHours()) // 10 console.log(date.getTime()) // 1536223410659 (correspond au nombre de millisecondes depuis le 1er janvier 1970) Calculer le temps \u00e9coul\u00e9 function traitementQuiPrendBeaucoupDeTemps(){ let j = 0 for(let i =0 ; i < 1000000 ; i++){ j++ } return j } // en utilisant les objets Date const debut = Date.now() // l'\u00e9v\u00e8nement \u00e0 mesurer se trouve ici : traitementQuiPrendBeaucoupDeTemps() const fin = Date.now() const tempsEcoule = fin - debut // temps \u00e9coul\u00e9 en millisecondes console.log(tempsEcoule) // affiche 15 // en utilisant les m\u00e9thodes natives const debut2 = new Date() // l'\u00e9v\u00e8nement \u00e0 mesurer se trouve ici : traitementQuiPrendBeaucoupDeTemps() const fin2 = new Date() const tempsEcoule2 = fin2.getTime() - debut2.getTime() // temps \u00e9coul\u00e9 en millisecondes console.log(tempsEcoule2) // affiche 10","title":"L'objet Date"},{"location":"javascript/objetsEtFonctionsUtilesJavascript/#expressions-regulieres","text":"Les expressions r\u00e9guli\u00e8res sont des motifs utilis\u00e9s pour correspondre \u00e0 certaines combinaisons de caract\u00e8res au sein de cha\u00eenes de caract\u00e8res. En JavaScript, les expressions r\u00e9guli\u00e8res sont \u00e9galement des objets. Ces motifs sont utilis\u00e9s avec les m\u00e9thodes exec et test de la classe RegExp , et avec les m\u00e9thodes match , replace , search et split de String . Il est possible de construire une expression r\u00e9guli\u00e8re de deux fa\u00e7ons : const re1 = /ab+c/ // avec un litt\u00e9ral d'expression r\u00e9guli\u00e8re, compil\u00e9 lors du chargement du script. Plus performant si l'expression reste constante const re2 = new RegExp(\"ab+c\") // avec le constructeur de l'objet RegExp, compil\u00e9 lors de l'ex\u00e9cution console.log(re1) // affiche /ab+c/ console.log(re2) // affiche /ab+c/ Exemples d'utilisation des m\u00e9thodes : const monTemplate = /ab/ console.log(monTemplate) // affiche /ab/ // m\u00e9thodes de RegExp // ex\u00e9cute une recherche de correspondance dans une cha\u00eene de caract\u00e8res. Elle renvoie un tableau d'informations ou null lorsqu'il n'y a pas de correspondance console.log(monTemplate.exec(\"abc\")) // affiche un tableau avec l'index \u00e0 l'endroit ou commence le template dans la cha\u00eene console.log(monTemplate.exec(\"qsd\")) // affiche null // teste la pr\u00e9sence d'une correspondance dans une cha\u00eene de caract\u00e8res. Elle renvoie true ou false console.log(monTemplate.test(\"abc\")) // true console.log(monTemplate.test(\"qsd\")) // false // m\u00e9thodes de String // ex\u00e9cute une recherche de correspondance dans une cha\u00eene de caract\u00e8res. Elle renvoie un tableau d'informations ou null lorsqu'il n'y a pas de correspondance console.log(\"abc\".match(monTemplate)) // affiche un tableau comme la m\u00e9thode exec() console.log(\"qsd\".match(monTemplate)) // affiche null // teste la pr\u00e9sence d'une correspondance dans une cha\u00eene de correspondance. Elle renvoie la position de la correspondance ou -1 s'il n'y en a pas console.log(\"abc\".search(monTemplate)) // affiche 0 console.log(\"qsd\".search(monTemplate)) // affiche -1 // recherche une correspondance dans une cha\u00eene de caract\u00e8res et qui remplace la correspondance par une cha\u00eene de substitution console.log(\"abc\".replace(monTemplate, \"ZZZ\")) // affiche ZZZc // utilise une expression r\u00e9guli\u00e8re ou une cha\u00eene de caract\u00e8res pour d\u00e9couper une cha\u00eene de caract\u00e8res en un tableau comprenant les fragments r\u00e9sultants console.log(\"Bonjourabjeabm'appelleabGa\u00ebtan\".split(monTemplate)) // affiche [\"Bonjour\", \"je\", \"m'appelle\", \"Ga\u00ebtan\"] Le motif d'une expression r\u00e9guli\u00e8re est compos\u00e9 de motifs simples comme /abc/ ou de caract\u00e8res sp\u00e9ciaux comme /ab*c/ . Les motifs simples doivent avoir une correspondance directe, on doit observer exactement les caract\u00e8res 'des' ensemble et dans cet ordre pr\u00e9cis. Lorsque le motif \u00e0 trouver est plus complexe qu'une simple \u00e9galit\u00e9, le motif devra contenir des caract\u00e8res sp\u00e9ciaux. (voir la documentation en ligne pour plus de d\u00e9tail). Les expressions r\u00e9guli\u00e8res sont souvent utilis\u00e9s dans les formulaires pour v\u00e9rifier la validit\u00e9 des donn\u00e9es saisies par l'utilisateur.","title":"Expressions R\u00e9guli\u00e8res"},{"location":"javascript/objetsEtFonctionsUtilesJavascript/#settimeout-et-setinterval","text":"Ce sont 2 m\u00e9thodes de l'objet global window . On s'en sert beaucoup dans les animations. La m\u00e9thode setTimeout() permet de d\u00e9finir un \u00ab minuteur \u00bb (timer) qui ex\u00e9cute une fonction ou un code donn\u00e9 apr\u00e8s la fin du d\u00e9lai indiqu\u00e9. Le d\u00e9lai est exprim\u00e9e en millisecondes. function hello(){ console.log(\"hello\") } setTimeout(hello, 2000) // ex\u00e9cute 1 fois hello() au bout de 2 secondes La valeur renvoy\u00e9e par la fonction est un entier qui repr\u00e9sente un identifiant du minuteur cr\u00e9\u00e9 par l'appel \u00e0 setTimeout(). Cet identifiant pourra \u00eatre pass\u00e9 \u00e0 la m\u00e9thode clearTimeout() afin d'annuler ce minuteur donn\u00e9, par exemple avec un bouton. Il est possible d'ex\u00e9cuter plusieurs fois une fonction avec setTimeout() : function hello(){ console.log(\"hello\") setTimeout(hello, 2000) } hello() // la m\u00e9thode s'ex\u00e9cute une premi\u00e8re fois imm\u00e9diatement puis toutes les 2 secondes La m\u00e9thode setInterval() appelle une fonction de mani\u00e8re r\u00e9p\u00e9t\u00e9e, avec un certain d\u00e9lai fix\u00e9 entre chaque appel setInterval(hello, 2000) // ex\u00e9cute hello() toutes de 2 secondes au bout de 2 secondes la premi\u00e8re fois On peut arr\u00eater la m\u00e9thode setInterval() avec la m\u00e9thode clearInterval() . Il faut stocker l'interval dans une variable pour r\u00e9cup\u00e9rer l'intervalID. Dans l'exemple ci-dessous, hello() s'ex\u00e9cute 3 fois. function hello(){ console.log(\"hello\") } const monInterval = setInterval(hello, 2000) setTimeout(function(){ clearInterval(monInterval) }, 6000)","title":"setTimeout et setInterval"},{"location":"javascript/objetsEtFonctionsUtilesJavascript/#fonctions-de-string","text":"L'objet global String est un constructeur de cha\u00eenes de caract\u00e8res. Les objets String sont cr\u00e9\u00e9s en appelant le constructeur new String() . La fonction globale String() peut \u00e9galement \u00eatre appel\u00e9e sans l'op\u00e9rateur new pour cr\u00e9er une cha\u00eene primitive. Les objets String peuvent \u00eatre convertis en cha\u00eenes primitives \u00e0 l'aide de String.valueOf() : // cr\u00e9ation d'une cha\u00eene primitve const chainePrimitive = \"toto\"; // cr\u00e9ation d'un objet String const objetString = new String(chainePrimitive); console.log(typeof chainePrimitive); // affiche \"string\" console.log(typeof objetString); // affiche \"object\" console.log(typeof objetString.valueOf()); // affiche \"string\" \u00c9tant donn\u00e9 que JavaScript effectue automatiquement les conversions entre cha\u00eenes primitives et objets String, toute m\u00e9thode de l'objet String peut \u00eatre appel\u00e9e sur une cha\u00eene primitive. La propri\u00e9t\u00e9 length retourne la longueur de la cha\u00eene. Quelques m\u00e9thodes utiles : - charAt(index) renvoie une nouvelle cha\u00eene contenant le caract\u00e8re \u00e0 la position indiqu\u00e9e en argument - concat(string2,...stringN) combine le texte de plusieurs cha\u00eenes avec la cha\u00eene appelante et renvoie la nouvelle cha\u00eene ainsi form\u00e9e - endsWith(cha\u00eeneRecherch\u00e9e) renvoie un bool\u00e9en indiquant si la chaine de caract\u00e8res se termine par la chaine de caract\u00e8res fournie en argument - indexOf(valeurRecherch\u00e9e) renvoie l'indice de la premi\u00e8re occurence de la valeur cherch\u00e9e au sein de la cha\u00eene courante. Elle renvoie -1 si la valeur cherch\u00e9e n'est pas trouv\u00e9e - lastIndexOf(valeurRecherch\u00e9e) envoie l'indice, dans la cha\u00eene courante, de la derni\u00e8re occurence de la valeur donn\u00e9e en argument. Si cette sous-cha\u00eene n'est pas trouv\u00e9e, la m\u00e9thode renvoie -1 - replace() rechercher une correspondance entre une expression r\u00e9guli\u00e8re et une cha\u00eene, et remplace la sous-cha\u00eene correspondante par une nouvelle cha\u00eene - search(regexp) renvoie l'indice de la premi\u00e8re correspondance pour l'expression r\u00e9guli\u00e8re au sein de la chaine de caract\u00e8res, sinon, la m\u00e9thode renvoie -1 - slice(indiceDebut[, indiceFin]) extrait une section d'une chaine de caract\u00e8res et la retourne comme une nouvelle chaine de caract\u00e8res - split(s\u00e9parateur) permet de diviser une cha\u00eene de caract\u00e8res \u00e0 partir d'un s\u00e9parateur pour fournir un tableau de sous-cha\u00eenes - startsWith(cha\u00eeneRecherch\u00e9e) renvoie un bool\u00e9en indiquant si la chaine de caract\u00e8res commence par la deuxi\u00e8me chaine de caract\u00e8res fournie en argument - substring(indiceA[, indiceB]) retourne une sous-cha\u00eene de la cha\u00eene courante, entre un indice de d\u00e9but et un indice de fin - toLowerCase() retourne la cha\u00eene de caract\u00e8res courante en minuscules - toString() renvoie une chaine de caract\u00e8res repr\u00e9sentant l'objet renseign\u00e9 - toUpperCase() retourne la valeur de la cha\u00eene courante, convertie en majuscules - trim() permet de retirer les blancs en d\u00e9but et fin de cha\u00eene - valueOf() renvoie la valeur primitive de l'objet String Exemples : console.log(gaetan.length) // affiche 6 console.log(gaetan.charAt(1)) // affiche a console.log(gaetan[1]) // affiche a console.log(gaetan.concat(\" et Louis\")) // affiche Ga\u00ebtan et Louis console.log(gaetan.substring(1,3)) // affiche a\u00eb","title":"Fonctions de String"},{"location":"javascript/objetsEtFonctionsUtilesJavascript/#fonctions-de-array","text":"L'objet global Array est utilis\u00e9 pour cr\u00e9er des tableaux. On peut cr\u00e9er un tableau avec le constructeur Array, et aussi la syntaxe crochets. La propri\u00e9t\u00e9 length retourne la longueur de la cha\u00eene. Un tableau contient plusieurs valeurs appel\u00e9es item . Chaque item est accessible au moyen d\u2019un indice dont la num\u00e9rotation commence \u00e0 0. On acc\u00e9de \u00e0 un \u00e9l\u00e9ment d'un tableau en indiquant son indice entre crochets et on peut modifier la valeur d'un \u00e9l\u00e9m\u00e9net de cette mani\u00e8re. const myArray = [1, 2, 3, 4, 5] const myArray2 = new Array(1, 2, 3, 4, 5) console.log(myArray.length) // affiche 5 console.log(myArray[0]) // affiche 1, le premier \u00e9l\u00e9ment du tableau myArray[0]=8 // modifie la valeur du premier \u00e9l\u00e9ment du tableau console.log(myArray[0]) // affiche 8, le premier \u00e9l\u00e9ment du tableau console.log(myArray[myArray.length-1]) // affiche 5, le dernier \u00e9l\u00e9ment du tableau const myArray = [1, 2, 3, 4, 5] myArray.push(6) // ajoute l'\u00e9l\u00e9ment en param\u00e8tre \u00e0 la fin du tableau myArray.pop() // enl\u00e8ve le dernier \u00e9l\u00e9ment du tableau et le retourne myArray.shift() // enl\u00e8ve le premier \u00e9l\u00e9ment du tableau et le retourne myArray.unshift(0) // ajoute l'\u00e9l\u00e9ment en param\u00e8tre au d\u00e9but du tableau console.log(myArray) isArray() permet de d\u00e9terminer si l'objet pass\u00e9 en argument est un objet Array reverse() permet d'inverser l'ordre des \u00e9l\u00e9ments du tableau. La m\u00e9thode modifie le tableau courant et renvoie une r\u00e9f\u00e9rence \u00e0 ce tableau sort() trie les \u00e9l\u00e9ments d'un tableau, dans ce m\u00eame tableau, et renvoie le tableau splice() modifie le contenu d'un tableau en retirant des \u00e9l\u00e9ments et/ou en ajoutant de nouveaux \u00e9l\u00e9ments const mesPoissons = [\"scalaire\", \"clown\", \"mandarin\", \"chirurgien\"] // supprime 0 \u00e9l\u00e9ment \u00e0 partir de l'index 2, et ins\u00e8re \"tambour\" enleves = mesPoissons.splice(2, 0, \"tambour\") // mesPoissons est [\"scalaire\", \"clown\", \"tambour\", \"mandarin\", \"chirurgien\"] // enleves est [], aucun \u00e9l\u00e9ment supprim\u00e9 // supprime 1 \u00e9l\u00e9ment \u00e0 partir de l'index 3 enleves = mesPoissons.splice(3, 1) // mesPoissons est [\"scalaire\", \"clown\", \"tambour\", \"chirurgien\"] // enleves est [\"mandarin\"] // supprime 1 \u00e9l\u00e9ment \u00e0 partir de l'index 2, et ins\u00e8re \"trompette\" enleves = mesPoissons.splice(2, 1, \"trompette\") // mesPoissons est [\"scalaire\", \"clown\", \"trompette\", \"chirurgien\"] // enleves est [\"tambour\"] concat(array2) est utilis\u00e9e afin de fusionner un ou plusieurs tableaux en les concat\u00e9nant. Cette m\u00e9thode ne modifie pas les tableaux existants, elle renvoie un nouveau tableau qui est le r\u00e9sultat de l'op\u00e9ration includes(\u00e9l\u00e9mentRecherch\u00e9) permet de d\u00e9terminer si un tableau contient un \u00e9l\u00e9ment et renvoie true si c'est le cas, false sinon indexOf(\u00e9l\u00e9mentRecherch\u00e9) renvoie le premier indice pour lequel on trouve un \u00e9l\u00e9ment donn\u00e9 dans un tableau. Si l'\u00e9l\u00e9ment cherch\u00e9 n'est pas pr\u00e9sent dans le tableau, la m\u00e9thode renverra -1 var beasts = ['ant', 'bison', 'camel', 'duck', 'bison']; console.log(beasts.indexOf('bison')); // expected output: 1 console.log(beasts.indexOf('bison', 2)); // start from index 2, expected output: 4 console.log(beasts.indexOf('giraffe')); // expected output: -1 join(s\u00e9parateur) r\u00e9unit tous les \u00e9l\u00e9ments d'un tableau dans une chaine de caract\u00e8res et renvoie cette nouvelle cha\u00eene de caract\u00e8res lastIndexOf(\u00e9l\u00e9mentRecherch\u00e9) permet de renvoyer le dernier indice pour lequel une valeur donn\u00e9e est pr\u00e9sente dans un tableau. Si la valeur recherch\u00e9e n'est pas pr\u00e9sente, le r\u00e9sultat sera -1 slice() renvoie un objet tableau contenant une copie d'une portion du tableau d'origine. La portion est d\u00e9finie par un indice de d\u00e9but et un indice de fin exclu optionnel var animals = ['ant', 'bison', 'camel', 'duck', 'elephant']; console.log(animals.slice()); // expected output: Array ['ant', 'bison', 'camel', 'duck', 'elephant'] console.log(animals.slice(2)); // expected output: Array ['camel', 'duck', 'elephant'] console.log(animals.slice(2, 4)); // expected output: Array ['camel', 'duck'] toString() renvoie une chaine de caract\u00e8res repr\u00e9sentant le tableau sp\u00e9cifi\u00e9 et ses \u00e9l\u00e9ments const mesPoissons = [\"scalaire\", \"clown\", \"mandarin\", \"chirurgien\"] console.log(mesPoissons.toString()) // scalaire,clown,mandarin,chirurgien Les m\u00e9thodes d'it\u00e9ration La m\u00e9thode every() permet de tester si tous les \u00e9l\u00e9ments d'un tableau v\u00e9rifient une condition donn\u00e9e par une fonction en argument : function isBelowThreshold(currentValue) { return currentValue < 40; } var array1 = [1, 30, 39, 29, 10, 13]; console.log(array1.every(isBelowThreshold)); // expected output: true La m\u00e9thode forEach() permet d'ex\u00e9cuter une fonction donn\u00e9e sur chaque \u00e9l\u00e9ment du tableau. La m\u00e9thode map() cr\u00e9e un nouveau tableau avec les r\u00e9sultats de l'appel d'une fonction fournie sur chaque \u00e9l\u00e9ment du tableau appelant. La m\u00e9thode filter() cr\u00e9e et retourne un nouveau tableau contenant tous les \u00e9l\u00e9ments du tableau d'origine qui remplissent une condition d\u00e9termin\u00e9e par la fonction callback. const myArray = [1, 2, 3, 4, 5] myArray.forEach((element, index, array) => { console.log(element+\" \"+index+\" \"+array) }) // a 0 a,b,c,d,e // b 1 a,b,c,d,e ... const myArray2 = myArray.map(element => { return element * 2 }) console.log(myArray2) // [2, 4, 6, 8, 10] const myArray3 = myArray.filter(element => { return element >= 3 }) console.log(myArray3) // [3, 4, 5] La m\u00e9thode every() permet de tester si tous les \u00e9l\u00e9ments d'un tableau v\u00e9rifient une condition donn\u00e9e par une fonction en argument. function isBelowThreshold(currentValue) { return currentValue < 40; } var array1 = [1, 30, 39, 29, 10, 13]; console.log(array1.every(isBelowThreshold)); // expected output: true La m\u00e9thode some() teste si au moins un \u00e9l\u00e9ment du tableau passe le test impl\u00e9ment\u00e9 par la fonction fournie. var array = [1, 2, 3, 4, 5]; var even = function(element) { // checks whether an element is even return element % 2 === 0; }; console.log(array.some(even)); // expected output: true La m\u00e9thode reduce() applique une fonction qui est un \u00ab accumulateur \u00bb et qui traite chaque valeur d'une liste (de la gauche vers la droite) afin de la r\u00e9duire \u00e0 une seule valeur. const array1 = [1, 2, 3, 4]; const reducer = (accumulator, currentValue) => accumulator + currentValue; // 1 + 2 + 3 + 4 console.log(array1.reduce(reducer)); // expected output: 10 Parcourir un tableau avec une boucle for : const fruits = [\"Pomme\", \"Melon\", \"Fraise\"] for(let fruit of fruits){ console.log(fruit) } // affiche Pomme, puis Melon, puis Fraise La m\u00e9thode from() permet de cr\u00e9er une nouvelle instance d'Array \u00e0 partir d'un objet it\u00e9rable ou semblable \u00e0 un tableau const paragraphes = document.querySelectorAll(\"p\") // r\u00e9cup\u00e8re tous les paragraphes // paragraphes est une NodeList, qui ressemble \u00e0 un tableau // on ne peut pas appliquer toutes les m\u00e9thodes d'un tableau dessus // on peut le convertir en vrai tableau pour le manipuler comme un tableau const paragraphesArray = Array.from(paragraphes)","title":"Fonctions de Array"},{"location":"javascript/objetsEtFonctionsUtilesJavascript/#lobjet-json","text":"L\u2019objet JSON contient des m\u00e9thodes pour interpr\u00e9ter du JSON (JavaScript Object Notation) et convertir des valeurs en JSON. La m\u00e9thode JSON.parse() parse une cha\u00eene de caract\u00e8res JSON et construit la valeur JavaScript ou l'objet d\u00e9crit par cette cha\u00eene. La m\u00e9thode JSON.stringify() convertit une valeur JavaScript en cha\u00eene JSON. var json = '{\"result\":true, \"count\":42}' obj = JSON.parse(json) console.log(obj.count) // expected output: 42 console.log(JSON.stringify({ x: 5, y: 6 })) // expected output: \"{\"x\":5,\"y\":6}\"","title":"L'Objet JSON"},{"location":"javascript/vraimentBienComprendreJavaScript/","text":"Vraiment bien comprendre JavaScript ---- Les variables Les diff\u00e9rents types de variables console.log(true); console.log(typeof true) // boolean console.log(1); console.log(typeof 1) // number console.log(\"Louis\"); console.log(typeof \"Louis\") // string console.log({name: \"Louis\"}); console.log(typeof {name: \"Louis\"}) // object Diff\u00e9rence entre undefined , null et is not defined - undefined : variable d\u00e9clar\u00e9e mais n'a pas re\u00e7u de valeur - null : variable d\u00e9finie par l'utilisateur - is not defined : variable non d\u00e9clar\u00e9e var a; console.log(a) // undefined var b = null; console.log(b) // null console.log(c) // c is not defined Le hoisting (hissage) JavaScript passe le code en revu et recherche les d\u00e9clarations de fonction et les hisse dans le haut de code, ce qui fait qu'on peut ex\u00e9cuter une fonction avant de la d\u00e9clarer. addition(1,3) function addition(a,b){ console.log(a+b) } Cela fonctionne pour les d\u00e9clarations de fonction, mais pas pour les fonctions anonymes stock\u00e9es dans une variable comme l'exemple ci-dessous. Pour que cet exemple fonctionne, il faut appeler addition() apr\u00e8s sa d\u00e9claration. addition(1,3) var addition = function(a,b){ console.log(a+b) } JavaScript hisse \u00e9galement la d\u00e9claration des variables, sans l'assignation de la valeur. console.log(x) // undefined var x = 5 console.log(y) // y is not defined C'est comme-ci on avait fait : var x console.log(x) // undefined var x = 5 Les types primitifs vs les objets Les variables de type primitif sont copi\u00e9s par valeur, les variables de type objet sont copi\u00e9s par r\u00e9f\u00e9rence. var x = 5 // 5 est stock\u00e9 en m\u00e9moire dans la variable x var y = x // 5 est stock\u00e9 en m\u00e9moire dans la variable y y = 8 // 8 est stock\u00e9 en m\u00e9moire dans la variable y console.log(x) console.log(y) var a = {name: \"Louis\"} // un espace m\u00e9moire est cr\u00e9\u00e9 pour stocker l'objet `{name:\"Louis\"}` et l'adresse de cet espace m\u00e9moire est stock\u00e9e dans l'espace m\u00e9moire de la variable a. On dit que l'espace m\u00e9moire de a est un pointeur. console.log(a) // affiche {name: \"Louis\"} var b = a // un espace m\u00e9moire est cr\u00e9e pour b qui pointe vers le m\u00eame objet que a b.name = \"Ga\u00ebtan\" // comme a et b pointe vers le m\u00eame objet, la modification de b entra\u00eene donc la modification de a console.log(a) // affiche {name: \"Ga\u00ebtan\"} console.log(b) // affiche {name: \"Ga\u00ebtan\"} var a = {name: \"Louis\"} console.log(a) // affiche {name: \"Louis\"} var b = a b = {name: \"Ga\u00ebtan\"} // cr\u00e9e un nouvel objet qui est stock\u00e9 dans un nouvel espace m\u00e9moire. b ne pointe donc plus vers le m\u00eame objet que a console.log(a) // affiche {name: \"Louis\"} console.log(b) // affiche {name: \"Ga\u00ebtan\"} La d\u00e9claration des variables Avec l'ES6, en plus du mot cl\u00e9 var , on peut utiliser les mots-cl\u00e9s let et const . var a = 5 console.log(a) // 5 let b = 6 console.log(b) // 6 const c = 7 console.log(c) // 7 Une constante doit avoir une valeur d\u00e8s sa d\u00e9claration et ne pas peut \u00eatre modifi\u00e9e. On ne peut pas faire : ```js const a; // ERREUR const b = 1; b=2; // ERREUR On ne peut pas assigner un nouvel objet \u00e0 une variable `const` mais on peut modifier les propri\u00e9t\u00e9s d'un objet ```js const a = {name: \"Louis\"} a.name = \"Ga\u00ebtan\" console.log(a) // {name: \"Ga\u00ebtan\"} const b = {name: \"Louis\"} b = {name: \"Ga\u00ebtan\"} // Erreur : on ne peut pas modifier la valeur d'une const Il n'y a pas de hissage avec const et let comme avec var console.log(a) // undefined var a = 5 console.log(b) // b is not defined let b = 5 Quand utiliser let , const et var ne plus utiliser le var toujours utiliser le const si on r\u00e9assigne une valeur \u00e0 la variable, utiliser le let ---- Les scopes Contexte d'ex\u00e9cution Un contexte d'ex\u00e9cution est un contexte dans lequel un certain bout de code est ex\u00e9cut\u00e9. Cela concerne les infos sur les variables qu'il va d\u00e9finir, auquel il va pouvoir acc\u00e9der... A chaque fois qu'une fonction est ex\u00e9cut\u00e9e , un nouveau contexte d'ex\u00e9cution est cr\u00e9\u00e9. Pour le code qui n'est pas dans une fonction, il appartient au contexte d'ex\u00e9cution global. Un contexte d'ex\u00e9cution est compos\u00e9 de 3 choses : 1. l'objet des variables : fonctions et variables qui sont d\u00e9finies dans ce bout de code 2. la cha\u00eene des scopes : variables auquel peut acc\u00e9der ce bout de code 3. le this : l'objet associ\u00e9 \u00e0 ce bout de code L'objet des variables L'objet des variables, ou Variable Objet (VO) , est cr\u00e9\u00e9 et initialis\u00e9 pendant la phase de cr\u00e9ation du contexte d'ex\u00e9cution. Il contient : - les arguments de la fonction - les d\u00e9clarations de fonctions avec le hoisting - les d\u00e9clarations de variables avec le hoisting (les variables d\u00e9clar\u00e9es avec var ) La cha\u00eene des scopes Le scope veut dire port\u00e9e en fran\u00e7ais. Cela permet de savoir \u00e0 quel endroit du code il est possible d'acc\u00e9der \u00e0 quelle variable. Le code qui n'appartient \u00e0 aucune fonction appartient au scope global. A chaque fois qu'une fonction est ex\u00e9cut\u00e9e, un scope local est cr\u00e9\u00e9, on parle de scope de fonction . Pour les variables cr\u00e9\u00e9es avec let et const , un scope de bloc est cr\u00e9\u00e9 (cf ci-apr\u00e8s). Une r\u00e8gle de base sur les scopes est qu'une fonction enfant peut acc\u00e9der au scope de ses parents, c'est-\u00e0-dire \u00e0 son objet des variables ainsi qu'\u00e0 l'objet des variables de ses parents. Si on d\u00e9clare une variable dans une fonction alors qu'une variable avec le m\u00eame nom existe d\u00e9j\u00e0 dans un scope sup\u00e9rieur, une nouvelle variable est d\u00e9finie, dans un espace m\u00e9moire diff\u00e9rent, et c'est celle du scope local qui est utilis\u00e9e. Lorsqu'on cherche une variable, on cherche d'abord la variable dans le scope local et si elle n'existe pas, on remonte la cha\u00eene des scopes jusqu'\u00e0 trouver notre variable. Le scope de bloc (ES6) Chaque fonction cr\u00e9e un nouvdau scope. Jusqu'\u00e0 l'arriv\u00e9e d'ES6, il n'y avait que le scope de fonction. Lorsqu'on d\u00e9clare des variables avec let et const , les variables ne respectent pas les scopes de fonction mais les scopes de bloc. Un bloc est tout ce qui est entre accolades. Par exemple, le code suivant ne fonctionne pas alors que \u00e7a aurait fonctionn\u00e9 avec le mot cl\u00e9 var . if(true){ let a = 5; } console.log(a) // a is not defined L'exemple suivant fonctionne car la variable est d\u00e9finie dans le m\u00eame scope qu'on souhaite l'afficher let a if(true){ a = 5; } console.log(a) // affiche 5 Il faut \u00e9viter d'utiliser le mot cl\u00e9 var et privil\u00e9gier const et let pour \u00e9viter les mauvaises surprises. Par exemple : var i = 62 for(i = 0 ; i < 10 ; i++){ console.log(i) } console.log(i) // affiche 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 et 10 let i = 62 for(let i = 0 ; i < 10 ; i++){ console.log(i) } console.log(i) // affiche 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 et 62 ---- Les fonctions Fonction Premi\u00e8re Classe Les fonctions sont des objets de premi\u00e8re classe, c'est-\u00e0-dire que ce sont des objets comme les autres. une fonction peut prendre une fonction en argument function addTwo(numberToAdd){ return numberToAdd + 2 } function myFunction(argFunction, number){ const x = argFunction(number) console.log(x) } myFunction(addTwo, 5) // affiche 7 une fonction peut retourner une autre fonction function myFunction(){ return function(number){ return number * 2 } } console.log(myFunction) // affiche la d\u00e9claration de myFonction console.log(myFunction()) // affiche la d\u00e9claration de la fonction anonyme : \u0192unction(number){return number * 2} console.log(myFunction()(3)) // affiche 6 on peut assigner une fonction \u00e0 une variable const returnedFunction = function(){ return 5+2 } console.log(returnedFunction()) // affiche 7 function myFunction(){ return 5+2 } const returnedFunction = myFunction() console.log(returnedFunction) // affiche 7 Les closures Une closure, est une fermeture. C'est une fonction qui a enferm\u00e9 avec elle des variables qui lui sont externes, provenant d'un scope parent. function multiplyBy(number){ const closedVariable = number return function(anotherNumber){ return closedVariable * anotherNumber } } const multiplyByFive = multiplyBy(5) const multiplyByThree = multiplyBy(3) console.log(multiplyByFive) // function(anotherNumber){return closedVariable * anotherNumber} console.log(multiplyByFive(2)) // 10 console.log(multiplyByThree(2)) // 6 Dans cet exemple, mutilyByFive utilise la variable closedVariable lors de son ex\u00e9cution avec lesparam\u00e8tre 2, alors que closedVariable fait parti du contexte d'ex\u00e9cution de multiplyBy(5) qui a disparu apr\u00e8s l'ex\u00e9cution de la fonction, donc closedVariable devrait avoir disparu, mais il est toujours disponible dans multiplyByFive, c'est ce qu'on appelle une closure car la fonction a captur\u00e9 une variable d'un scope parent. C'est la m\u00eame chose pour multiplyByThree. M\u00e9fiez-vous des scopes Il faut prot\u00e9ger ses variables pour \u00e9viter qu'elles soient \"pirat\u00e9es\" par un autre script. Exemple avec une page HTML qui charge 3 scripts : <!DOCTYPE html> <html> <head> <script src=\"script1.js\"></script> <script src=\"script2.js\"></script> <script src=\"script3.js\"></script> </head> // script1.js var myPassword = \"12345\" function setPassword(newPassword){ myPassword = newPassword } function getPassword(){ return myPassword } // script2.js var myPassword = \"000\" // script3.js console.log(getPassword()) // affiche 000 alors qu'on voulait 12345 Dans le script 3, on veut r\u00e9cup\u00e9rer myPassword de script 1 mais elle a \u00e9t\u00e9 \u00e9cras\u00e9 par myPassword du script 2 car les variables ont le m\u00eame nom et elles sont toutes les 2 dans le scope global. Il faut \u00e9viter au maximum de rattacher les variables au scope global. Il faut d\u00e9finir ce qu'on souhaite rendre priv\u00e9 (uniquement utilisable dans le script courant) et ce qu'on veut rendre public, c'est-\u00e0-dire rendre accessible aux autres scripts. Pour cela on va utiliser les IIFEs IIFEs Les fonctions imm\u00e9diatement ex\u00e9cut\u00e9es se nomment des Immediatly-Invoked Function Expression , abr\u00e9g\u00e9es IIFE. L'id\u00e9e est d\u00e9clarer la fonction et de l'ex\u00e9cuter en m\u00eame temps. En utilisant une IIFE, tout le code ex\u00e9cut\u00e9 dedans sera priv\u00e9 et non accessible de l'ext\u00e9rieur. // fonction classique function myFunction(){ // code de la fonction } // IIFE (function(){ // code de la fonction })() Pour revenir \u00e0 notre exemple pr\u00e9c\u00e9dent o\u00f9 lon veut rendre public getPassword() et rendre priv\u00e9 myPassword et setPassword , on peut utiliser les IIFEs et les closures pour r\u00e9soudre ce probl\u00e8me. const getPassword = (function(){ var myPassword = \"12345\" function setPassword(newPassword){ myPassword = newPassword } return function(){ return myPassword } })() Cet exemple permet de rendre accessible la fonction getPassword uniquement de ce script. Cependant, cela permet uniquement d'exposer une variable ou une fonction. Il est possible de rendre public plusieurs \u00e9l\u00e9ments public en retournant un objet : const script1 = (function(){ var myPassword = \"12345\" function setPassword(newPassword){ myPassword = newPassword } function getPassword(){ return myPassword } return { getPassword: getPassword, setPassword: setPassword, } })() // appel dans le script 3 console.log(script1.getPassword()) Le mot cl\u00e9 THIS A chaque contexte d'ex\u00e9cution est associ\u00e9 un objet. this permet d'acc\u00e9der \u00e0 cet objet. console.log(this) // donne Window qui est l'objet global dans le navigateur. JavaScript ex\u00e9cut\u00e9 dans un autre environnement comme un serveur aurait donn\u00e9 un autre objet global. Le this est l'objet qui a ex\u00e9cut\u00e9 la m\u00e9thode, sinon ce sera l'objet global function first(){ console.log(this) } first() // Window const louis = { name: \"Louis\", present: first } louis.present() // {name: \"Louis\", present: \u0192} Choses bizarres Les d\u00e9clarations de variables avec var et les d\u00e9clarations de fonctions dans le contexte d'ex\u00e9cution global sont stock\u00e9es dans l'objet global Window. Ce n'est pas le cas pour les variables d\u00e9clar\u00e9es avec let et const . var a = 5 function allo(){ } console.log(this) // on retrouve a et allo() dans Window var myName = \"Louis\" console.log(window.myName === this.myName && window.myName === myName) // affiche true Si on oublie le mot cl\u00e9 var pour d\u00e9clarer une variable, elle est automatiquement rattach\u00e9 \u00e0 l'objet global, m\u00eame si elle est d\u00e9clar\u00e9e dans une fonction. function allo(){ b = 9 } allo() console.log(this) // on retrouve b dans l'objet Window Pour \u00e9viter cela, on peut utiliser le mode strict en ajoutant la commande 'use strict' en haut du fichier javascript et ce qui aura pour effet dans le script pr\u00e9c\u00e9dent de renvoyer une erreur en disant que b n'est pas d\u00e9fini. Bind, Call et Apply Ces m\u00e9thodes vont permettre de contr\u00f4ler la valeur du this . bind est une m\u00e9thode qui permet de changer la valeur du this en appliquant le this d'un autre objet. function first(){ console.log(this) } first() // affiche l'objet global Window const louis = { name: \"Louis\", present: function(){ console.log(this) } } const second = first.bind(louis) // fixe le this de louis sur la fonction second second() // affiche l'objet louis louis.present() // affiche l'objet louis louis.present.bind(window)() // affiche l'objet Window car on a chang\u00e9 la valeur de this en mettant Window \u00e0 la place de louis Voici quelques autres exemples var name = \"Louis\" function present(){ console.log(this.name) } const kev = { name: \"K\u00e9vin\", present: present } const thib = { name: \"Thibaut\", present: present.bind(this) } const presentKev = kev.present const presentKevBind = kev.present.bind(kev) const presentKevBind2 = kev.present.bind(this) present() // affiche Louis : comme ce n'est pas un objet qui ex\u00e9cute la fonction, c'est l'objet global Window qui l'ex\u00e9cute. Le this est donc associ\u00e9 \u00e0 Window, on cherche donc \u00e0 logguer un window.name et on a d\u00e9clar\u00e9 la variable name dans le scope global, qui est donc attach\u00e9 \u00e0 l'objet Window, donc window.name = \"John\" kev.present() // affiche K\u00e9vin : present est ex\u00e9cut\u00e9e en tant que m\u00e9thode de l'objet kev donc le this est kev presentKev() // affiche Louis : presentKev est \u00e9gale \u00e0 une m\u00e9thode d'un objet mais elle est ex\u00e9cut\u00e9e en tant que fonction et n'est pas associ\u00e9e \u00e0 un objet, le this est donc Window presentKevBind() // affiche K\u00e9vin : comme la m\u00e9thode pr\u00e9c\u00e9dente sauf que le this a \u00e9t\u00e9 bind\u00e9 avec l'objet kev presentKevBind2() // affiche Louis comme pour presentKev en bindant le this qui correspond \u00e0 Window, donc \u00e7a ne change rien de faire le bind dans ce cas thib.present() // affiche Louis : la m\u00e9thode present est bind\u00e9e avec this dans l'objet franck et le this correspond \u00e0 Window \u00e0 ce moment l\u00e0 bind permet aussi de fixer la valeur des arguments que va prendre la nouvelle fonction que l'on cr\u00e9e. function multiply(number1, number2){ return number1 * number2 } // on fixe la valeur du premier argument de multiply \u00e0 2. // multiplyByTwo prend donc un seul argument qui correspond au number2 de multiply const multiplyByTwo = multiply.bind(this, 2) console.log(multiplyByTwo(3)) // affiche 6 Les m\u00e9thodes call et apply ne cr\u00e9ent pas une nouvelle fonction qu'il faut ensuite ex\u00e9cuter comme bind , elles l'ex\u00e9cutent directement. function multiply(number1, number2){ console.log(this) console.log(number1 * number2) } const louis = { name: \"Louis\" } multiply.bind(louis, 2, 3)() // affiche louis et 6 // call ex\u00e9cute directement multiplly multiply.call(louis, 2, 3) // affiche Window et 6 comme bind // apply prend les arguments de la fonction dans un tableau multiply.apply(louis, [2, 3]) // affiche Window et 6 comme bind Les fonctions fl\u00e9ch\u00e9es (Arrow Functions) Les fonctions fl\u00e9ch\u00e9es ont 2 particularit\u00e9es : - la syntaxe est plus rapide - elles vont fixer la valeur du this automatiquement La syntaxe : const myFunction = arg => arg * 5 console.log(myFunction(3)) // affiche 15 const myFunction2 = () => 4 * 5 console.log(myFunction2()) // affiche 20 const myFunction3 = (nombre1, nombre2) => nombre1 * nombre2 console.log(myFunction3(3, 4)) // affiche 12 On peut utiliser des accolades si la fonction fait davantage que retourner une valeur, comme par exemple ex\u00e9cuter du code avant. const myFunction3 = (nombre1, nombre2) => { const nombreCalcule = nombre1 * nombre1 return nombreCalcule * nombre2 } console.log(myFunction3(3, 4)) // affiche 36 (3 * 3 * 4) Fonctionne aussi sur les objets louis = { name: \"Louis\", // syntaxe classique present: function(friend){ return \"Tu connais \"+friend+\" ?\" }, // nouvelle syntaxe presentArrow: friend => \"Tu connais \"+friend+\" ?\" } console.log(louis.present(\"K\u00e9vin\")) console.log(louis.presentArrow(\"Thibaut\")) Les fonctions fl\u00e9ch\u00e9es fixent la valeur du this automatiquement. Dans l'exemple ci-dessous, le this de presentClassic est l'objet louis car c'est l'objet louis qui a ex\u00e9cut\u00e9 la m\u00e9thode. Pour presentArrow , son this est Windows. Une fonction fl\u00e9ch\u00e9e capture le this du scope parent o\u00f9 elle a \u00e9tait d\u00e9clar\u00e9e. Il faut donc regarder \u00e0 quoi correspond le this de l'endroit o\u00f9 elle a \u00e9t\u00e9 d\u00e9clar\u00e9e. Cela revient au m\u00eame que l'ex\u00e9cution d'une fonction classique o\u00f9 on aurait bind\u00e9 le this. function classicFunction(){ console.log(this) } const classicFunctionBind = classicFunction.bind(this) const arrowFunction = () => { console.log(this) } const louis = { name: \"Louis\", presentClassic: classicFunction, presentClassicBind: classicFunctionBind, presentArrow: arrowFunction, } louis.presentClassic() // affiche louis louis.presentClassicBind() // affiche Window louis.presentArrow() // affiche Window ---- Les objets Fonction constructeur Une fonction constructeur est un moule. En ex\u00e9cutant cette fonction, on cr\u00e9e des instances bas\u00e9es sur ce moule. function Person(name, age){ this.name = name this.age = age this.present = () => {console.log(\"Hello my name is \"+this.name)} } let louis = new Person(\"Louis\", 0) let thibaut = new Person(\"Thibaut\", 23) louis.present() // Hello my name is Louis thibaut.present() // Hello my name is Thibaut console.log(louis) // affiche l'objet louis console.log(thibaut) // affiche l'objet thibaut console.log(louis.present === thibaut.present) // affiche false present de louis et present de thibaut sont 2 m\u00e9thodes diff\u00e9rentes qui font la m\u00eame chose, donc elles sont stock\u00e9es deux fois en m\u00e9moire alors qu'on aurait pu les stocker qu'une fois. On va pouvoir faire cela avec les prototypes. Les prototypes On va stocker la fonction dans le prototype de Person, comme \u00e7a elle sera unique. Il faut utiliser une fonction classique au lieu d'une fonction fl\u00e9ch\u00e9e, car une fonction fl\u00e9ch\u00e9e capturerait le this de l'endroit o\u00f9 elle est d\u00e9clar\u00e9e, c'est-\u00e0-dire l'objet global. function Person(name, age){ this.name = name this.age = age //this.present = () => {console.log(\"Hello my name is \"+this.name)} } Person.prototype.present = function(){ console.log(\"Hello my name is \"+this.name) } let louis = new Person(\"Louis\", 0) let thibaut = new Person(\"Thibaut\", 23) louis.present() // Hello my name is Louis console.log(louis.present === thibaut.present) // affiche true Dans l'exemple pr\u00e9c\u00e9dent sans utiliser les prototypes, si on regarde ce que contient l'objet Person , il y a les attributs name et age , la fonction present , et l'objet __proto__ , qui contient lui-m\u00eame le constructeur de Person . En d\u00e9clarant la fonction dans le prototype, la fonction present n'est plus dans l'objet Person mais dans l'objet __proto__ . __proto__ correspond au prototype de la personne et il est accessible \u00e0 toutes les instances cr\u00e9\u00e9es avec la fonction constructeur Person . console.log(louis.__proto__ === Person.prototype) // affiche true console.log(louis.__proto__ === thibaut.__proto__) // affiche true Tout est un objet Si on rentre dans l'objet __proto__ de Person , il y a un autre __proto__ qui est celui d' Object . Object est l'objet le plus haut, il n'y a rien au dessus. Pratiquement tout en Javascript descend d' Object , comme par exemple les Array (tableaux), les String , les Number , les fonctions. Exemple en partant du code de l'exemple pr\u00e9c\u00e9dent : const myObject = {} console.log(louis.__proto__.__proto__ === myObject.__proto__) // affiche true Cela permet d'utiliser les m\u00e9thodes des objets parents, comme par exemple la m\u00e9thode hasOwnProperty qui renvoi un bool\u00e9en pour savoir si une propri\u00e9t\u00e9e pass\u00e9e en param\u00e8tre existe dans l'objet. console.log(louis.hasOwnProperty(\"name\")) // affiche true console.log(louis.hasOwnProperty(\"color\")) // affiche false La cha\u00eene des constructeurs Les objets ont acc\u00e8s aux m\u00e9thodes d\u00e9clar\u00e9es dans la fonction constructeur, dans le prototype, et aux m\u00e9thodes des prototypes parents, notamment d' Object . Si une m\u00e9thode \u00e0 le m\u00eame nom dans la fonction constructeur et dans le prototype, c'est celle dans la fonction constructeur qui sera ex\u00e9cut\u00e9e car il y a un ordre de pr\u00e9f\u00e9rence. C'est ce qu'on appelle la cha\u00eene des prototypes : - la m\u00e9thode est d'abord recherch\u00e9e sur notre objet lui-m\u00eame - si rien n'est trouv\u00e9, elle est cherch\u00e9e sur le prototype de notre objet - si rien n'est encore trouv\u00e9, elle est cherch\u00e9e sur le prototype de l'objet parent, par exemple Object function Person(name, age){ this.name = name this.age = age } let louis = new Person(\"Louis\", 0) console.log(louis.hasOwnProperty(\"name\")) // affiche true. C'est la m\u00e9thode d'Object qui a \u00e9t\u00e9 ex\u00e9cut\u00e9e Person.prototype.hasOwnProperty = function(text){ return(text) } console.log(louis.hasOwnProperty(\"name\")) // affiche name. C'est la m\u00e9thode red\u00e9finie dans le prototype de Person qui a \u00e9t\u00e9 ex\u00e9cut\u00e9e Les classes (ES6) Avec l'arriv\u00e9e d'ES6, pour construire un objet, au lieu de faire une fonction constructeur et ajouter des m\u00e9thodes sur le prototype, on peut cr\u00e9er des classes. En ES5 : function Person(name, age){ this.name = name this.age = age } Person.prototype.present = function(){ console.log(\"Hello my name is \" + this.name) } let louis = new Person(\"Louis\", 0) louis.present() // affiche : Hello my name is Louis En ES6 avec les classes : class Person { constructor(name, age){ this.name = name this.age = age } present(){ console.log(\"Hello my name is \" + this.name) } } let louis = new Person(\"Louis\", 0) louis.present() // affiche : Hello my name is Louis Pour cr\u00e9er un objet avec les classes, c'est comme avant avec le mot cl\u00e9 new . Le changement est uniquement syntaxique pour simplifier l'\u00e9criture du code. L'objet cr\u00e9\u00e9 est exactement le m\u00eame que si on l'avait cr\u00e9\u00e9 avec la fonction constructeur et en d\u00e9clarant les m\u00e9thodes dans le prototype.","title":"Vraiment bien comprendre JavaScript"},{"location":"javascript/vraimentBienComprendreJavaScript/#vraiment-bien-comprendre-javascript","text":"","title":"Vraiment bien comprendre JavaScript"},{"location":"javascript/vraimentBienComprendreJavaScript/#-","text":"","title":"----"},{"location":"javascript/vraimentBienComprendreJavaScript/#les-variables","text":"","title":"Les variables"},{"location":"javascript/vraimentBienComprendreJavaScript/#les-differents-types-de-variables","text":"console.log(true); console.log(typeof true) // boolean console.log(1); console.log(typeof 1) // number console.log(\"Louis\"); console.log(typeof \"Louis\") // string console.log({name: \"Louis\"}); console.log(typeof {name: \"Louis\"}) // object Diff\u00e9rence entre undefined , null et is not defined - undefined : variable d\u00e9clar\u00e9e mais n'a pas re\u00e7u de valeur - null : variable d\u00e9finie par l'utilisateur - is not defined : variable non d\u00e9clar\u00e9e var a; console.log(a) // undefined var b = null; console.log(b) // null console.log(c) // c is not defined","title":"Les diff\u00e9rents types de variables"},{"location":"javascript/vraimentBienComprendreJavaScript/#le-hoisting-hissage","text":"JavaScript passe le code en revu et recherche les d\u00e9clarations de fonction et les hisse dans le haut de code, ce qui fait qu'on peut ex\u00e9cuter une fonction avant de la d\u00e9clarer. addition(1,3) function addition(a,b){ console.log(a+b) } Cela fonctionne pour les d\u00e9clarations de fonction, mais pas pour les fonctions anonymes stock\u00e9es dans une variable comme l'exemple ci-dessous. Pour que cet exemple fonctionne, il faut appeler addition() apr\u00e8s sa d\u00e9claration. addition(1,3) var addition = function(a,b){ console.log(a+b) } JavaScript hisse \u00e9galement la d\u00e9claration des variables, sans l'assignation de la valeur. console.log(x) // undefined var x = 5 console.log(y) // y is not defined C'est comme-ci on avait fait : var x console.log(x) // undefined var x = 5","title":"Le hoisting (hissage)"},{"location":"javascript/vraimentBienComprendreJavaScript/#les-types-primitifs-vs-les-objets","text":"Les variables de type primitif sont copi\u00e9s par valeur, les variables de type objet sont copi\u00e9s par r\u00e9f\u00e9rence. var x = 5 // 5 est stock\u00e9 en m\u00e9moire dans la variable x var y = x // 5 est stock\u00e9 en m\u00e9moire dans la variable y y = 8 // 8 est stock\u00e9 en m\u00e9moire dans la variable y console.log(x) console.log(y) var a = {name: \"Louis\"} // un espace m\u00e9moire est cr\u00e9\u00e9 pour stocker l'objet `{name:\"Louis\"}` et l'adresse de cet espace m\u00e9moire est stock\u00e9e dans l'espace m\u00e9moire de la variable a. On dit que l'espace m\u00e9moire de a est un pointeur. console.log(a) // affiche {name: \"Louis\"} var b = a // un espace m\u00e9moire est cr\u00e9e pour b qui pointe vers le m\u00eame objet que a b.name = \"Ga\u00ebtan\" // comme a et b pointe vers le m\u00eame objet, la modification de b entra\u00eene donc la modification de a console.log(a) // affiche {name: \"Ga\u00ebtan\"} console.log(b) // affiche {name: \"Ga\u00ebtan\"} var a = {name: \"Louis\"} console.log(a) // affiche {name: \"Louis\"} var b = a b = {name: \"Ga\u00ebtan\"} // cr\u00e9e un nouvel objet qui est stock\u00e9 dans un nouvel espace m\u00e9moire. b ne pointe donc plus vers le m\u00eame objet que a console.log(a) // affiche {name: \"Louis\"} console.log(b) // affiche {name: \"Ga\u00ebtan\"}","title":"Les types primitifs vs les objets"},{"location":"javascript/vraimentBienComprendreJavaScript/#la-declaration-des-variables","text":"Avec l'ES6, en plus du mot cl\u00e9 var , on peut utiliser les mots-cl\u00e9s let et const . var a = 5 console.log(a) // 5 let b = 6 console.log(b) // 6 const c = 7 console.log(c) // 7 Une constante doit avoir une valeur d\u00e8s sa d\u00e9claration et ne pas peut \u00eatre modifi\u00e9e. On ne peut pas faire : ```js const a; // ERREUR const b = 1; b=2; // ERREUR On ne peut pas assigner un nouvel objet \u00e0 une variable `const` mais on peut modifier les propri\u00e9t\u00e9s d'un objet ```js const a = {name: \"Louis\"} a.name = \"Ga\u00ebtan\" console.log(a) // {name: \"Ga\u00ebtan\"} const b = {name: \"Louis\"} b = {name: \"Ga\u00ebtan\"} // Erreur : on ne peut pas modifier la valeur d'une const Il n'y a pas de hissage avec const et let comme avec var console.log(a) // undefined var a = 5 console.log(b) // b is not defined let b = 5","title":"La d\u00e9claration des variables"},{"location":"javascript/vraimentBienComprendreJavaScript/#quand-utiliser-let-const-et-var","text":"ne plus utiliser le var toujours utiliser le const si on r\u00e9assigne une valeur \u00e0 la variable, utiliser le let","title":"Quand utiliser let, const et var"},{"location":"javascript/vraimentBienComprendreJavaScript/#-_1","text":"","title":"----"},{"location":"javascript/vraimentBienComprendreJavaScript/#les-scopes","text":"","title":"Les scopes"},{"location":"javascript/vraimentBienComprendreJavaScript/#contexte-dexecution","text":"Un contexte d'ex\u00e9cution est un contexte dans lequel un certain bout de code est ex\u00e9cut\u00e9. Cela concerne les infos sur les variables qu'il va d\u00e9finir, auquel il va pouvoir acc\u00e9der... A chaque fois qu'une fonction est ex\u00e9cut\u00e9e , un nouveau contexte d'ex\u00e9cution est cr\u00e9\u00e9. Pour le code qui n'est pas dans une fonction, il appartient au contexte d'ex\u00e9cution global. Un contexte d'ex\u00e9cution est compos\u00e9 de 3 choses : 1. l'objet des variables : fonctions et variables qui sont d\u00e9finies dans ce bout de code 2. la cha\u00eene des scopes : variables auquel peut acc\u00e9der ce bout de code 3. le this : l'objet associ\u00e9 \u00e0 ce bout de code","title":"Contexte d'ex\u00e9cution"},{"location":"javascript/vraimentBienComprendreJavaScript/#lobjet-des-variables","text":"L'objet des variables, ou Variable Objet (VO) , est cr\u00e9\u00e9 et initialis\u00e9 pendant la phase de cr\u00e9ation du contexte d'ex\u00e9cution. Il contient : - les arguments de la fonction - les d\u00e9clarations de fonctions avec le hoisting - les d\u00e9clarations de variables avec le hoisting (les variables d\u00e9clar\u00e9es avec var )","title":"L'objet des variables"},{"location":"javascript/vraimentBienComprendreJavaScript/#la-chaine-des-scopes","text":"Le scope veut dire port\u00e9e en fran\u00e7ais. Cela permet de savoir \u00e0 quel endroit du code il est possible d'acc\u00e9der \u00e0 quelle variable. Le code qui n'appartient \u00e0 aucune fonction appartient au scope global. A chaque fois qu'une fonction est ex\u00e9cut\u00e9e, un scope local est cr\u00e9\u00e9, on parle de scope de fonction . Pour les variables cr\u00e9\u00e9es avec let et const , un scope de bloc est cr\u00e9\u00e9 (cf ci-apr\u00e8s). Une r\u00e8gle de base sur les scopes est qu'une fonction enfant peut acc\u00e9der au scope de ses parents, c'est-\u00e0-dire \u00e0 son objet des variables ainsi qu'\u00e0 l'objet des variables de ses parents. Si on d\u00e9clare une variable dans une fonction alors qu'une variable avec le m\u00eame nom existe d\u00e9j\u00e0 dans un scope sup\u00e9rieur, une nouvelle variable est d\u00e9finie, dans un espace m\u00e9moire diff\u00e9rent, et c'est celle du scope local qui est utilis\u00e9e. Lorsqu'on cherche une variable, on cherche d'abord la variable dans le scope local et si elle n'existe pas, on remonte la cha\u00eene des scopes jusqu'\u00e0 trouver notre variable.","title":"La cha\u00eene des scopes"},{"location":"javascript/vraimentBienComprendreJavaScript/#le-scope-de-bloc-es6","text":"Chaque fonction cr\u00e9e un nouvdau scope. Jusqu'\u00e0 l'arriv\u00e9e d'ES6, il n'y avait que le scope de fonction. Lorsqu'on d\u00e9clare des variables avec let et const , les variables ne respectent pas les scopes de fonction mais les scopes de bloc. Un bloc est tout ce qui est entre accolades. Par exemple, le code suivant ne fonctionne pas alors que \u00e7a aurait fonctionn\u00e9 avec le mot cl\u00e9 var . if(true){ let a = 5; } console.log(a) // a is not defined L'exemple suivant fonctionne car la variable est d\u00e9finie dans le m\u00eame scope qu'on souhaite l'afficher let a if(true){ a = 5; } console.log(a) // affiche 5 Il faut \u00e9viter d'utiliser le mot cl\u00e9 var et privil\u00e9gier const et let pour \u00e9viter les mauvaises surprises. Par exemple : var i = 62 for(i = 0 ; i < 10 ; i++){ console.log(i) } console.log(i) // affiche 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 et 10 let i = 62 for(let i = 0 ; i < 10 ; i++){ console.log(i) } console.log(i) // affiche 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 et 62","title":"Le scope de bloc (ES6)"},{"location":"javascript/vraimentBienComprendreJavaScript/#-_2","text":"","title":"----"},{"location":"javascript/vraimentBienComprendreJavaScript/#les-fonctions","text":"","title":"Les fonctions"},{"location":"javascript/vraimentBienComprendreJavaScript/#fonction-premiere-classe","text":"Les fonctions sont des objets de premi\u00e8re classe, c'est-\u00e0-dire que ce sont des objets comme les autres. une fonction peut prendre une fonction en argument function addTwo(numberToAdd){ return numberToAdd + 2 } function myFunction(argFunction, number){ const x = argFunction(number) console.log(x) } myFunction(addTwo, 5) // affiche 7 une fonction peut retourner une autre fonction function myFunction(){ return function(number){ return number * 2 } } console.log(myFunction) // affiche la d\u00e9claration de myFonction console.log(myFunction()) // affiche la d\u00e9claration de la fonction anonyme : \u0192unction(number){return number * 2} console.log(myFunction()(3)) // affiche 6 on peut assigner une fonction \u00e0 une variable const returnedFunction = function(){ return 5+2 } console.log(returnedFunction()) // affiche 7 function myFunction(){ return 5+2 } const returnedFunction = myFunction() console.log(returnedFunction) // affiche 7","title":"Fonction Premi\u00e8re Classe"},{"location":"javascript/vraimentBienComprendreJavaScript/#les-closures","text":"Une closure, est une fermeture. C'est une fonction qui a enferm\u00e9 avec elle des variables qui lui sont externes, provenant d'un scope parent. function multiplyBy(number){ const closedVariable = number return function(anotherNumber){ return closedVariable * anotherNumber } } const multiplyByFive = multiplyBy(5) const multiplyByThree = multiplyBy(3) console.log(multiplyByFive) // function(anotherNumber){return closedVariable * anotherNumber} console.log(multiplyByFive(2)) // 10 console.log(multiplyByThree(2)) // 6 Dans cet exemple, mutilyByFive utilise la variable closedVariable lors de son ex\u00e9cution avec lesparam\u00e8tre 2, alors que closedVariable fait parti du contexte d'ex\u00e9cution de multiplyBy(5) qui a disparu apr\u00e8s l'ex\u00e9cution de la fonction, donc closedVariable devrait avoir disparu, mais il est toujours disponible dans multiplyByFive, c'est ce qu'on appelle une closure car la fonction a captur\u00e9 une variable d'un scope parent. C'est la m\u00eame chose pour multiplyByThree.","title":"Les closures"},{"location":"javascript/vraimentBienComprendreJavaScript/#mefiez-vous-des-scopes","text":"Il faut prot\u00e9ger ses variables pour \u00e9viter qu'elles soient \"pirat\u00e9es\" par un autre script. Exemple avec une page HTML qui charge 3 scripts : <!DOCTYPE html> <html> <head> <script src=\"script1.js\"></script> <script src=\"script2.js\"></script> <script src=\"script3.js\"></script> </head> // script1.js var myPassword = \"12345\" function setPassword(newPassword){ myPassword = newPassword } function getPassword(){ return myPassword } // script2.js var myPassword = \"000\" // script3.js console.log(getPassword()) // affiche 000 alors qu'on voulait 12345 Dans le script 3, on veut r\u00e9cup\u00e9rer myPassword de script 1 mais elle a \u00e9t\u00e9 \u00e9cras\u00e9 par myPassword du script 2 car les variables ont le m\u00eame nom et elles sont toutes les 2 dans le scope global. Il faut \u00e9viter au maximum de rattacher les variables au scope global. Il faut d\u00e9finir ce qu'on souhaite rendre priv\u00e9 (uniquement utilisable dans le script courant) et ce qu'on veut rendre public, c'est-\u00e0-dire rendre accessible aux autres scripts. Pour cela on va utiliser les IIFEs","title":"M\u00e9fiez-vous des scopes"},{"location":"javascript/vraimentBienComprendreJavaScript/#iifes","text":"Les fonctions imm\u00e9diatement ex\u00e9cut\u00e9es se nomment des Immediatly-Invoked Function Expression , abr\u00e9g\u00e9es IIFE. L'id\u00e9e est d\u00e9clarer la fonction et de l'ex\u00e9cuter en m\u00eame temps. En utilisant une IIFE, tout le code ex\u00e9cut\u00e9 dedans sera priv\u00e9 et non accessible de l'ext\u00e9rieur. // fonction classique function myFunction(){ // code de la fonction } // IIFE (function(){ // code de la fonction })() Pour revenir \u00e0 notre exemple pr\u00e9c\u00e9dent o\u00f9 lon veut rendre public getPassword() et rendre priv\u00e9 myPassword et setPassword , on peut utiliser les IIFEs et les closures pour r\u00e9soudre ce probl\u00e8me. const getPassword = (function(){ var myPassword = \"12345\" function setPassword(newPassword){ myPassword = newPassword } return function(){ return myPassword } })() Cet exemple permet de rendre accessible la fonction getPassword uniquement de ce script. Cependant, cela permet uniquement d'exposer une variable ou une fonction. Il est possible de rendre public plusieurs \u00e9l\u00e9ments public en retournant un objet : const script1 = (function(){ var myPassword = \"12345\" function setPassword(newPassword){ myPassword = newPassword } function getPassword(){ return myPassword } return { getPassword: getPassword, setPassword: setPassword, } })() // appel dans le script 3 console.log(script1.getPassword())","title":"IIFEs"},{"location":"javascript/vraimentBienComprendreJavaScript/#le-mot-cle-this","text":"A chaque contexte d'ex\u00e9cution est associ\u00e9 un objet. this permet d'acc\u00e9der \u00e0 cet objet. console.log(this) // donne Window qui est l'objet global dans le navigateur. JavaScript ex\u00e9cut\u00e9 dans un autre environnement comme un serveur aurait donn\u00e9 un autre objet global. Le this est l'objet qui a ex\u00e9cut\u00e9 la m\u00e9thode, sinon ce sera l'objet global function first(){ console.log(this) } first() // Window const louis = { name: \"Louis\", present: first } louis.present() // {name: \"Louis\", present: \u0192}","title":"Le mot cl\u00e9 THIS"},{"location":"javascript/vraimentBienComprendreJavaScript/#choses-bizarres","text":"Les d\u00e9clarations de variables avec var et les d\u00e9clarations de fonctions dans le contexte d'ex\u00e9cution global sont stock\u00e9es dans l'objet global Window. Ce n'est pas le cas pour les variables d\u00e9clar\u00e9es avec let et const . var a = 5 function allo(){ } console.log(this) // on retrouve a et allo() dans Window var myName = \"Louis\" console.log(window.myName === this.myName && window.myName === myName) // affiche true Si on oublie le mot cl\u00e9 var pour d\u00e9clarer une variable, elle est automatiquement rattach\u00e9 \u00e0 l'objet global, m\u00eame si elle est d\u00e9clar\u00e9e dans une fonction. function allo(){ b = 9 } allo() console.log(this) // on retrouve b dans l'objet Window Pour \u00e9viter cela, on peut utiliser le mode strict en ajoutant la commande 'use strict' en haut du fichier javascript et ce qui aura pour effet dans le script pr\u00e9c\u00e9dent de renvoyer une erreur en disant que b n'est pas d\u00e9fini.","title":"Choses bizarres"},{"location":"javascript/vraimentBienComprendreJavaScript/#bind-call-et-apply","text":"Ces m\u00e9thodes vont permettre de contr\u00f4ler la valeur du this . bind est une m\u00e9thode qui permet de changer la valeur du this en appliquant le this d'un autre objet. function first(){ console.log(this) } first() // affiche l'objet global Window const louis = { name: \"Louis\", present: function(){ console.log(this) } } const second = first.bind(louis) // fixe le this de louis sur la fonction second second() // affiche l'objet louis louis.present() // affiche l'objet louis louis.present.bind(window)() // affiche l'objet Window car on a chang\u00e9 la valeur de this en mettant Window \u00e0 la place de louis Voici quelques autres exemples var name = \"Louis\" function present(){ console.log(this.name) } const kev = { name: \"K\u00e9vin\", present: present } const thib = { name: \"Thibaut\", present: present.bind(this) } const presentKev = kev.present const presentKevBind = kev.present.bind(kev) const presentKevBind2 = kev.present.bind(this) present() // affiche Louis : comme ce n'est pas un objet qui ex\u00e9cute la fonction, c'est l'objet global Window qui l'ex\u00e9cute. Le this est donc associ\u00e9 \u00e0 Window, on cherche donc \u00e0 logguer un window.name et on a d\u00e9clar\u00e9 la variable name dans le scope global, qui est donc attach\u00e9 \u00e0 l'objet Window, donc window.name = \"John\" kev.present() // affiche K\u00e9vin : present est ex\u00e9cut\u00e9e en tant que m\u00e9thode de l'objet kev donc le this est kev presentKev() // affiche Louis : presentKev est \u00e9gale \u00e0 une m\u00e9thode d'un objet mais elle est ex\u00e9cut\u00e9e en tant que fonction et n'est pas associ\u00e9e \u00e0 un objet, le this est donc Window presentKevBind() // affiche K\u00e9vin : comme la m\u00e9thode pr\u00e9c\u00e9dente sauf que le this a \u00e9t\u00e9 bind\u00e9 avec l'objet kev presentKevBind2() // affiche Louis comme pour presentKev en bindant le this qui correspond \u00e0 Window, donc \u00e7a ne change rien de faire le bind dans ce cas thib.present() // affiche Louis : la m\u00e9thode present est bind\u00e9e avec this dans l'objet franck et le this correspond \u00e0 Window \u00e0 ce moment l\u00e0 bind permet aussi de fixer la valeur des arguments que va prendre la nouvelle fonction que l'on cr\u00e9e. function multiply(number1, number2){ return number1 * number2 } // on fixe la valeur du premier argument de multiply \u00e0 2. // multiplyByTwo prend donc un seul argument qui correspond au number2 de multiply const multiplyByTwo = multiply.bind(this, 2) console.log(multiplyByTwo(3)) // affiche 6 Les m\u00e9thodes call et apply ne cr\u00e9ent pas une nouvelle fonction qu'il faut ensuite ex\u00e9cuter comme bind , elles l'ex\u00e9cutent directement. function multiply(number1, number2){ console.log(this) console.log(number1 * number2) } const louis = { name: \"Louis\" } multiply.bind(louis, 2, 3)() // affiche louis et 6 // call ex\u00e9cute directement multiplly multiply.call(louis, 2, 3) // affiche Window et 6 comme bind // apply prend les arguments de la fonction dans un tableau multiply.apply(louis, [2, 3]) // affiche Window et 6 comme bind","title":"Bind, Call et Apply"},{"location":"javascript/vraimentBienComprendreJavaScript/#les-fonctions-flechees-arrow-functions","text":"Les fonctions fl\u00e9ch\u00e9es ont 2 particularit\u00e9es : - la syntaxe est plus rapide - elles vont fixer la valeur du this automatiquement La syntaxe : const myFunction = arg => arg * 5 console.log(myFunction(3)) // affiche 15 const myFunction2 = () => 4 * 5 console.log(myFunction2()) // affiche 20 const myFunction3 = (nombre1, nombre2) => nombre1 * nombre2 console.log(myFunction3(3, 4)) // affiche 12 On peut utiliser des accolades si la fonction fait davantage que retourner une valeur, comme par exemple ex\u00e9cuter du code avant. const myFunction3 = (nombre1, nombre2) => { const nombreCalcule = nombre1 * nombre1 return nombreCalcule * nombre2 } console.log(myFunction3(3, 4)) // affiche 36 (3 * 3 * 4) Fonctionne aussi sur les objets louis = { name: \"Louis\", // syntaxe classique present: function(friend){ return \"Tu connais \"+friend+\" ?\" }, // nouvelle syntaxe presentArrow: friend => \"Tu connais \"+friend+\" ?\" } console.log(louis.present(\"K\u00e9vin\")) console.log(louis.presentArrow(\"Thibaut\")) Les fonctions fl\u00e9ch\u00e9es fixent la valeur du this automatiquement. Dans l'exemple ci-dessous, le this de presentClassic est l'objet louis car c'est l'objet louis qui a ex\u00e9cut\u00e9 la m\u00e9thode. Pour presentArrow , son this est Windows. Une fonction fl\u00e9ch\u00e9e capture le this du scope parent o\u00f9 elle a \u00e9tait d\u00e9clar\u00e9e. Il faut donc regarder \u00e0 quoi correspond le this de l'endroit o\u00f9 elle a \u00e9t\u00e9 d\u00e9clar\u00e9e. Cela revient au m\u00eame que l'ex\u00e9cution d'une fonction classique o\u00f9 on aurait bind\u00e9 le this. function classicFunction(){ console.log(this) } const classicFunctionBind = classicFunction.bind(this) const arrowFunction = () => { console.log(this) } const louis = { name: \"Louis\", presentClassic: classicFunction, presentClassicBind: classicFunctionBind, presentArrow: arrowFunction, } louis.presentClassic() // affiche louis louis.presentClassicBind() // affiche Window louis.presentArrow() // affiche Window","title":"Les fonctions fl\u00e9ch\u00e9es (Arrow Functions)"},{"location":"javascript/vraimentBienComprendreJavaScript/#-_3","text":"","title":"----"},{"location":"javascript/vraimentBienComprendreJavaScript/#les-objets","text":"","title":"Les objets"},{"location":"javascript/vraimentBienComprendreJavaScript/#fonction-constructeur","text":"Une fonction constructeur est un moule. En ex\u00e9cutant cette fonction, on cr\u00e9e des instances bas\u00e9es sur ce moule. function Person(name, age){ this.name = name this.age = age this.present = () => {console.log(\"Hello my name is \"+this.name)} } let louis = new Person(\"Louis\", 0) let thibaut = new Person(\"Thibaut\", 23) louis.present() // Hello my name is Louis thibaut.present() // Hello my name is Thibaut console.log(louis) // affiche l'objet louis console.log(thibaut) // affiche l'objet thibaut console.log(louis.present === thibaut.present) // affiche false present de louis et present de thibaut sont 2 m\u00e9thodes diff\u00e9rentes qui font la m\u00eame chose, donc elles sont stock\u00e9es deux fois en m\u00e9moire alors qu'on aurait pu les stocker qu'une fois. On va pouvoir faire cela avec les prototypes.","title":"Fonction constructeur"},{"location":"javascript/vraimentBienComprendreJavaScript/#les-prototypes","text":"On va stocker la fonction dans le prototype de Person, comme \u00e7a elle sera unique. Il faut utiliser une fonction classique au lieu d'une fonction fl\u00e9ch\u00e9e, car une fonction fl\u00e9ch\u00e9e capturerait le this de l'endroit o\u00f9 elle est d\u00e9clar\u00e9e, c'est-\u00e0-dire l'objet global. function Person(name, age){ this.name = name this.age = age //this.present = () => {console.log(\"Hello my name is \"+this.name)} } Person.prototype.present = function(){ console.log(\"Hello my name is \"+this.name) } let louis = new Person(\"Louis\", 0) let thibaut = new Person(\"Thibaut\", 23) louis.present() // Hello my name is Louis console.log(louis.present === thibaut.present) // affiche true Dans l'exemple pr\u00e9c\u00e9dent sans utiliser les prototypes, si on regarde ce que contient l'objet Person , il y a les attributs name et age , la fonction present , et l'objet __proto__ , qui contient lui-m\u00eame le constructeur de Person . En d\u00e9clarant la fonction dans le prototype, la fonction present n'est plus dans l'objet Person mais dans l'objet __proto__ . __proto__ correspond au prototype de la personne et il est accessible \u00e0 toutes les instances cr\u00e9\u00e9es avec la fonction constructeur Person . console.log(louis.__proto__ === Person.prototype) // affiche true console.log(louis.__proto__ === thibaut.__proto__) // affiche true","title":"Les prototypes"},{"location":"javascript/vraimentBienComprendreJavaScript/#tout-est-un-objet","text":"Si on rentre dans l'objet __proto__ de Person , il y a un autre __proto__ qui est celui d' Object . Object est l'objet le plus haut, il n'y a rien au dessus. Pratiquement tout en Javascript descend d' Object , comme par exemple les Array (tableaux), les String , les Number , les fonctions. Exemple en partant du code de l'exemple pr\u00e9c\u00e9dent : const myObject = {} console.log(louis.__proto__.__proto__ === myObject.__proto__) // affiche true Cela permet d'utiliser les m\u00e9thodes des objets parents, comme par exemple la m\u00e9thode hasOwnProperty qui renvoi un bool\u00e9en pour savoir si une propri\u00e9t\u00e9e pass\u00e9e en param\u00e8tre existe dans l'objet. console.log(louis.hasOwnProperty(\"name\")) // affiche true console.log(louis.hasOwnProperty(\"color\")) // affiche false","title":"Tout est un objet"},{"location":"javascript/vraimentBienComprendreJavaScript/#la-chaine-des-constructeurs","text":"Les objets ont acc\u00e8s aux m\u00e9thodes d\u00e9clar\u00e9es dans la fonction constructeur, dans le prototype, et aux m\u00e9thodes des prototypes parents, notamment d' Object . Si une m\u00e9thode \u00e0 le m\u00eame nom dans la fonction constructeur et dans le prototype, c'est celle dans la fonction constructeur qui sera ex\u00e9cut\u00e9e car il y a un ordre de pr\u00e9f\u00e9rence. C'est ce qu'on appelle la cha\u00eene des prototypes : - la m\u00e9thode est d'abord recherch\u00e9e sur notre objet lui-m\u00eame - si rien n'est trouv\u00e9, elle est cherch\u00e9e sur le prototype de notre objet - si rien n'est encore trouv\u00e9, elle est cherch\u00e9e sur le prototype de l'objet parent, par exemple Object function Person(name, age){ this.name = name this.age = age } let louis = new Person(\"Louis\", 0) console.log(louis.hasOwnProperty(\"name\")) // affiche true. C'est la m\u00e9thode d'Object qui a \u00e9t\u00e9 ex\u00e9cut\u00e9e Person.prototype.hasOwnProperty = function(text){ return(text) } console.log(louis.hasOwnProperty(\"name\")) // affiche name. C'est la m\u00e9thode red\u00e9finie dans le prototype de Person qui a \u00e9t\u00e9 ex\u00e9cut\u00e9e","title":"La cha\u00eene des constructeurs"},{"location":"javascript/vraimentBienComprendreJavaScript/#les-classes-es6","text":"Avec l'arriv\u00e9e d'ES6, pour construire un objet, au lieu de faire une fonction constructeur et ajouter des m\u00e9thodes sur le prototype, on peut cr\u00e9er des classes. En ES5 : function Person(name, age){ this.name = name this.age = age } Person.prototype.present = function(){ console.log(\"Hello my name is \" + this.name) } let louis = new Person(\"Louis\", 0) louis.present() // affiche : Hello my name is Louis En ES6 avec les classes : class Person { constructor(name, age){ this.name = name this.age = age } present(){ console.log(\"Hello my name is \" + this.name) } } let louis = new Person(\"Louis\", 0) louis.present() // affiche : Hello my name is Louis Pour cr\u00e9er un objet avec les classes, c'est comme avant avec le mot cl\u00e9 new . Le changement est uniquement syntaxique pour simplifier l'\u00e9criture du code. L'objet cr\u00e9\u00e9 est exactement le m\u00eame que si on l'avait cr\u00e9\u00e9 avec la fonction constructeur et en d\u00e9clarant les m\u00e9thodes dans le prototype.","title":"Les classes (ES6)"}]}